<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.1" />
<title>tkintertable.Tables API documentation</title>
<meta name="description" content="Implements the core TableCanvas class.
Created Oct 2008
Copyright (C) Damien Farrell â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tkintertable.Tables</code></h1>
</header>
<section id="section-intro">
<p>Implements the core TableCanvas class.
Created Oct 2008
Copyright (C) Damien Farrell</p>
<p>This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307
USA</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#!/usr/bin/env python
&#34;&#34;&#34;
    Implements the core TableCanvas class.
    Created Oct 2008
    Copyright (C) Damien Farrell

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
&#34;&#34;&#34;

from __future__ import absolute_import, division, print_function
try:
    from tkinter import *
    from tkinter.ttk import *
except:
    from Tkinter import *
    from ttk import *
if (sys.version_info &gt; (3, 0)):
    from tkinter import filedialog, messagebox, simpledialog
    from tkinter import font
    import tkinter.colorchooser as tkColorChooser
else:
    import tkFileDialog as filedialog
    import tkSimpleDialog as simpledialog
    import tkMessageBox as messagebox
    import tkFont as font
    import tkColorChooser

from .TableModels import TableModel
from .TableFormula import Formula
from .Prefs import Preferences
from .Dialogs import *

import math, time
import os, types
import copy
import platform

class TableCanvas(Canvas):
    &#34;&#34;&#34;A tkinter class for providing table functionality&#34;&#34;&#34;

    def __init__(self, parent=None, model=None, data=None, read_only=False,
                 width=None, height=None,
                 rows=10, cols=5, **kwargs):
        Canvas.__init__(self, parent, bg=&#39;white&#39;,
                         width=width, height=height,
                         relief=GROOVE,
                         scrollregion=(0,0,300,200))
        self.parentframe = parent
        #get platform into a variable
        self.ostyp = self.checkOSType()
        self.platform = platform.system()
        self.width = width
        self.height = height
        self.set_defaults()

        self.currentpage = None
        self.navFrame = None
        self.currentrow = 0
        self.currentcol = 0
        self.reverseorder = 0
        self.startrow = self.endrow = None
        self.startcol = self.endcol = None
        self.allrows = False       #for selected all rows without setting multiplerowlist
        self.multiplerowlist=[]
        self.multiplecollist=[]
        self.col_positions=[]       #record current column grid positions
        self.mode = &#39;normal&#39;
        self.read_only = read_only
        self.filtered = False

        self.loadPrefs()
        #set any options passed in kwargs to overwrite defaults and prefs
        for key in kwargs:
            self.__dict__[key] = kwargs[key]

        if data is not None:
            self.model = TableModel()
            self.model.importDict(data)
        elif model is not None:
            self.model = model
        else:
            self.model = TableModel(rows=rows,columns=cols)

        self.rows = self.model.getRowCount()
        self.cols = self.model.getColumnCount()
        self.tablewidth = (self.cellwidth)*self.cols
        self.do_bindings()
        #initial sort order
        self.model.setSortOrder()

        #column specific actions, define for every column type in the model
        #when you add a column type you should edit this dict
        self.columnactions = {&#39;text&#39; : {&#34;Edit&#34;:  &#39;drawCellEntry&#39; },
                              &#39;number&#39; : {&#34;Edit&#34;: &#39;drawCellEntry&#39; }}
        self.setFontSize()
        return

    def set_defaults(self):
        &#34;&#34;&#34;Set default settings&#34;&#34;&#34;

        self.cellwidth=150
        self.maxcellwidth=200
        self.rowheight=20
        self.horizlines=1
        self.vertlines=1
        self.alternaterows=0
        self.autoresizecols = 0
        self.inset=2
        self.x_start=0
        self.y_start=1
        self.linewidth=1.0
        self.rowheaderwidth=40
        self.showkeynamesinheader=False
        self.thefont = (&#39;Arial&#39;,12)
        self.cellbackgr = &#39;#F7F7FA&#39;
        self.entrybackgr = &#39;white&#39;
        self.grid_color = &#39;#ABB1AD&#39;
        self.selectedcolor = &#39;yellow&#39;
        self.rowselectedcolor = &#39;#CCCCFF&#39;
        self.multipleselectioncolor = &#39;#ECD672&#39;
        return

    def setFontSize(self):
        &#34;&#34;&#34;Set font size to match font, we need to get rid of fontsize as
            a separate variable?&#34;&#34;&#34;

        if hasattr(self, &#39;thefont&#39;) and type(self.thefont) is tuple:
            self.fontsize = self.thefont[1]
        return

    def mouse_wheel(self, event):
        &#34;&#34;&#34;Handle mouse wheel scroll for windows&#34;&#34;&#34;

        if event.num == 5 or event.delta == -120:
            event.widget.yview_scroll(1, UNITS)
            self.tablerowheader.yview_scroll(1, UNITS)
        if event.num == 4 or event.delta == 120:
            if self.canvasy(0) &lt; 0:
                return
            event.widget.yview_scroll(-1, UNITS)
            self.tablerowheader.yview_scroll(-1, UNITS)
        self.redrawVisible()
        return

    def do_bindings(self):
        &#34;&#34;&#34;Bind keys and mouse clicks, this can be overriden&#34;&#34;&#34;
        self.bind(&#34;&lt;Button-1&gt;&#34;,self.handle_left_click)
        self.bind(&#34;&lt;Double-Button-1&gt;&#34;,self.handle_double_click)
        self.bind(&#34;&lt;Control-Button-1&gt;&#34;, self.handle_left_ctrl_click)
        self.bind(&#34;&lt;Shift-Button-1&gt;&#34;, self.handle_left_shift_click)

        self.bind(&#34;&lt;ButtonRelease-1&gt;&#34;, self.handle_left_release)
        if self.ostyp==&#39;mac&#39;:
            #For mac we bind Shift, left-click to right click
            self.bind(&#34;&lt;Button-2&gt;&#34;, self.handle_right_click)
            self.bind(&#39;&lt;Shift-Button-1&gt;&#39;,self.handle_right_click)
        else:
            self.bind(&#34;&lt;Button-3&gt;&#34;, self.handle_right_click)

        self.bind(&#39;&lt;B1-Motion&gt;&#39;, self.handle_mouse_drag)
        self.bind(&#39;&lt;Motion&gt;&#39;, self.handle_motion)

        self.bind_all(&#34;&lt;Control-x&gt;&#34;, self.deleteRow)
        self.bind_all(&#34;&lt;Control-n&gt;&#34;, self.addRow)
        self.bind_all(&#34;&lt;Delete&gt;&#34;, self.clearData)
        self.bind_all(&#34;&lt;Control-v&gt;&#34;, self.paste)

        #if not hasattr(self,&#39;parentapp&#39;):
        #    self.parentapp = self.parentframe

        self.parentframe.master.bind_all(&#34;&lt;Right&gt;&#34;, self.handle_arrow_keys)
        self.parentframe.master.bind_all(&#34;&lt;Left&gt;&#34;, self.handle_arrow_keys)
        self.parentframe.master.bind_all(&#34;&lt;Up&gt;&#34;, self.handle_arrow_keys)
        self.parentframe.master.bind_all(&#34;&lt;Down&gt;&#34;, self.handle_arrow_keys)
        self.parentframe.master.bind_all(&#34;&lt;KP_8&gt;&#34;, self.handle_arrow_keys)
        self.parentframe.master.bind_all(&#34;&lt;Return&gt;&#34;, self.handle_arrow_keys)
        self.parentframe.master.bind_all(&#34;&lt;Tab&gt;&#34;, self.handle_arrow_keys)
        #if &#39;windows&#39; in self.platform:
        self.bind(&#34;&lt;MouseWheel&gt;&#34;, self.mouse_wheel)
        self.bind(&#39;&lt;Button-4&gt;&#39;, self.mouse_wheel)
        self.bind(&#39;&lt;Button-5&gt;&#39;, self.mouse_wheel)
        self.focus_set()
        return

    def getModel(self):
        &#34;&#34;&#34;Get the current table model&#34;&#34;&#34;
        return self.model

    def setModel(self, model):
        &#34;&#34;&#34;Set a new model - requires redraw to reflect changes&#34;&#34;&#34;
        self.model = model
        return

    def createfromDict(self, data):
        &#34;&#34;&#34;Attempt to create a new model/table from a dict&#34;&#34;&#34;

        try:
            namefield=self.namefield
        except:
            namefield=data.keys()[0]
        self.model = TableModel()
        self.model.importDict(data, namefield=namefield)
        self.model.setSortOrder(0,reverse=self.reverseorder)
        return

    def createTableFrame(self, callback=None):
        self.show(callback)
        return

    def show(self, callback=None):
        &#34;&#34;&#34;Adds column header and scrollbars and combines them with
           the current table adding all to the master frame provided in constructor.
           Table is then redrawn.&#34;&#34;&#34;

        #Add the table and header to the frame
        self.tablerowheader = RowHeader(self.parentframe, self, width=self.rowheaderwidth)
        self.tablecolheader = ColumnHeader(self.parentframe, self)
        self.Yscrollbar = AutoScrollbar(self.parentframe,orient=VERTICAL,command=self.set_yviews)
        self.Yscrollbar.grid(row=1,column=2,rowspan=1,sticky=&#39;news&#39;,pady=0,ipady=0)
        self.Xscrollbar = AutoScrollbar(self.parentframe,orient=HORIZONTAL,command=self.set_xviews)
        self.Xscrollbar.grid(row=2,column=1,columnspan=1,sticky=&#39;news&#39;)
        self[&#39;xscrollcommand&#39;] = self.Xscrollbar.set
        self[&#39;yscrollcommand&#39;] = self.Yscrollbar.set
        self.tablecolheader[&#39;xscrollcommand&#39;] = self.Xscrollbar.set
        self.tablerowheader[&#39;yscrollcommand&#39;] = self.Yscrollbar.set
        self.parentframe.rowconfigure(1,weight=1)
        self.parentframe.columnconfigure(1,weight=1)

        self.tablecolheader.grid(row=0,column=1,rowspan=1,sticky=&#39;news&#39;,pady=0,ipady=0)
        self.tablerowheader.grid(row=1,column=0,rowspan=1,sticky=&#39;news&#39;,pady=0,ipady=0)
        self.grid(row=1,column=1,rowspan=1,sticky=&#39;news&#39;,pady=0,ipady=0)

        self.adjustColumnWidths()
        self.redrawTable(callback=callback)
        self.parentframe.bind(&#34;&lt;Configure&gt;&#34;, self.redrawVisible)
        self.tablecolheader.xview(&#34;moveto&#34;, 0)
        self.xview(&#34;moveto&#34;, 0)
        return

    def getVisibleRegion(self):
        &#34;&#34;&#34;Get visible region of table to display&#34;&#34;&#34;

        x1, y1 = self.canvasx(0), self.canvasy(0)
        #w, h = self.winfo_width(), self.winfo_height()
        w,h= self.master.winfo_width(), self.master.winfo_height()
        if w &lt;= 1.0 or h &lt;= 1.0:
            w, h = self.master.winfo_width(), self.master.winfo_height()
        x2, y2 = self.canvasx(w), self.canvasy(h)
        return x1, y1, x2, y2

    def getRowPosition(self, y):
        &#34;&#34;&#34;Get current row from canvas position&#34;&#34;&#34;

        h = self.rowheight
        y_start = self.y_start
        row = (int(y)-y_start)/h
        if row &lt; 0:
            return 0
        if row &gt; self.rows:
            row = self.rows
        return row

    def getColPosition(self, x):
        &#34;&#34;&#34;Get current col from canvas position&#34;&#34;&#34;

        x_start = self.x_start
        w = self.cellwidth
        i=0
        col=0
        for c in self.col_positions:
            col = i
            if c+w&gt;=x:
                break
            i+=1
        return col

    def getVisibleRows(self, y1, y2):
        &#34;&#34;&#34;Get the visible row range&#34;&#34;&#34;

        start = int(self.getRowPosition(y1))
        end = int(self.getRowPosition(y2))+1
        if end &gt; self.rows:
            end = self.rows
        return start, end

    def getVisibleCols(self, x1, x2):
        &#34;&#34;&#34;Get the visible column range&#34;&#34;&#34;

        start = self.getColPosition(x1)
        end = self.getColPosition(x2)+1
        if end &gt; self.cols:
            end = self.cols
        return start, end

    def redrawVisible(self, event=None, callback=None):
        &#34;&#34;&#34;Redraw the visible portion of the canvas&#34;&#34;&#34;

        model = self.model
        self.rows = self.model.getRowCount()
        self.cols = self.model.getColumnCount()

        self.tablewidth = (self.cellwidth) * self.cols
        self.configure(bg=self.cellbackgr)
        self.setColPositions()

        #are we drawing a filtered subset of the recs?
        if self.filtered == True and self.model.filteredrecs != None:
            self.rows = len(self.model.filteredrecs)
            self.delete(&#39;colrect&#39;)

        self.rowrange = range(0,self.rows)
        self.configure(scrollregion=(0,0, self.tablewidth+self.x_start,
                self.rowheight*self.rows+10))

        x1, y1, x2, y2 = self.getVisibleRegion()
        startvisiblerow, endvisiblerow = self.getVisibleRows(y1, y2)
        self.visiblerows = range(startvisiblerow, endvisiblerow)
        startvisiblecol, endvisiblecol = self.getVisibleCols(x1, x2)
        self.visiblecols = range(startvisiblecol, endvisiblecol)

        if self.cols == 0 or self.rows == 0:
            self.delete(&#39;entry&#39;)
            self.delete(&#39;rowrect&#39;)
            self.delete(&#39;currentrect&#39;)
            self.delete(&#39;gridline&#39;,&#39;text&#39;)
            self.tablerowheader.redraw()
            return

        self.drawGrid(startvisiblerow, endvisiblerow)
        align = self.align
        self.delete(&#39;fillrect&#39;)
        for row in self.visiblerows:
            if callback != None:
                callback()
            for col in self.visiblecols:
                colname = model.getColumnName(col)
                bgcolor = model.getColorAt(row,col, &#39;bg&#39;)
                fgcolor = model.getColorAt(row,col, &#39;fg&#39;)
                text = model.getValueAt(row,col)
                self.drawText(row, col, text, fgcolor, align)
                if bgcolor != None:
                    self.drawRect(row,col, color=bgcolor)

        #self.drawSelectedCol()
        self.tablecolheader.redraw()
        self.tablerowheader.redraw(align=self.align, showkeys=self.showkeynamesinheader)
        #self.setSelectedRow(self.currentrow)
        self.drawSelectedRow()
        self.drawSelectedRect(self.currentrow, self.currentcol)
        #print self.multiplerowlist

        if len(self.multiplerowlist)&gt;1:
            self.tablerowheader.drawSelectedRows(self.multiplerowlist)
            self.drawMultipleRows(self.multiplerowlist)
            self.drawMultipleCells()
        return

    def redrawTable(self, event=None, callback=None):
        self.redrawVisible(event, callback)
        return

    def redraw(self, event=None, callback=None):
        self.redrawVisible(event, callback)
        return

    def redrawCell(self, row=None, col=None, recname=None, colname=None):
        &#34;&#34;&#34;Redraw a specific cell only&#34;&#34;&#34;

        if row == None and recname != None:
            row = self.model.getRecordIndex(recname)
        if col == None and colname != None:
            col = self.model.getColumnIndex(colname)
        bgcolor = self.model.getColorAt(row,col, &#39;bg&#39;)
        fgcolor = self.model.getColorAt(row,col, &#39;fg&#39;)
        text = self.model.getValueAt(row,col)
        self.drawText(row, col, text, fgcolor)
        if bgcolor != None:
            self.drawRect(row,col, color=bgcolor)
        return

    def adjustColumnWidths(self):
        &#34;&#34;&#34;Optimally adjust col widths to accomodate the longest entry
            in each column - usually only called  on first redraw&#34;&#34;&#34;

        #self.cols = self.model.getColumnCount()
        try:
            fontsize = self.thefont[1]
        except:
            fontsize = self.fontsize
        scale = 8.5 * float(fontsize)/12
        for col in range(self.cols):
            colname = self.model.getColumnName(col)
            if colname in self.model.columnwidths:
                w = self.model.columnwidths[colname]
            else:
                w = self.cellwidth
            maxlen = self.model.getlongestEntry(col)
            size = maxlen * scale
            if size &lt; w:
                continue
            #print col, size, self.cellwidth
            if size &gt;= self.maxcellwidth:
                size = self.maxcellwidth
            self.model.columnwidths[colname] = size + float(fontsize)/12*6
        return

    def autoResizeColumns(self):
        &#34;&#34;&#34;Automatically set nice column widths and draw&#34;&#34;&#34;

        self.adjustColumnWidths()
        self.redrawTable()
        return

    def setColPositions(self):
        &#34;&#34;&#34;Determine current column grid positions&#34;&#34;&#34;

        self.col_positions=[]
        w=self.cellwidth
        x_pos=self.x_start
        self.col_positions.append(x_pos)
        for col in range(self.cols):
            colname=self.model.getColumnName(col)
            if colname in self.model.columnwidths:
                x_pos=x_pos+self.model.columnwidths[colname]
            else:
                x_pos=x_pos+w
            self.col_positions.append(x_pos)
        self.tablewidth = self.col_positions[len(self.col_positions)-1]
        return

    def sortTable(self, columnIndex=0, columnName=None, reverse=0):
        &#34;&#34;&#34;Set up sort order dict based on currently selected field&#34;&#34;&#34;

        self.model.setSortOrder(columnIndex, columnName, reverse)
        self.redrawTable()
        return

    def set_xviews(self,*args):
        &#34;&#34;&#34;Set the xview of table and col header&#34;&#34;&#34;

        self.xview(*args)
        self.tablecolheader.xview(*args)
        self.redrawVisible()
        return

    def set_yviews(self,*args):
        &#34;&#34;&#34;Set the xview of table and row header&#34;&#34;&#34;

        self.yview(*args)
        self.tablerowheader.yview(*args)
        self.redrawVisible()
        return

    def addRow(self, key=None, **kwargs):
        &#34;&#34;&#34;Add new row&#34;&#34;&#34;

        key = self.model.addRow(key, **kwargs)
        self.redrawTable()
        self.setSelectedRow(self.model.getRecordIndex(key))
        return

    def addRows(self, num=None):
        &#34;&#34;&#34;Add new rows&#34;&#34;&#34;

        if num == None:
            num = simpledialog.askinteger(&#34;Now many rows?&#34;,
                                            &#34;Number of rows:&#34;,initialvalue=1,
                                             parent=self.parentframe)
        if not num:
            return
        keys = self.model.autoAddRows(num)
        self.redrawTable()
        self.setSelectedRow(self.model.getRecordIndex(keys[0]))
        return

    def addColumn(self, newname=None):
        &#34;&#34;&#34;Add a new column&#34;&#34;&#34;

        if newname == None:

            coltypes = self.getModel().getDefaultTypes()
            d = MultipleValDialog(title=&#39;New Column&#39;,
                                    initialvalues=(coltypes, &#39;&#39;),
                                    labels=(&#39;Column Type&#39;,&#39;Name&#39;),
                                    types=(&#39;list&#39;,&#39;string&#39;),
                                    parent=self.parentframe)
            if d.result == None:
                return
            else:
                coltype = d.results[0]
                newname = d.results[1]

        if newname != None:
            if newname in self.getModel().columnNames:
                messagebox.showwarning(&#34;Name exists&#34;,
                                         &#34;Name already exists!&#34;,
                                         parent=self.parentframe)
            else:
                self.model.addColumn(newname)
                self.parentframe.configure(width=self.width)
                self.redrawTable()
        return

    def deleteRow(self):
        &#34;&#34;&#34;Delete a row&#34;&#34;&#34;

        if len(self.multiplerowlist)&gt;1:
            n = messagebox.askyesno(&#34;Delete&#34;,
                                      &#34;Delete Selected Records?&#34;,
                                      parent=self.parentframe)
            if n == True:
                rows = self.multiplerowlist
                self.model.deleteRows(rows)
                self.clearSelected()
                self.setSelectedRow(0)
                self.redrawTable()
        else:
            n = messagebox.askyesno(&#34;Delete&#34;,
                                      &#34;Delete This Record?&#34;,
                                      parent=self.parentframe)
            if n:
                row = self.getSelectedRow()
                self.model.deleteRow(row)
                self.setSelectedRow(row-1)
                self.clearSelected()
                self.redrawTable()
        return

    def deleteColumn(self):
        &#34;&#34;&#34;Delete currently selected column&#34;&#34;&#34;

        n =  messagebox.askyesno(&#34;Delete&#34;,
                                   &#34;Delete This Column?&#34;,
                                   parent=self.parentframe)
        if n:
            col = self.getSelectedColumn()
            self.model.deleteColumn(col)
            self.currentcol = self.currentcol - 1
            self.redrawTable()
        return

    def deleteCells(self, rows, cols):
        &#34;&#34;&#34;Clear the cell contents&#34;&#34;&#34;

        n =  messagebox.askyesno(&#34;Clear Confirm&#34;,
                                   &#34;Clear this data?&#34;,
                                   parent=self.parentframe)
        if not n:
            return
        for col in cols:
            for row in rows:
                #absrow = self.get_AbsoluteRow(row)
                self.model.deleteCellRecord(row, col)
                self.redrawCell(row,col)
        return

    def clearData(self, evt=None):
        &#34;&#34;&#34;Delete cells from gui event&#34;&#34;&#34;

        rows = self.multiplerowlist
        cols = self.multiplecollist
        self.deleteCells(rows, cols)
        return

    def autoAddColumns(self, numcols=None):
        &#34;&#34;&#34;Automatically add x number of cols&#34;&#34;&#34;

        if numcols == None:
            numcols = simpledialog.askinteger(&#34;Auto add rows.&#34;,
                                                &#34;How many empty columns?&#34;,
                                                parent=self.parentframe)
        self.model.auto_AddColumns(numcols)
        self.parentframe.configure(width=self.width)
        self.redrawTable()
        return

    def getRecordInfo(self, row):
        &#34;&#34;&#34;Show the record for this row&#34;&#34;&#34;

        model = self.model
        #We need a custom dialog for allowing field entries here
        #absrow = self.get_AbsoluteRow(row)
        d = RecordViewDialog(title=&#34;Record Details&#34;,
                                  parent=self.parentframe, table=self, row=row)
        return

    def findValue(self, searchstring=None, findagain=None):
        &#34;&#34;&#34;Return the row/col for the input value&#34;&#34;&#34;

        if searchstring == None:
            searchstring = simpledialog.askstring(&#34;Search table.&#34;,
                                               &#34;Enter search value&#34;,
                                               parent=self.parentframe)
        found=0
        if findagain == None or not hasattr(self,&#39;foundlist&#39;):
            self.foundlist=[]
        if self.model!=None:
            for row in range(self.rows):
                for col in range(self.cols):
                    text = str(self.model.getValueAt(row,col))
                    if text==&#39;&#39; or text==None:
                        continue
                    cell=row,col
                    if findagain == 1 and cell in self.foundlist:
                        continue
                    if text.lower().find(searchstring.lower())!=-1:
                        print (&#39;found in&#39;,row,col)
                        found=1
                        #highlight cell
                        self.delete(&#39;searchrect&#39;)
                        self.drawRect(row, col, color=&#39;red&#39;, tag=&#39;searchrect&#39;, delete=0)
                        self.lift(&#39;searchrect&#39;)
                        self.lift(&#39;celltext&#39;+str(col)+&#39;_&#39;+str(row))
                        #add row/col to foundlist
                        self.foundlist.append(cell)
                        #need to scroll to centre the cell here..
                        x,y = self.getCanvasPos(row, col)
                        self.xview(&#39;moveto&#39;, x)
                        self.yview(&#39;moveto&#39;, y)
                        self.tablecolheader.xview(&#39;moveto&#39;, x)
                        self.tablerowheader.yview(&#39;moveto&#39;, y)
                        return row, col
        if found==0:
            self.delete(&#39;searchrect&#39;)
            print (&#39;nothing found&#39;)
            return None

    def showAll(self):
        self.model.filteredrecs = None
        self.filtered = False
        self.redrawTable()
        return

    def doFilter(self, event=None):
        &#34;&#34;&#34;Filter the table display by some column values.
        We simply pass the model search function to the the filtering
        class and that handles everything else.
        See filtering frame class for how searching is done.
        &#34;&#34;&#34;
        if self.model==None:
            return
        names = self.filterframe.doFiltering(searchfunc=self.model.filterBy)
        #create a list of filtered recs
        self.model.filteredrecs = names
        self.filtered = True
        self.redrawTable()
        return

    def createFilteringBar(self, parent=None, fields=None):
        &#34;&#34;&#34;Add a filter frame&#34;&#34;&#34;

        if parent == None:
            parent = Toplevel()
            parent.title(&#39;Filter Records&#39;)
            x,y,w,h = self.getGeometry(self.master)
            parent.geometry(&#39;+%s+%s&#39; %(x,y+h))
        if fields == None:
            fields = self.model.columnNames
        from .Filtering import FilterFrame
        self.filterframe = FilterFrame(parent, fields,
                                       self.doFilter, self.closeFilterFrame)
        self.filterframe.pack()
        return parent

    def showFilteringBar(self):
        if not hasattr(self, &#39;filterwin&#39;) or self.filterwin == None:
            self.filterwin = self.createFilteringBar()
            self.filterwin.protocol(&#34;WM_DELETE_WINDOW&#34;, self.closeFilterFrame)
        else:
            self.filterwin.lift()
        return

    def closeFilterFrame(self):
        &#34;&#34;&#34;Callback for closing filter frame&#34;&#34;&#34;
        self.filterwin.destroy()
        self.filterwin = None
        self.showAll()
        return

    def resizeColumn(self, col, width):
        &#34;&#34;&#34;Resize a column by dragging&#34;&#34;&#34;

        #print &#39;resizing column&#39;, col
        #recalculate all col positions..
        colname=self.model.getColumnName(col)
        self.model.columnwidths[colname]=width
        self.setColPositions()
        self.redrawTable()
        self.drawSelectedCol(self.currentcol)
        return

    def get_currentRecord(self):
        &#34;&#34;&#34;Get the currently selected record&#34;&#34;&#34;

        rec = self.model.getRecordAtRow(self.currentrow)
        return rec

    def get_currentColName(self):
        &#34;&#34;&#34;Get the currently selected record name&#34;&#34;&#34;

        colname = self.mo(self.currentcol)
        return colname

    def get_currentRecordName(self):
        &#34;&#34;&#34;Get the currently selected record name&#34;&#34;&#34;

        recname = self.model.getRecName(self.currentrow)
        return recname

    def get_selectedRecordNames(self):
        &#34;&#34;&#34;Get a list of the current multiple selection, if any&#34;&#34;&#34;

        recnames=[]
        for row in self.multiplerowlist:
            recnames.append(self.model.getRecName(row))
        return recnames

    def get_currentRecCol(self):
        &#34;&#34;&#34;Get the clicked rec and col names as a tuple&#34;&#34;&#34;

        recname = self.get_currentRecordName()
        colname = self.get_currentColName()
        return (recname, colname)

    def get_row_clicked(self, event):
        &#34;&#34;&#34;get row where event on canvas occurs&#34;&#34;&#34;

        h=self.rowheight
        #get coord on canvas, not window, need this if scrolling
        y = int(self.canvasy(event.y))
        y_start=self.y_start
        rowc = int((int(y)-y_start)/h)
        #rowc = math.floor(rowc)
        #print &#39;event.y&#39;,event.y, &#39;y&#39;,y
        #print &#39;rowclicked&#39;, rowc
        return rowc

    def get_col_clicked(self,event):
        &#34;&#34;&#34;get col where event on canvas occurs&#34;&#34;&#34;

        w=self.cellwidth
        x = int(self.canvasx(event.x))
        x_start=self.x_start
        #print self.col_positions
        for colpos in self.col_positions:
            try:
                nextpos=self.col_positions[self.col_positions.index(colpos)+1]
            except:
                nextpos=self.tablewidth
            if x &gt; colpos and x &lt;= nextpos:
                #print &#39;x=&#39;, x, &#39;colpos&#39;, colpos, self.col_positions.index(colpos)
                return self.col_positions.index(colpos)
            else:
                #print None
                pass
        #return colc

    def setSelectedRow(self, row):
        &#34;&#34;&#34;Set currently selected row and reset multiple row list&#34;&#34;&#34;

        self.currentrow = row
        self.multiplerowlist = []
        self.multiplerowlist.append(row)
        return

    def setSelectedCol(self, col):
        &#34;&#34;&#34;Set currently selected column&#34;&#34;&#34;

        self.currentcol = col
        self.multiplecollist = []
        self.multiplecollist.append(col)
        return

    def setSelectedCells(self, startrow, endrow, startcol, endcol):
        &#34;&#34;&#34;Set a block of cells selected&#34;&#34;&#34;

        self.currentrow = startrow
        self.currentcol = startcol
        if startrow &lt; 0 or startcol &lt; 0:
            return
        if endrow &gt; self.rows or endcol &gt; self.cols:
            return
        for r in range(startrow, endrow):
            self.multiplerowlist.append(r)
        for c in range(startcol, endcol):
            self.multiplecollist.append(c)
        return

    def getSelectedRow(self):
        &#34;&#34;&#34;Get currently selected row&#34;&#34;&#34;
        return self.currentrow

    def getSelectedColumn(self):
        &#34;&#34;&#34;Get currently selected column&#34;&#34;&#34;
        return self.currentcol

    def select_All(self):
        &#34;&#34;&#34;Select all rows and cells&#34;&#34;&#34;

        self.startrow = 0
        self.endrow = self.rows
        self.multiplerowlist = range(self.startrow,self.endrow)
        self.drawMultipleRows(self.multiplerowlist)
        self.startcol = 0
        self.endcol = self.cols
        self.multiplecollist = range(self.startcol, self.endcol)
        self.drawMultipleCells()
        return

    def getCellCoords(self, row, col):
        &#34;&#34;&#34;Get x-y coordinates to drawing a cell in a given row/col&#34;&#34;&#34;
        colname=self.model.getColumnName(col)
        if colname in self.model.columnwidths:
            w=self.model.columnwidths[colname]
        else:
            w=self.cellwidth
        h=self.rowheight
        x_start=self.x_start
        y_start=self.y_start

        #get nearest rect co-ords for that row/col
        #x1=x_start+w*col
        x1=self.col_positions[col]
        y1=y_start+h*row
        x2=x1+w
        y2=y1+h
        return x1,y1,x2,y2

    def getCanvasPos(self, row, col):
        &#34;&#34;&#34;Get the cell x-y coords as a fraction of canvas size&#34;&#34;&#34;
        if self.rows==0:
            return None, None
        x1,y1,x2,y2 = self.getCellCoords(row,col)
        cx=float(x1)/self.tablewidth
        cy=float(y1)/(self.rows*self.rowheight)
        return cx, cy

    def isInsideTable(self,x,y):
        &#34;&#34;&#34;Returns true if x-y coord is inside table bounds&#34;&#34;&#34;
        if self.x_start &lt; x &lt; self.tablewidth and self.y_start &lt; y &lt; self.rows*self.rowheight:
            return 1
        else:
            return 0
        return answer

    def setRowHeight(self, h):
        &#34;&#34;&#34;Set the row height&#34;&#34;&#34;
        self.rowheight = h
        return

    def clearSelected(self):
        self.delete(&#39;rect&#39;)
        self.delete(&#39;entry&#39;)
        self.delete(&#39;tooltip&#39;)
        self.delete(&#39;searchrect&#39;)
        self.delete(&#39;colrect&#39;)
        self.delete(&#39;multicellrect&#39;)

        #self.delete(&#39;formulabox&#39;)
        return

    def gotoprevRow(self):
        &#34;&#34;&#34;Programmatically set previous row - eg. for button events&#34;&#34;&#34;
        self.clearSelected()
        current = self.getSelectedRow()
        self.setSelectedRow(current-1)
        self.startrow = current-1
        self.endrow = current-1
        #reset multiple selection list
        self.multiplerowlist=[]
        self.multiplerowlist.append(self.currentrow)
        self.drawSelectedRect(self.currentrow, self.currentcol)
        self.drawSelectedRow()
        coltype = self.model.getColumnType(self.currentcol)
        if coltype == &#39;text&#39; or coltype == &#39;number&#39;:
            self.drawCellEntry(self.currentrow, self.currentcol)
        return

    def gotonextRow(self):
        &#34;&#34;&#34;Programmatically set next row - eg. for button events&#34;&#34;&#34;
        self.clearSelected()
        current = self.getSelectedRow()
        self.setSelectedRow(current+1)
        self.startrow = current+1
        self.endrow = current+1
        #reset multiple selection list
        self.multiplerowlist=[]
        self.multiplerowlist.append(self.currentrow)
        self.drawSelectedRect(self.currentrow, self.currentcol)
        self.drawSelectedRow()
        coltype = self.model.getColumnType(self.currentcol)
        if coltype == &#39;text&#39; or coltype == &#39;number&#39;:
            self.drawCellEntry(self.currentrow, self.currentcol)
        return

    def handle_left_click(self, event):
        &#34;&#34;&#34;Respond to a single press&#34;&#34;&#34;

        #which row and column is the click inside?
        self.clearSelected()
        self.allrows = False
        rowclicked = self.get_row_clicked(event)
        colclicked = self.get_col_clicked(event)
        self.focus_set()
        if self.mode == &#39;formula&#39;:
            self.handleFormulaClick(rowclicked, colclicked)
            return
        if hasattr(self, &#39;cellentry&#39;):
            self.cellentry.destroy()
        #ensure popup menus are removed if present
        if hasattr(self, &#39;rightmenu&#39;):
            self.rightmenu.destroy()
        if hasattr(self.tablecolheader, &#39;rightmenu&#39;):
            self.tablecolheader.rightmenu.destroy()

        self.startrow = rowclicked
        self.endrow = rowclicked
        self.startcol = colclicked
        self.endcol = colclicked
        #reset multiple selection list
        self.multiplerowlist=[]
        self.multiplerowlist.append(rowclicked)
        if rowclicked is None or colclicked is None:
            return
        if self.read_only is True:    
            return
        if 0 &lt;= rowclicked &lt; self.rows and 0 &lt;= colclicked &lt; self.cols:
            self.setSelectedRow(rowclicked)
            self.setSelectedCol(colclicked)
            self.drawSelectedRect(self.currentrow, self.currentcol)
            self.drawSelectedRow()
            self.tablerowheader.drawSelectedRows(rowclicked)
            coltype = self.model.getColumnType(colclicked)
            if coltype == &#39;text&#39; or coltype == &#39;number&#39;:
                self.drawCellEntry(rowclicked, colclicked)
        return

    def handle_left_release(self,event):
        self.endrow = self.get_row_clicked(event)
        return

    def handle_left_ctrl_click(self, event):
        &#34;&#34;&#34;Handle ctrl clicks for multiple row selections&#34;&#34;&#34;
        rowclicked = self.get_row_clicked(event)
        colclicked = self.get_col_clicked(event)
        if 0 &lt;= rowclicked &lt; self.rows and 0 &lt;= colclicked &lt; self.cols:
            if rowclicked not in self.multiplerowlist:
                self.multiplerowlist.append(rowclicked)
            else:
                self.multiplerowlist.remove(rowclicked)
            self.drawMultipleRows(self.multiplerowlist)
            if colclicked not in self.multiplecollist:
                self.multiplecollist.append(colclicked)
            #print self.multiplecollist
            self.drawMultipleCells()
        return

    def handle_left_shift_click(self, event):
        &#34;&#34;&#34;Handle shift click, for selecting multiple rows&#34;&#34;&#34;
        #Has same effect as mouse drag, so just use same method
        self.handle_mouse_drag(event)
        return

    def handle_mouse_drag(self, event):
        &#34;&#34;&#34;Handle mouse moved with button held down, multiple selections&#34;&#34;&#34;

        if hasattr(self, &#39;cellentry&#39;):
            self.cellentry.destroy()
        rowover = self.get_row_clicked(event)
        colover = self.get_col_clicked(event)
        if colover == None or rowover == None:
            return

        if rowover &gt;= self.rows or self.startrow &gt; self.rows:
            return
        else:
            self.endrow = rowover
        #do columns
        if colover &gt; self.cols or self.startcol &gt; self.cols:
            return
        else:
            self.endcol = colover
            if self.startcol is None or self.endcol is None:
                return
            if self.endcol &lt; self.startcol:
                self.multiplecollist = range(self.endcol, self.startcol+1)
            else:
                self.multiplecollist = range(self.startcol, self.endcol+1)
            #print self.multiplecollist
        #draw the selected rows
        if self.endrow != self.startrow:
            if self.endrow &lt; self.startrow:
                self.multiplerowlist = range(self.endrow, self.startrow+1)
            else:
                self.multiplerowlist = range(self.startrow, self.endrow+1)
            self.drawMultipleRows(self.multiplerowlist)
            self.tablerowheader.drawSelectedRows(self.multiplerowlist)
            #draw selected cells outline using row and col lists
            #print self.multiplerowlist
            self.drawMultipleCells()
        else:
            self.multiplerowlist = []
            self.multiplerowlist.append(self.currentrow)
            if len(self.multiplecollist) &gt;= 1:
                self.drawMultipleCells()
            self.delete(&#39;multiplesel&#39;)
        #print self.multiplerowlist
        return

    def handle_arrow_keys(self, event):
        &#34;&#34;&#34;Handle arrow keys press&#34;&#34;&#34;
        #print event.keysym

        row = self.get_row_clicked(event)
        col = self.get_col_clicked(event)
        x,y = self.getCanvasPos(self.currentrow, 0)
        if x == None:
            return

        if event.keysym == &#39;Up&#39;:
            if self.currentrow == 0:
                return
            else:
                self.currentrow  = self.currentrow -1
        elif event.keysym == &#39;Down&#39;:
            if self.currentrow &gt;= self.rows-1:
                return
            else:
                self.currentrow  = self.currentrow +1
        elif event.keysym == &#39;Right&#39; or event.keysym == &#39;Tab&#39;:
            if self.currentcol &gt;= self.cols-1:
                if self.currentrow &lt; self.rows-1:
                    self.currentcol = 0
                    self.currentrow  = self.currentrow +1
                else:
                    return
            else:
                self.currentcol  = self.currentcol +1
        elif event.keysym == &#39;Left&#39;:
            if self.currentcol == 0:
                if self.currentrow == 0:
                    return
                else:
                    self.currentcol = self.cols-1
                    self.currentrow = self.currentrow - 1
            else:
                self.currentcol  = self.currentcol -1
        self.drawSelectedRect(self.currentrow, self.currentcol)
        coltype = self.model.getColumnType(self.currentcol)
        if coltype == &#39;text&#39; or coltype == &#39;number&#39;:
            self.delete(&#39;entry&#39;)
            self.drawCellEntry(self.currentrow, self.currentcol)
        return

    def handle_double_click(self, event):
        &#34;&#34;&#34;Do double click stuff. Selected row/cols will already have
           been set with single click binding&#34;&#34;&#34;

        &#39;&#39;&#39;row = self.get_row_clicked(event)
        col = self.get_col_clicked(event)
        model=self.getModel()
        cellvalue = model.getCellRecord(row, col)
        if Formula.isFormula(cellvalue):
            self.formula_Dialog(row, col, cellvalue)&#39;&#39;&#39;

        return

    def handle_right_click(self, event):
        &#34;&#34;&#34;respond to a right click&#34;&#34;&#34;

        if self.read_only is True:
            return
        self.delete(&#39;tooltip&#39;)
        self.tablerowheader.clearSelected()
        if hasattr(self, &#39;rightmenu&#39;):
            self.rightmenu.destroy()
        rowclicked = self.get_row_clicked(event)
        colclicked = self.get_col_clicked(event)
        if colclicked == None:
            self.rightmenu = self.popupMenu(event, outside=1)
            return

        if (rowclicked in self.multiplerowlist or self.allrows == True) and colclicked in self.multiplecollist:
            self.rightmenu = self.popupMenu(event, rows=self.multiplerowlist, cols=self.multiplecollist)
        else:
            if 0 &lt;= rowclicked &lt; self.rows and 0 &lt;= colclicked &lt; self.cols:
                self.clearSelected()
                self.allrows = False
                self.setSelectedRow(rowclicked)
                self.setSelectedCol(colclicked)
                self.drawSelectedRect(self.currentrow, self.currentcol)
                self.drawSelectedRow()
            if self.isInsideTable(event.x,event.y) == 1:
                self.rightmenu = self.popupMenu(event,rows=self.multiplerowlist, cols=self.multiplecollist)
            else:
                self.rightmenu = self.popupMenu(event, outside=1)
        return

    def handle_motion(self, event):
        &#34;&#34;&#34;Handle mouse motion on table&#34;&#34;&#34;

        self.delete(&#39;tooltip&#39;)
        row = self.get_row_clicked(event)
        col = self.get_col_clicked(event)
        if row == None or col == None:
            return
        if 0 &lt;= row &lt; self.rows and 0 &lt;= col &lt; self.cols:
            self.drawTooltip(row, col)

        return

    def gotonextCell(self, event):
        &#34;&#34;&#34;Move highlighted cell to next cell in row or a new col&#34;&#34;&#34;
        #print &#39;next&#39;
        if hasattr(self, &#39;cellentry&#39;):
            self.cellentry.destroy()
        self.currentcol=self.currentcol+1
        if self.currentcol &gt;= self.cols-1:
            self.currentrow  = self.currentrow +1
            self.currentcol = self.currentcol+1
        self.drawSelectedRect(self.currentrow, self.currentcol)
        return

    def movetoSelectedRow(self, row=None, recname=None):
        &#34;&#34;&#34;Move to selected row, updating table&#34;&#34;&#34;
        row=self.model.getRecordIndex(recname)
        self.setSelectedRow(row)
        self.drawSelectedRow()
        x,y = self.getCanvasPos(row, 0)
        self.yview(&#39;moveto&#39;, y-0.01)
        self.tablecolheader.yview(&#39;moveto&#39;, y)
        return

    def handleFormulaClick(self, row, col):
        &#34;&#34;&#34;Do a dialog for cell formula entry&#34;&#34;&#34;

        model = self.getModel()
        cell = list(model.getRecColNames(row, col))
        #absrow = self.get_AbsoluteRow(row)
        self.formulaText.insert(END, str(cell))
        self.formulaText.focus_set()
        self.drawSelectedRect(row, col, color=&#39;red&#39;)
        return

    def formula_Dialog(self, row, col, currformula=None):
        &#34;&#34;&#34;Formula dialog&#34;&#34;&#34;
        self.mode = &#39;formula&#39;
        print (self.mode)
        x1,y1,x2,y2 = self.getCellCoords(row,col)
        w=300
        h=h=self.rowheight * 3
        def close():
            if hasattr(self,&#39;formulaWin&#39;):
                self.delete(&#39;formulabox&#39;)
            self.mode = &#39;normal&#39;
        def calculate():
            #get text area contents and do formula
            f = self.formulaText.get(1.0, END)
            f = f.strip(&#39;\n&#39;)
            self.model.setFormulaAt(f,row,col)
            value = self.model.doFormula(f)
            color = self.model.getColorAt(row,col,&#39;fg&#39;)
            self.drawText(row, col, value, color)
            close()
            self.mode = &#39;normal&#39;
            return
        def clear():
            self.formulaText.delete(1.0, END)

        self.formulaFrame = Frame(width=w,height=h,bd=3)
        self.formulaText = Text(self.formulaFrame, width=30, height=8, bg=&#39;white&#39;,relief=GROOVE)
        self.formulaText.pack(side=LEFT,padx=2,pady=2)
        if currformula != None:
            self.formulaText.insert(END, Formula.getFormula(currformula))
        cancelbutton=Button(self.formulaFrame, text=&#39;Cancel&#39;,
                            bg=&#39;#99ccff&#39;,command=close)
        cancelbutton.pack(fill=BOTH,padx=2,pady=2)
        donebutton=Button(self.formulaFrame, text=&#39;Done&#39;,
                          bg=&#39;#99ccff&#39;,command=calculate)
        donebutton.pack(fill=BOTH,padx=2,pady=2)
        &#39;&#39;&#39;clrbutton=Button(self.formulaFrame, text=&#39;Clear&#39;,
                           bg=&#39;#99ccff&#39;,command=clear)
        clrbutton.pack(fill=BOTH,padx=2,pady=2) &#39;&#39;&#39;
        #add to canvas
        self.formulaWin = self.create_window(x1+self.inset,y1+self.inset,
                                width=w,height=h,
                                window=self.formulaFrame,anchor=&#39;nw&#39;,
                                tag=&#39;formulabox&#39;)
        self.formulaText.focus_set()
        return

    def convertFormulae(self, rows, cols=None):
        &#34;&#34;&#34;Convert the formulas in the cells to their result values&#34;&#34;&#34;

        if len(self.multiplerowlist) == 0 or len(self.multiplecollist) == 0:
            return None

        print (rows, cols)
        if cols == None:
            cols = range(self.cols)
        for r in rows:
            #absr=self.get_AbsoluteRow(r)
            for c in cols:
                val = self.model.getValueAt(r,c)
                self.model.setValueAt(val, r, c)
        return

    def paste(self, event=None):
        &#34;&#34;&#34;Copy from clipboard&#34;&#34;&#34;

        print (self.parentframe.clipboard_get())
        return

    def copyCell(self, rows, cols=None):
        &#34;&#34;&#34;Copy cell contents to a temp internal clipboard&#34;&#34;&#34;

        row = rows[0]; col = cols[0]
        #absrow = self.get_AbsoluteRow(row)
        self.clipboard = copy.deepcopy(self.model.getCellRecord(row, col))
        return

    def pasteCell(self, rows, cols=None):
        &#34;&#34;&#34;Paste cell from internal clipboard&#34;&#34;&#34;

        row = rows[0]; col = cols[0]
        #absrow = self.get_AbsoluteRow(row)
        val = self.clipboard
        self.model.setValueAt(val, row, col)
        self.redrawTable()
        return

    def copyColumns(self):
        &#34;&#34;&#34;Copy current selected cols&#34;&#34;&#34;

        M = self.model
        coldata = {}
        for col in self.multiplecollist:
            name = M.columnNames[col]
            coldata[name] = M.getColumnData(columnName=name)
        return coldata

    def pasteColumns(self, coldata):
        &#34;&#34;&#34;Paste new cols, overwrites existing names&#34;&#34;&#34;

        M = self.model
        for name in coldata:
            if name not in M.columnNames:
                M.addColumn(name)
            for r in range(len(coldata[name])):
                val = coldata[name][r]
                col = M.columnNames.index(name)
                if r &gt;= self.rows:
                    break
                M.setValueAt(val, r, col)
        self.redrawTable()
        return coldata

    # --- Some cell specific actions here ---

    def setcellColor(self, rows, cols=None, newColor=None, key=None, redraw=True):
        &#34;&#34;&#34;Set the cell color for one or more cells and save it in the model color&#34;&#34;&#34;

        model = self.getModel()
        if newColor == None:
            ctuple, newColor = tkColorChooser.askcolor(title=&#39;pick a color&#39;)
            if newColor == None:
                return

        if type(rows) is int:
            x=rows
            rows=[]
            rows.append(x)
        if self.allrows == True:
            #we use all rows if the whole column has been selected
            rows = range(0,self.rows)
        if cols == None:
            cols = range(self.cols)
        for col in cols:
            for row in rows:
                #absrow = self.get_AbsoluteRow(row)
                model.setColorAt(row, col, color=newColor, key=key)
                #setcolor(absrow, col)
        if redraw == True:
            self.redrawTable()
        return

    def popupMenu(self, event, rows=None, cols=None, outside=None):
        &#34;&#34;&#34;Add left and right click behaviour for canvas, should not have to override
            this function, it will take its values from defined dicts in constructor&#34;&#34;&#34;

        defaultactions = {&#34;Set Fill Color&#34; : lambda : self.setcellColor(rows,cols,key=&#39;bg&#39;),
                        &#34;Set Text Color&#34; : lambda : self.setcellColor(rows,cols,key=&#39;fg&#39;),
                        &#34;Copy&#34; : lambda : self.copyCell(rows, cols),
                        &#34;Paste&#34; : lambda : self.pasteCell(rows, cols),
                        &#34;Fill Down&#34; : lambda : self.fillDown(rows, cols),
                        &#34;Fill Right&#34; : lambda : self.fillAcross(cols, rows),
                        &#34;Add Row(s)&#34; : lambda : self.addRows(),
                        &#34;Delete Row(s)&#34; : lambda : self.deleteRow(),
                        &#34;View Record&#34; : lambda : self.getRecordInfo(row),
                        &#34;Clear Data&#34; : lambda : self.deleteCells(rows, cols),
                        &#34;Select All&#34; : self.select_All,
                        &#34;Auto Fit Columns&#34; : self.autoResizeColumns,
                        &#34;Filter Records&#34; : self.showFilteringBar,
                        &#34;New&#34;: self.new,
                        &#34;Load&#34;: self.load,
                        &#34;Save&#34;: self.save,
                        &#34;Import text&#34;:self.importTable,
                        &#34;Export csv&#34;: self.exportTable,
                        &#34;Plot Selected&#34; : self.plotSelected,
                        &#34;Plot Options&#34; : self.plotSetup,
                        &#34;Export Table&#34; : self.exportTable,
                        &#34;Preferences&#34; : self.showtablePrefs,
                        &#34;Formulae-&gt;Value&#34; : lambda : self.convertFormulae(rows, cols)}

        main = [&#34;Set Fill Color&#34;,&#34;Set Text Color&#34;,&#34;Copy&#34;, &#34;Paste&#34;, &#34;Fill Down&#34;,&#34;Fill Right&#34;,
                &#34;Clear Data&#34;]
        general = [&#34;Select All&#34;, &#34;Add Row(s)&#34; , &#34;Delete Row(s)&#34;, &#34;Auto Fit Columns&#34;, &#34;Filter Records&#34;, &#34;Preferences&#34;]
        filecommands = [&#39;New&#39;,&#39;Load&#39;,&#39;Save&#39;,&#39;Import text&#39;,&#39;Export csv&#39;]
        plotcommands = [&#39;Plot Selected&#39;,&#39;Plot Options&#39;]

        def createSubMenu(parent, label, commands):
            menu = Menu(parent, tearoff = 0)
            popupmenu.add_cascade(label=label,menu=menu)
            for action in commands:
                menu.add_command(label=action, command=defaultactions[action])
            return menu

        def add_commands(fieldtype):
            &#34;&#34;&#34;Add commands to popup menu for column type and specific cell&#34;&#34;&#34;
            functions = self.columnactions[fieldtype]
            for f in functions.keys():
                func = getattr(self, functions[f])
                popupmenu.add_command(label=f, command= lambda : func(row,col))
            return

        popupmenu = Menu(self, tearoff = 0)
        def popupFocusOut(event):
            popupmenu.unpost()

        if outside == None:
            #if outside table, just show general items
            row = self.get_row_clicked(event)
            col = self.get_col_clicked(event)
            coltype = self.model.getColumnType(col)
            def add_defaultcommands():
                &#34;&#34;&#34;now add general actions for all cells&#34;&#34;&#34;
                for action in main:
                    if action == &#39;Fill Down&#39; and (rows == None or len(rows) &lt;= 1):
                        continue
                    if action == &#39;Fill Right&#39; and (cols == None or len(cols) &lt;= 1):
                        continue
                    else:
                        popupmenu.add_command(label=action, command=defaultactions[action])
                return

            if coltype in self.columnactions:
                add_commands(coltype)
            add_defaultcommands()

        for action in general:
            popupmenu.add_command(label=action, command=defaultactions[action])

        popupmenu.add_separator()
        createSubMenu(popupmenu, &#39;File&#39;, filecommands)
        createSubMenu(popupmenu, &#39;Plot&#39;, plotcommands)
        popupmenu.bind(&#34;&lt;FocusOut&gt;&#34;, popupFocusOut)
        popupmenu.focus_set()
        popupmenu.post(event.x_root, event.y_root)
        return popupmenu

    # --- spreadsheet type functions ---

    def fillDown(self, rowlist, collist):
        &#34;&#34;&#34;Fill down a column, or multiple columns&#34;&#34;&#34;
        model = self.model
        #absrow  = self.get_AbsoluteRow(rowlist[0])
        #remove first element as we don&#39;t want to overwrite it
        rowlist.remove(rowlist[0])

        #if this is a formula, we have to treat it specially
        for col in collist:
            val = self.model.getCellRecord(row, col)
            f=val #formula to copy
            i=1
            for r in rowlist:
                #absr = self.get_AbsoluteRow(r)
                if Formula.isFormula(f):
                    newval = model.copyFormula(f, r, col, offset=i)
                    model.setFormulaAt(newval, r, col)
                else:
                    model.setValueAt(val, r, col)
                #print &#39;setting&#39;, val, &#39;at row&#39;, r
                i+=1

        self.redrawTable()
        return

    def fillAcross(self, collist, rowlist):
        &#34;&#34;&#34;Fill across a row, or multiple rows&#34;&#34;&#34;
        model = self.model
        #row = self.currentrow
        #absrow  = self.get_AbsoluteRow(collist[0])
        frstcol = collist[0]
        collist.remove(frstcol)

        for row in rowlist:
            #absr = self.get_AbsoluteRow(row)
            val = self.model.getCellRecord(absr, frstcol)
            f=val     #formula to copy
            i=1
            for c in collist:
                if Formula.isFormula(f):
                    newval = model.copyFormula(f, r, c, offset=i, dim=&#39;x&#39;)
                    model.setFormulaAt(newval, r, c)
                else:
                    model.setValueAt(val, r, c)
                i+=1
        self.redrawTable()
        return

    def getSelectionValues(self):
        &#34;&#34;&#34;Get values for current multiple cell selection&#34;&#34;&#34;
        if len(self.multiplerowlist) == 0 or len(self.multiplecollist) == 0:
            return None
        rows = self.multiplerowlist
        cols = self.multiplecollist
        model = self.model
        if len(rows)&lt;1 or len(cols)&lt;1:
            return None
        #if only one row selected we plot whole col
        if len(rows) == 1:
            rows = self.rowrange
        lists = []

        for c in cols:
            x=[]
            for r in rows:
                #absr = self.get_AbsoluteRow(r)
                val = model.getValueAt(r,c)
                if val == None or val == &#39;&#39;:
                    continue
                x.append(val)
            lists.append(x)
        return lists

    def plotSelected(self, graphtype=&#39;XY&#39;):
        &#34;&#34;&#34;Plot the selected data using pylab - if possible&#34;&#34;&#34;

        from .Plot import pylabPlotter
        if not hasattr(self, &#39;pyplot&#39;):
            self.pyplot = pylabPlotter()
        plotdata = []
        for p in self.getSelectionValues():
            x = []
            fail = False
            for d in p:
                try:
                    x.append(float(d))
                except:
                    fail = True
                    continue
            if fail == False:
                plotdata.append(x)

        pltlabels = self.getplotlabels()
        if len(pltlabels) &gt; 2:
            self.pyplot.setDataSeries(pltlabels)
            self.pyplot.showlegend = 1
        self.pyplot.plotCurrent(data=plotdata, graphtype=graphtype)
        return

    def plotSetup(self):
        &#34;&#34;&#34;Call pylab plot dialog setup, send data if we haven&#39;t already
            plotted&#34;&#34;&#34;

        from PylabPlot import pylabPlotter
        if not hasattr(self, &#39;pyplot&#39;):
            self.pyplot = pylabPlotter()
        plotdata = self.getSelectionValues()
        if not self.pyplot.hasData() and plotdata != None:
            print (&#39;has data&#39;)
            plotdata = self.getSelectionValues()
            pltlabels = self.getplotlabels()
            self.pyplot.setDataSeries(pltlabels)
            self.pyplot.plotSetup(plotdata)
        else:
            self.pyplot.plotSetup()
        return

    def getplotlabels(self):
        &#34;&#34;&#34;Get labels for plot series from col labels&#34;&#34;&#34;
        pltlabels = []
        for col in self.multiplecollist:
            pltlabels.append(self.model.getColumnLabel(col))
        return pltlabels

    #--- Drawing stuff ---

    def drawGrid(self, startrow, endrow):
        &#34;&#34;&#34;Draw the table grid lines&#34;&#34;&#34;
        self.delete(&#39;gridline&#39;,&#39;text&#39;)
        rows=len(self.rowrange)
        cols=self.cols
        w = self.cellwidth
        h = self.rowheight
        x_start=self.x_start
        y_start=self.y_start
        x_pos=x_start

        if self.vertlines==1:
            for col in range(cols+1):
                x=self.col_positions[col]
                self.create_line(x,y_start,x,y_start+rows*h, tag=&#39;gridline&#39;,
                                     fill=self.grid_color, width=self.linewidth)
        if self.horizlines==1:
            for row in range(startrow, endrow+1):
                y_pos=y_start+row*h
                self.create_line(x_start,y_pos,self.tablewidth,y_pos, tag=&#39;gridline&#39;,
                                    fill=self.grid_color, width=self.linewidth)
        return

    def drawRowHeader(self):
        &#34;&#34;&#34;User has clicked to select a cell&#34;&#34;&#34;
        self.delete(&#39;rowheader&#39;)
        x_start=self.x_start
        y_start=self.y_start
        h=self.rowheight
        rowpos=0
        for row in self.rowrange:
            x1,y1,x2,y2 = self.getCellCoords(rowpos,0)
            self.create_rectangle(0,y1,x_start-2,y2,
                                      fill=&#39;gray75&#39;,
                                      outline=&#39;white&#39;,
                                      width=1,
                                      tag=&#39;rowheader&#39;)
            self.create_text(x_start/2,y1+h/2,
                                      text=row+1,
                                      fill=&#39;black&#39;,
                                      font=self.thefont,
                                      tag=&#39;rowheader&#39;)
            rowpos+=1
        return

    def drawSelectedRect(self, row, col, color=None):
        &#34;&#34;&#34;User has clicked to select a cell&#34;&#34;&#34;
        if col &gt;= self.cols:
            return
        self.delete(&#39;currentrect&#39;)
        bg = self.selectedcolor
        if color == None:
            color = &#39;gray25&#39;
        w=3
        x1,y1,x2,y2 = self.getCellCoords(row,col)
        rect = self.create_rectangle(x1+w/2,y1+w/2,x2-w/2,y2-w/2,
                                  fill=bg,
                                  outline=color,
                                  width=w,
                                  stipple=&#39;gray50&#39;,
                                  tag=&#39;currentrect&#39;)
        #self.lower(&#39;currentrect&#39;)
        #raise text above all
        self.lift(&#39;celltext&#39;+str(col)+&#39;_&#39;+str(row))
        return

    def drawRect(self, row, col, color=None, tag=None, delete=1):
        &#34;&#34;&#34;Cell is colored&#34;&#34;&#34;
        if delete==1:
            self.delete(&#39;cellbg&#39;+str(row)+str(col))
        if color==None or color==self.cellbackgr:
            return
        else:
            bg=color
        if tag==None:
            recttag=&#39;fillrect&#39;
        else:
            recttag=tag
        w=1
        x1,y1,x2,y2 = self.getCellCoords(row,col)
        rect = self.create_rectangle(x1+w/2,y1+w/2,x2-w/2,y2-w/2,
                                  fill=bg,
                                  outline=bg,
                                  width=w,
                                  tag=(recttag,&#39;cellbg&#39;+str(row)+str(col)))
        self.lower(recttag)
        return

    def drawCellEntry(self, row, col, text=None):
        &#34;&#34;&#34;When the user single/double clicks on a text/number cell, bring up entry window&#34;&#34;&#34;

        if self.read_only == True:
            return
        #absrow = self.get_AbsoluteRow(row)
        h=self.rowheight
        model=self.getModel()
        cellvalue = self.model.getCellRecord(row, col)
        if Formula.isFormula(cellvalue):
            return
        else:
            text = self.model.getValueAt(row, col)
        x1,y1,x2,y2 = self.getCellCoords(row,col)
        w=x2-x1
        #Draw an entry window
        txtvar = StringVar()
        txtvar.set(text)
        def callback(e):
            value = txtvar.get()
            if value == &#39;=&#39;:
                #do a dialog that gets the formula into a text area
                #then they can click on the cells they want
                #when done the user presses ok and its entered into the cell
                self.cellentry.destroy()
                #its all done here..
                self.formula_Dialog(row, col)
                return

            coltype = self.model.getColumnType(col)
            if coltype == &#39;number&#39;:
                sta = self.checkDataEntry(e)
                if sta == 1:
                    model.setValueAt(value,row,col)
            elif coltype == &#39;text&#39;:
                model.setValueAt(value,row,col)

            color = self.model.getColorAt(row,col,&#39;fg&#39;)
            self.drawText(row, col, value, color, align=self.align)
            if e.keysym==&#39;Return&#39;:
                self.delete(&#39;entry&#39;)
                #self.drawRect(row, col)
                #self.gotonextCell(e)
            return

        self.cellentry=Entry(self.parentframe,width=20,
                        textvariable=txtvar,
                        #bg=self.entrybackgr,
                        #relief=FLAT,
                        takefocus=1,
                        font=self.thefont)
        self.cellentry.icursor(END)
        self.cellentry.bind(&#39;&lt;Return&gt;&#39;, callback)
        self.cellentry.bind(&#39;&lt;KeyRelease&gt;&#39;, callback)
        self.cellentry.focus_set()
        self.entrywin=self.create_window(x1+self.inset,y1+self.inset,
                                width=w-self.inset*2,height=h-self.inset*2,
                                window=self.cellentry,anchor=&#39;nw&#39;,
                                tag=&#39;entry&#39;)

        return

    def checkDataEntry(self,event=None):
        &#34;&#34;&#34;do validation checks on data entry in a widget&#34;&#34;&#34;
        #if user enters commas, change to points
        import re
        value=event.widget.get()
        if value!=&#39;&#39;:
            try:
                value=re.sub(&#39;,&#39;,&#39;.&#39;, value)
                value=float(value)

            except ValueError:
                event.widget.configure(bg=&#39;red&#39;)
                return 0
        elif value == &#39;&#39;:
            return 1
        return 1

    def drawText(self, row, col, celltxt, fgcolor=None, align=None):
        &#34;&#34;&#34;Draw the text inside a cell area&#34;&#34;&#34;

        self.delete(&#39;celltext&#39;+str(col)+&#39;_&#39;+str(row))
        h=self.rowheight
        x1,y1,x2,y2 = self.getCellCoords(row,col)
        w=x2-x1
        wrap = False
        pad=5
        # If celltxt is a number then we make it a string
        if type(celltxt) is float or type(celltxt) is int:
            celltxt=str(celltxt)
        length = len(celltxt)
        if length == 0:
            return
        #if cell width is less than x, print nothing
        if w&lt;=10:
            return

        if fgcolor == None or fgcolor == &#34;None&#34;:
            fgcolor = &#39;black&#39;
        if align == None:
            align = &#39;w&#39;
        if align == &#39;w&#39;:
            x1 = x1-w/2+pad
        elif align == &#39;e&#39;:
            x1 = x1+w/2-pad

        if w &lt; 18:
            celltxt = &#39;.&#39;
        else:
            fontsize = self.fontsize
            colname = self.model.getColumnName(col)
            #scaling between canvas and text normalised to about font 14
            scale = 8.5 * float(fontsize)/12
            size = length * scale
            if size &gt; w:
                newlength = w / scale
                #print w, size, length, newlength
                celltxt = celltxt[0:int(math.floor(newlength))]

        #if celltxt is dict then we are drawing a hyperlink
        if self.isLink(celltxt) == True:
            haslink=0
            linktext=celltxt[&#39;text&#39;]
            if len(linktext) &gt; w/scale or w&lt;28:
                linktext=linktext[0:int(w/fontsize*1.2)-2]+&#39;..&#39;
            if celltxt[&#39;link&#39;]!=None and celltxt[&#39;link&#39;]!=&#39;&#39;:
                f,s = self.thefont
                linkfont = (f, s, &#39;underline&#39;)
                linkcolor=&#39;blue&#39;
                haslink=1
            else:
                linkfont = self.thefont
                linkcolor=fgcolor

            rect = self.create_text(x1+w/2,y1+h/2,
                                      text=linktext,
                                      fill=linkcolor,
                                      font=linkfont,
                                      tag=(&#39;text&#39;,&#39;hlink&#39;,&#39;celltext&#39;+str(col)+&#39;_&#39;+str(row)))
            if haslink == 1:
                self.tag_bind(rect, &#39;&lt;Double-Button-1&gt;&#39;, self.check_hyperlink)

        #just normal text
        else:
            rect = self.create_text(x1+w/2,y1+h/2,
                                      text=celltxt,
                                      fill=fgcolor,
                                      font=self.thefont,
                                      anchor=align,
                                      tag=(&#39;text&#39;,&#39;celltext&#39;+str(col)+&#39;_&#39;+str(row)))
        return

    def isLink(self, cell):
        &#34;&#34;&#34;Checks if cell is a hyperlink, without using isinstance&#34;&#34;&#34;
        try:
            if &#39;link&#39; in cell:
                return True
        except:
            return False

    def drawSelectedRow(self):
        &#34;&#34;&#34;Draw the highlight rect for the currently selected row&#34;&#34;&#34;

        self.delete(&#39;rowrect&#39;)
        row = self.currentrow
        x1,y1,x2,y2 = self.getCellCoords(row,0)
        x2 = self.tablewidth
        rect = self.create_rectangle(x1,y1,x2,y2,
                                  fill=self.rowselectedcolor,
                                  outline=self.rowselectedcolor,
                                  tag=&#39;rowrect&#39;)
        self.lower(&#39;rowrect&#39;)
        self.lower(&#39;fillrect&#39;)
        self.tablerowheader.drawSelectedRows(self.currentrow)
        return

    def drawSelectedCol(self, col=None, delete=1):
        &#34;&#34;&#34;Draw an outline rect fot the current column selection&#34;&#34;&#34;

        if delete == 1:
            self.delete(&#39;colrect&#39;)
        if col == None:
            col=self.currentcol
        w=2
        x1,y1,x2,y2 = self.getCellCoords(0,col)
        y2 = self.rows * self.rowheight
        rect = self.create_rectangle(x1+w/2,y1+w/2,x2,y2+w/2,
                                     outline=&#39;blue&#39;,width=w,
                                     tag=&#39;colrect&#39;)
        return

    def drawMultipleRows(self, rowlist):
        &#34;&#34;&#34;Draw more than one row selection&#34;&#34;&#34;

        self.delete(&#39;multiplesel&#39;)
        for r in rowlist:
            if r not in self.visiblerows or r &gt; self.rows-1:
                continue
            x1,y1,x2,y2 = self.getCellCoords(r,0)
            x2 = self.tablewidth
            rect = self.create_rectangle(x1,y1,x2,y2,
                                      fill=self.multipleselectioncolor,
                                      outline=self.rowselectedcolor,
                                      tag=(&#39;multiplesel&#39;,&#39;rowrect&#39;))
        self.lower(&#39;multiplesel&#39;)
        self.lower(&#39;fillrect&#39;)
        return

    def drawMultipleCells(self):
        &#34;&#34;&#34;Draw an outline box for multiple cell selection&#34;&#34;&#34;

        self.delete(&#39;multicellrect&#39;)
        rows = self.multiplerowlist
        cols = self.multiplecollist
        w=2
        x1,y1,a,b = self.getCellCoords(rows[0],cols[0])
        c,d,x2,y2 = self.getCellCoords(rows[len(rows)-1],cols[len(cols)-1])
        rect = self.create_rectangle(x1+w/2,y1+w/2,x2,y2,
                             outline=&#39;blue&#39;,width=w,activefill=&#39;red&#39;,activestipple=&#39;gray25&#39;,
                             tag=&#39;multicellrect&#39;)

        return

    def drawTooltip(self, row, col):
        &#34;&#34;&#34;Draw a tooltip showing contents of cell&#34;&#34;&#34;

        x1,y1,x2,y2 = self.getCellCoords(row,col)
        w=x2-x1
        text = self.model.getValueAt(row,col)
        if isinstance(text, dict):
            if &#39;link&#39; in text:
                text = text[&#39;link&#39;]

        # If text is a number we make it a string
        if type(text) is float or type is int:
            text = str(text)
        if text == None or text == &#39;&#39; or len(str(text))&lt;=10:
            return

        sfont = font.Font(family=&#39;Arial&#39;, size=12,weight=&#39;bold&#39;)
        obj = self.create_text(x1+w/1.5,y2,text=text,
                                anchor=&#39;w&#39;,
                                font=sfont,tag=&#39;tooltip&#39;)

        box = self.bbox(obj)
        x1=box[0]-1
        y1=box[1]-1
        x2=box[2]+1
        y2=box[3]+1

        rect = self.create_rectangle(x1+1,y1+1,x2+1,y2+1,tag=&#39;tooltip&#39;,fill=&#39;black&#39;)
        rect2 = self.create_rectangle(x1,y1,x2,y2,tag=&#39;tooltip&#39;,fill=&#39;lightyellow&#39;)
        self.lift(obj)
        return

    def setcellbackgr(self):
        clr = self.getaColor(self.cellbackgr)
        if clr != None:
            self.cellbackgr = clr
        return

    def setgrid_color(self):
        clr = self.getaColor(self.grid_color)
        if clr != None:
            self.grid_color = clr

        return

    def setrowselectedcolor(self):
        clr = self.getaColor(self.rowselectedcolor)
        if clr != None:
            self.rowselectedcolor = clr
        return

    def getaColor(self, oldcolor):

        ctuple, newcolor = tkColorChooser.askcolor(title=&#39;pick a color&#39;, initialcolor=oldcolor,
                                                   parent=self.parentframe)
        if ctuple == None:
            return None
        return str(newcolor)

    #--- Preferences stuff ---

    def showtablePrefs(self, prefs=None):
        &#34;&#34;&#34;Show table options dialog using an instance of prefs&#34;&#34;&#34;
        #self.prefs = prefs
        if self.prefs == None:
            self.loadPrefs()
        self.prefswindow=Toplevel()
        x,y,w,h = self.getGeometry(self.master)
        self.prefswindow.geometry(&#39;+%s+%s&#39; %(int(x+w/2),int(y+h/2)))
        self.prefswindow.title(&#39;Preferences&#39;)
        self.prefswindow.resizable(width=FALSE, height=FALSE)

        frame1=Frame(self.prefswindow)
        frame1.pack(side=LEFT)
        frame2=Frame(self.prefswindow)
        frame2.pack()
        def close_prefsdialog():
            self.prefswindow.destroy()
        row=0
        Checkbutton(frame1, text=&#34;Show horizontal lines&#34;, variable=self.horizlinesvar,
                    onvalue=1, offvalue=0).grid(row=row,column=0, columnspan=2, sticky=&#39;news&#39;)
        row=row+1
        Checkbutton(frame1, text=&#34;Show vertical lines&#34;, variable=self.vertlinesvar,
                    onvalue=1, offvalue=0).grid(row=row,column=0, columnspan=2, sticky=&#39;news&#39;)
        row=row+1
        Checkbutton(frame1, text=&#34;Alternate Row Color&#34;, variable=self.alternaterowsvar,
                    onvalue=1, offvalue=0).grid(row=row,column=0, columnspan=2, sticky=&#39;news&#39;)
        row=row+1
        lblrowheight = Label(frame1,text=&#39;Row Height:&#39;)
        lblrowheight.grid(row=row,column=0,padx=3,pady=2)
        rowheightentry = Spinbox(frame1,from_=12,to=50,width=10,
                            textvariable=self.rowheightvar)
        rowheightentry.grid(row=row,column=1,padx=3,pady=2)
        row=row+1
        lblcellwidth = Label(frame1,text=&#39;Cell Width:&#39;)
        lblcellwidth.grid(row=row,column=0,padx=3,pady=2)
        cellwidthentry = Spinbox(frame1,from_=20,to=500, width=10,
                             textvariable=self.cellwidthvar)
        cellwidthentry.grid(row=row,column=1,padx=3,pady=2)
        row=row+1

        lbllinewidth = Label(frame1,text=&#39;Line Width:&#39;)
        lbllinewidth.grid(row=row,column=0,padx=3,pady=2)
        linewidthentry = Spinbox(frame1,from_=0,to=10,width=10,
                            textvariable=self.linewidthvar)
        linewidthentry.grid(row=row,column=1,padx=3,pady=2)
        row=row+1

        rowhdrwidth = Label(frame1,text=&#39;Row Header Width:&#39;)
        rowhdrwidth.grid(row=row,column=0,padx=3,pady=2)
        rowhdrentry = Spinbox(frame1,from_=0,to=300, width=10,
                            textvariable=self.rowheaderwidthvar)
        rowhdrentry.grid(row=row,column=1,padx=3,pady=2)
        row=row+1

        #fonts
        fts = self.getFonts()
        self.fontvar = StringVar()
        self.fontvar.set(self.prefs.get(&#39;celltextfont&#39;))
        def setFont(*args):
            self.thefont = self.fontvar.get()
            return

        self.fontbox = Combobox(frame2,
                        values=(fts),
                        text=&#39;Font:&#39;,
                        height = 6,
                        textvariable=self.fontvar)
        self.fontvar.trace(&#39;w&#39;, setFont)
        Label(frame2,text=&#39;Font:&#39;).grid(row=row,column=0,padx=3,pady=2)
        self.fontbox.grid(row=row,column=1, columnspan=2, sticky=&#39;nes&#39;, padx=3,pady=2)
        row=row+1

        lblfontsize=Label(frame2,text=&#39;Text Size:&#39;)
        lblfontsize.grid(row=row,column=0,padx=3,pady=2)
        fontsizeentry = Spinbox(frame2,from_=6,to=50, width=20,
                                textvariable=self.celltextsizevar)

        fontsizeentry.grid(row=row,column=1, sticky=&#39;wens&#39;,padx=3,pady=2)
        row=row+1

        #cell alignment
        lbl=Label(frame2,text=&#39;Alignment:&#39;)
        lbl.grid(row=row,column=0,padx=3,pady=2)
        alignentry_button = Menubutton(frame2,textvariable=self.cellalignvar, width=16)
        alignentry_menu = Menu(alignentry_button,tearoff=0)
        alignentry_button[&#39;menu&#39;] = alignentry_menu
        alignments=[&#39;w&#39;,&#39;e&#39;,&#39;center&#39;]
        for text in alignments:
            alignentry_menu.add_radiobutton(label=text,
                                            variable=self.cellalignvar,
                                            value=text,
                                            indicatoron=1)
        alignentry_button.grid(row=row,column=1, sticky=&#39;nes&#39;, padx=3,pady=2)
        row=row+1

        #colors
        style = Style()
        style.configure(&#34;cb.TButton&#34;, background=self.cellbackgr)
        cellbackgrbutton = Button(frame2, text=&#39;table background&#39;, style=&#34;cb.TButton&#34;, #bg=self.cellbackgr,
                                 command=self.setcellbackgr)
        cellbackgrbutton.grid(row=row,column=0,columnspan=2, sticky=&#39;news&#39;,padx=3,pady=2)
        row=row+1
        style = Style()
        style.configure(&#34;gc.TButton&#34;, background=self.grid_color)
        grid_colorbutton = Button(frame2, text=&#39;grid color&#39;,  style=&#34;gc.TButton&#34;, #bg=self.grid_color,
                                 command=self.setgrid_color)
        grid_colorbutton.grid(row=row,column=0,columnspan=2,  sticky=&#39;news&#39;,padx=3,pady=2)
        row=row+1
        style = Style()
        style.configure(&#34;rhc.TButton&#34;, background=self.rowselectedcolor)
        rowselectedcolorbutton = Button(frame2, text=&#39;row highlight color&#39;, style=&#34;rhc.TButton&#34;,
                                 command=self.setrowselectedcolor)
        rowselectedcolorbutton.grid(row=row,column=0,columnspan=2,  sticky=&#39;news&#39;,padx=3,pady=2)
        row=row+1

        frame=Frame(self.prefswindow)
        frame.pack()
        # Apply Button
        b = Button(frame, text=&#34;Apply Settings&#34;, command=self.applyPrefs)
        b.grid(row=row,column=1,columnspan=2,sticky=&#39;news&#39;,padx=4,pady=4)

        # Close button
        c=Button(frame,text=&#39;Close&#39;, command=close_prefsdialog)
        c.grid(row=row,column=0,sticky=&#39;news&#39;,padx=4,pady=4)
        self.prefswindow.focus_set()
        self.prefswindow.grab_set()
        self.prefswindow.wait_window()
        return self.prefswindow

    def getFonts(self):
        fonts = set(list(font.families()))
        fonts = sorted(list(fonts))
        return fonts

    def loadPrefs(self, prefs=None):
        &#34;&#34;&#34;Load table specific prefs from the prefs instance used
           if they are not present, create them.&#34;&#34;&#34;

        if prefs == None:
            prefs=Preferences(&#39;Table&#39;,{&#39;check_for_update&#39;:1})
        self.prefs = prefs
        defaultprefs = {&#39;horizlines&#39;:self.horizlines, &#39;vertlines&#39;:self.vertlines,
                        &#39;alternaterows&#39;:self.alternaterows,
                        &#39;rowheight&#39;:self.rowheight,
                        &#39;cellwidth&#39;:100,
                        &#39;autoresizecols&#39;: 0,
                        &#39;align&#39;: &#39;w&#39;,
                        &#39;celltextsize&#39;:11, &#39;celltextfont&#39;:&#39;Arial&#39;,
                        &#39;cellbackgr&#39;: self.cellbackgr, &#39;grid_color&#39;: self.grid_color,
                        &#39;linewidth&#39; : self.linewidth,
                        &#39;rowselectedcolor&#39;: self.rowselectedcolor,
                        &#39;rowheaderwidth&#39;: self.rowheaderwidth}

        #print (self.prefs.__dict__)
        for prop in defaultprefs:
            if not prop in self.prefs.prefs:
                #print (defaultprefs[prop])
                if defaultprefs[prop] != &#39;None&#39;:
                    self.prefs.set(prop, defaultprefs[prop])

        self.defaultprefs = defaultprefs

        #Create tkvars for dialog
        self.rowheightvar = IntVar()
        self.rowheightvar.set(self.prefs.get(&#39;rowheight&#39;))
        self.rowheight = self.rowheightvar.get()
        self.cellwidthvar = IntVar()
        self.cellwidthvar.set(self.prefs.get(&#39;cellwidth&#39;))
        self.cellwidth = self.cellwidthvar.get()
        self.cellalignvar = StringVar()
        self.cellalignvar.set(self.prefs.get(&#39;align&#39;))
        self.align = self.cellalignvar.get()
        self.linewidthvar = IntVar()
        self.linewidthvar.set(self.prefs.get(&#39;linewidth&#39;))
        self.horizlinesvar = IntVar()
        self.horizlinesvar.set(self.prefs.get(&#39;horizlines&#39;))
        self.vertlinesvar = IntVar()
        self.vertlinesvar.set(self.prefs.get(&#39;vertlines&#39;))
        self.alternaterowsvar = IntVar()
        self.alternaterowsvar.set(self.prefs.get(&#39;alternaterows&#39;))
        self.celltextsizevar = IntVar()
        self.celltextsizevar.set(self.prefs.get(&#39;celltextsize&#39;))
        self.cellbackgr = self.prefs.get(&#39;cellbackgr&#39;)
        self.grid_color = self.prefs.get(&#39;grid_color&#39;)
        self.rowselectedcolor = self.prefs.get(&#39;rowselectedcolor&#39;)
        self.fontsize = self.celltextsizevar.get()
        self.thefont = (self.prefs.get(&#39;celltextfont&#39;), self.prefs.get(&#39;celltextsize&#39;))
        self.rowheaderwidthvar = IntVar()
        self.rowheaderwidthvar.set(self.prefs.get(&#39;rowheaderwidth&#39;))
        self.rowheaderwidth = self.rowheaderwidthvar.get()
        return

    def savePrefs(self):
        &#34;&#34;&#34;Save and set the prefs&#34;&#34;&#34;

        try:
            self.prefs.set(&#39;horizlines&#39;, self.horizlinesvar.get())
            self.horizlines = self.horizlinesvar.get()
            self.prefs.set(&#39;vertlines&#39;, self.vertlinesvar.get())
            self.vertlines = self.vertlinesvar.get()
            self.prefs.set(&#39;alternaterows&#39;, self.alternaterowsvar.get())
            self.alternaterows = self.alternaterowsvar.get()
            self.prefs.set(&#39;rowheight&#39;, self.rowheightvar.get())
            self.rowheight = self.rowheightvar.get()
            self.prefs.set(&#39;cellwidth&#39;, self.cellwidthvar.get())
            self.cellwidth = self.cellwidthvar.get()
            self.prefs.set(&#39;align&#39;, self.cellalignvar.get())
            self.align = self.cellalignvar.get()
            self.prefs.set(&#39;linewidth&#39;, self.linewidthvar.get())
            self.linewidth = self.linewidthvar.get()
            self.prefs.set(&#39;celltextsize&#39;, self.celltextsizevar.get())
            self.prefs.set(&#39;celltextfont&#39;, self.fontvar.get())
            self.prefs.set(&#39;cellbackgr&#39;, self.cellbackgr)
            self.prefs.set(&#39;grid_color&#39;, self.grid_color)
            self.prefs.set(&#39;rowselectedcolor&#39;, self.rowselectedcolor)
            self.prefs.set(&#39;rowheaderwidth&#39;, self.rowheaderwidth)
            self.rowheaderwidth = self.rowheaderwidthvar.get()
            self.thefont = (self.prefs.get(&#39;celltextfont&#39;), self.prefs.get(&#39;celltextsize&#39;))
            self.fontsize = self.prefs.get(&#39;celltextsize&#39;)

        except ValueError as e:
            print (e)
            pass
        self.prefs.save_prefs()
        return

    def applyPrefs(self):
        &#34;&#34;&#34;Apply prefs to the table by redrawing&#34;&#34;&#34;

        self.savePrefs()
        self.redrawTable()
        return

    def AskForColorButton(self, frame, text, func):
        def SetColor():
            ctuple, variable = tkColorChooser.askcolor(title=&#39;pick a color&#39;,
                                                       initialcolor=self.cellbackgr)

            return
        bgcolorbutton = Button(frame, text=text,command=SetColor)
        return  bgcolorbutton

    def check_hyperlink(self,event=None):
        &#34;&#34;&#34;Check if a hyperlink was clicked&#34;&#34;&#34;

        row = self.get_row_clicked(event)
        col = self.get_col_clicked(event)
        #absrow = self.get_AbsoluteRow(row)
        recdata = self.model.getValueAt(row, col)
        try:
            link = recdata[&#39;link&#39;]
            import webbrowser
            webbrowser.open(link,autoraise=1)
        except:
            pass
        return

    def show_progressbar(self,message=None):
        &#34;&#34;&#34;Show progress bar window for loading of data&#34;&#34;&#34;
        progress_win=Toplevel() # Open a new window
        progress_win.title(&#34;Please Wait&#34;)
        #progress_win.geometry(&#39;+%d+%d&#39; %(self.parentframe.rootx+200,self.parentframe.rooty+200))
        #force on top
        progress_win.grab_set()
        progress_win.transient(self.parentframe)
        if message==None:
            message=&#39;Working&#39;
        lbl = Label(progress_win,text=message,font=&#39;Arial 16&#39;)

        lbl.grid(row=0,column=0,columnspan=2,sticky=&#39;news&#39;,padx=6,pady=4)
        progrlbl = Label(progress_win,text=&#39;Progress:&#39;)
        progrlbl.grid(row=1,column=0,sticky=&#39;news&#39;,padx=2,pady=4)
        import ProgressBar
        self.bar = ProgressBar.ProgressBar(progress_win)
        self.bar.frame.grid(row=1,column=1,columnspan=2,padx=2,pady=4)

        return progress_win

    def updateModel(self, model):
        &#34;&#34;&#34;Call this method to update the table model&#34;&#34;&#34;

        self.model = model
        self.rows = self.model.getRowCount()
        self.cols = self.model.getColumnCount()
        self.tablewidth = (self.cellwidth)*self.cols
        self.tablecolheader = ColumnHeader(self.parentframe, self)
        self.tablerowheader = RowHeader(self.parentframe, self)
        self.createTableFrame()
        return

    def new(self):
        &#34;&#34;&#34;Clears all the data and makes a new table&#34;&#34;&#34;

        mpDlg = MultipleValDialog(title=&#39;Create new table&#39;,
                                    initialvalues=(10, 4),
                                    labels=(&#39;rows&#39;,&#39;columns&#39;),
                                    types=(&#39;int&#39;,&#39;int&#39;),
                                    parent=self.parentframe)

        if mpDlg.result == True:
            rows = mpDlg.results[0]
            cols = mpDlg.results[1]
            model = TableModel(rows=rows,columns=cols)
            self.updateModel(model)
        return

    def load(self, filename=None):
        &#34;&#34;&#34;load from a file&#34;&#34;&#34;

        if filename == None:
            filename = filedialog.askopenfilename(parent=self.master,
                                                      defaultextension=&#39;.table&#39;,
                                                      initialdir=os.getcwd(),
                                                      filetypes=[(&#34;pickle&#34;,&#34;*.table&#34;),
                                                        (&#34;All files&#34;,&#34;*.*&#34;)])
        if not os.path.exists(filename):
            print (&#39;file does not exist&#39;)
            return
        if filename:
            self.model.load(filename)
            self.redrawTable()
        return

    def save(self, filename=None):
        &#34;&#34;&#34;Save model to pickle file&#34;&#34;&#34;

        if filename == None:
            filename = filedialog.asksaveasfilename(parent=self.master,
                                                        defaultextension=&#39;.table&#39;,
                                                        initialdir=os.getcwd(),
                                                        filetypes=[(&#34;pickle&#34;,&#34;*.table&#34;),
                                                          (&#34;All files&#34;,&#34;*.*&#34;)])
        if filename:
            self.model.save(filename)
        return

    def importTable(self):
        self.importCSV()

    def importCSV(self, filename=None):
        &#34;&#34;&#34;Import from csv file&#34;&#34;&#34;

        if filename is None:
            from .Tables_IO import TableImporter
            importer = TableImporter()
            importdialog = importer.import_Dialog(self.master)
            self.master.wait_window(importdialog)
            model = TableModel()
            model.importDict(importer.data)
        else:
            model = TableModel()
            model.importCSV(filename)
        self.updateModel(model)
        return

    def exportTable(self, filename=None):
        &#34;&#34;&#34;Do a simple export of the cell contents to csv&#34;&#34;&#34;

        from .Tables_IO import TableExporter
        exporter = TableExporter()
        exporter.ExportTableData(self)
        return

    @classmethod
    def checkOSType(cls):
        &#34;&#34;&#34;Check the OS we are in&#34;&#34;&#34;

        ostyp=&#39;&#39;
        var_s=[&#39;OSTYPE&#39;,&#39;OS&#39;]
        for var in var_s:
            if var in os.environ:
                try:
                    ostyp = str.lower(os.environ[var])
                except:
                    ostyp = os.environ[var].lower()

        ostyp=ostyp.lower()
        if ostyp.find(&#39;windows&#39;)!=-1:
            ostyp=&#39;windows&#39;
        elif ostyp.find(&#39;darwin&#39;)!=-1 or ostyp.find(&#39;apple&#39;)!=-1:
            ostyp=&#39;mac&#39;
        elif ostyp.find(&#39;linux&#39;)!=-1:
            ostyp=&#39;linux&#39;
        else:
            ostyp=&#39;unknown&#39;
            try:
                info=os.uname()
            except:
                pass
            ostyp=info[0].lower()
            if ostyp.find(&#39;darwin&#39;)!=-1:
                ostyp=&#39;mac&#39;
        return ostyp

    def getGeometry(self, frame):
        &#34;&#34;&#34;Get frame geometry&#34;&#34;&#34;
        return frame.winfo_rootx(), frame.winfo_rooty(), frame.winfo_width(), frame.winfo_height()

class ColumnHeader(Canvas):
    &#34;&#34;&#34;Class that takes it&#39;s size and rendering from a parent table
        and column names from the table model.&#34;&#34;&#34;

    def __init__(self, parent=None, table=None):
        Canvas.__init__(self, parent, bg=&#39;gray25&#39;, width=500, height=20)
        self.thefont=&#39;Arial 14&#39;
        if table != None:
            self.table = table
            self.height = 20
            self.model = self.table.getModel()
            self.config(width=self.table.width)
            #self.colnames = self.model.columnNames
            self.columnlabels = self.model.columnlabels
            self.bind(&#39;&lt;Button-1&gt;&#39;,self.handle_left_click)
            self.bind(&#34;&lt;ButtonRelease-1&gt;&#34;, self.handle_left_release)
            self.bind(&#39;&lt;B1-Motion&gt;&#39;, self.handle_mouse_drag)
            self.bind(&#39;&lt;Motion&gt;&#39;, self.handle_mouse_move)
            self.bind(&#39;&lt;Shift-Button-1&gt;&#39;, self.handle_left_shift_click)
            if self.table.ostyp==&#39;mac&#39;:
                #For mac we bind Shift, left-click to right click
                self.bind(&#34;&lt;Button-2&gt;&#34;, self.handle_right_click)
                self.bind(&#39;&lt;Shift-Button-1&gt;&#39;,self.handle_right_click)
            else:
                self.bind(&#34;&lt;Button-3&gt;&#34;, self.handle_right_click)
            self.thefont = self.table.thefont
        return

    def redraw(self):

        cols = self.model.getColumnCount()
        self.tablewidth=self.table.tablewidth
        self.configure(scrollregion=(0,0, self.table.tablewidth+self.table.x_start, self.height))
        self.delete(&#39;gridline&#39;,&#39;text&#39;)
        self.delete(&#39;rect&#39;)
        self.atdivider = None
        align=&#39;w&#39;
        pad=4
        h=self.height
        #x_start=self.table.x_start

        if cols == 0:
            return
        for col in self.table.visiblecols:
            colname = self.model.columnNames[col]
            if not colname in self.model.columnlabels:
                self.model.columnlabels[colname]=colname
            collabel = self.model.columnlabels[colname]
            if colname in self.model.columnwidths:
                w = self.model.columnwidths[colname]
            else:
                w = self.table.cellwidth
            x = self.table.col_positions[col]

            if len(collabel)&gt;w/10:
                collabel = collabel[0:int(w/12)]+&#39;.&#39;
            line = self.create_line(x, 0, x, h, tag=(&#39;gridline&#39;, &#39;vertline&#39;),
                                 fill=&#39;white&#39;, width=2)

            self.create_text(x+pad,h/2,
                            text=collabel,
                            anchor=align,
                            fill=&#39;white&#39;,
                            font=self.thefont,
                            tag=&#39;text&#39;)


        x=self.table.col_positions[col+1]
        self.create_line(x,0, x,h, tag=&#39;gridline&#39;,
                        fill=&#39;white&#39;, width=2)

        return

    def handle_left_click(self,event):
        &#34;&#34;&#34;Does cell selection when mouse is clicked on canvas&#34;&#34;&#34;

        self.delete(&#39;rect&#39;)
        self.table.delete(&#39;entry&#39;)
        self.table.delete(&#39;multicellrect&#39;)
        colclicked = self.table.get_col_clicked(event)
        if colclicked == None:
            return
        #set all rows selected
        self.table.allrows = True
        self.table.setSelectedCol(colclicked)

        if self.atdivider == 1:
            return
        self.drawRect(self.table.currentcol)
        #also draw a copy of the rect to be dragged
        self.draggedcol = None
        self.drawRect(self.table.currentcol, tag=&#39;dragrect&#39;,
                        color=&#39;red&#39;, outline=&#39;white&#39;)
        if hasattr(self, &#39;rightmenu&#39;):
            self.rightmenu.destroy()
        #finally, draw the selected col on the table
        self.table.drawSelectedCol()
        return

    def handle_left_release(self,event):
        &#34;&#34;&#34;When mouse released implement resize or col move&#34;&#34;&#34;

        self.delete(&#39;dragrect&#39;)
        if self.atdivider == 1:
            #col = self.table.get_col_clicked(event)
            x=int(self.canvasx(event.x))
            col = self.table.currentcol
            x1,y1,x2,y2 = self.table.getCellCoords(0,col)
            newwidth=x - x1
            if newwidth &lt; 5:
                newwidth=5
            self.table.resizeColumn(col, newwidth)
            self.table.delete(&#39;resizeline&#39;)
            self.delete(&#39;resizeline&#39;)
            self.delete(&#39;resizesymbol&#39;)
            self.atdivider = 0
            return
        self.delete(&#39;resizesymbol&#39;)
        #move column
        if self.draggedcol != None and self.table.currentcol != self.draggedcol:
            self.model.moveColumn(self.table.currentcol, self.draggedcol)
            self.table.setSelectedCol(self.draggedcol)
            self.table.redrawTable()
            self.table.drawSelectedCol(self.table.currentcol)
            self.drawRect(self.table.currentcol)
        return

    def handle_mouse_drag(self, event):
        &#34;&#34;&#34;Handle column drag, will be either to move cols or resize&#34;&#34;&#34;

        x=int(self.canvasx(event.x))
        if self.atdivider == 1:
            self.table.delete(&#39;resizeline&#39;)
            self.delete(&#39;resizeline&#39;)
            self.table.create_line(x, 0, x, self.table.rowheight*self.table.rows,
                                width=2, fill=&#39;gray&#39;, tag=&#39;resizeline&#39;)
            self.create_line(x, 0, x, self.height,
                                width=2, fill=&#39;gray&#39;, tag=&#39;resizeline&#39;)
            return
        else:
            w = self.table.cellwidth
            self.draggedcol = self.table.get_col_clicked(event)
            x1, y1, x2, y2 = self.coords(&#39;dragrect&#39;)
            x=int(self.canvasx(event.x))
            y = self.canvasy(event.y)
            self.move(&#39;dragrect&#39;, x-x1-w/2, 0)

        return

    def within(self, val, l, d):
        &#34;&#34;&#34;Utility funtion to see if val is within d of any
            items in the list l&#34;&#34;&#34;
        for v in l:
            if abs(val-v) &lt;= d:
                return 1
        return 0

    def handle_mouse_move(self, event):
        &#34;&#34;&#34;Handle mouse moved in header, if near divider draw resize symbol&#34;&#34;&#34;

        self.delete(&#39;resizesymbol&#39;)
        w=self.table.cellwidth
        h=self.height
        x_start=self.table.x_start
        #x = event.x
        x=int(self.canvasx(event.x))
        if x &gt; self.tablewidth+w:
            return
        #if event x is within x pixels of divider, draw resize symbol
        if x!=x_start and self.within(x, self.table.col_positions, 4):
            col = self.table.get_col_clicked(event)
            if col == None:
                return
            self.draw_resize_symbol(col)
            self.atdivider = 1
        else:
            self.atdivider = 0
        return

    def handle_right_click(self, event):
        &#34;&#34;&#34;respond to a right click&#34;&#34;&#34;

        self.handle_left_click(event)
        if self.table.read_only == False:
            self.rightmenu = self.popupMenu(event)
        return

    def handle_right_release(self, event):
        self.rightmenu.destroy()
        return

    def handle_left_shift_click(self, event):
        &#34;&#34;&#34;Handle shift click, for selecting multiple cols&#34;&#34;&#34;

        self.table.delete(&#39;colrect&#39;)
        self.delete(&#39;rect&#39;)
        currcol = self.table.currentcol
        colclicked = self.table.get_col_clicked(event)
        if colclicked &gt; currcol:
            self.table.multiplecollist = range(currcol, colclicked+1)
        elif colclicked &lt; currcol:
            self.table.multiplecollist = range(colclicked, currcol+1)
        else:
            return

        #print self.table.multiplecollist
        for c in self.table.multiplecollist:
            self.drawRect(c, delete=0)
            self.table.drawSelectedCol(c, delete=0)
        return

    def popupMenu(self, event):
        &#34;&#34;&#34;Add left and right click behaviour for column header&#34;&#34;&#34;

        colname = self.model.columnNames[self.table.currentcol]
        collabel = self.model.columnlabels[colname]
        currcol = self.table.currentcol
        popupmenu = Menu(self, tearoff = 0)
        def popupFocusOut(event):
            popupmenu.unpost()
        popupmenu.add_command(label=&#34;Rename Column&#34;, command=self.relabel_Column)
        popupmenu.add_command(label=&#34;Sort by &#34;+ collabel, command=lambda : self.table.sortTable(currcol))
        popupmenu.add_command(label=&#34;Sort by &#34;+ collabel +&#39; (descending)&#39;, command=lambda : self.table.sortTable(currcol,reverse=1))
        popupmenu.add_command(label=&#34;Delete This Column&#34;, command=self.table.deleteColumn)
        popupmenu.add_command(label=&#34;Add New Column&#34;, command=self.table.addColumn)

        popupmenu.bind(&#34;&lt;FocusOut&gt;&#34;, popupFocusOut)
        #self.bind(&#34;&lt;Button-3&gt;&#34;, popupFocusOut)
        popupmenu.focus_set()
        popupmenu.post(event.x_root, event.y_root)
        return popupmenu

    def relabel_Column(self):
        col=self.table.currentcol
        ans = simpledialog.askstring(&#34;New column name?&#34;, &#34;Enter new name:&#34;)
        if ans !=None:
            if ans == &#39;&#39;:
                messagebox.showwarning(&#34;Error&#34;, &#34;Name should not be blank.&#34;)
                return
            else:
                self.model.relabel_Column(col, ans)
                self.redraw()
        return

    def draw_resize_symbol(self, col):
        &#34;&#34;&#34;Draw a symbol to show that col can be resized when mouse here&#34;&#34;&#34;

        self.delete(&#39;resizesymbol&#39;)
        w=self.table.cellwidth
        h=self.height
        wdth=1
        hfac1=0.2
        hfac2=0.4
        x_start=self.table.x_start
        x1,y1,x2,y2 = self.table.getCellCoords(0,col)

        self.create_polygon(x2-3,h/4, x2-10,h/2, x2-3,h*3/4, tag=&#39;resizesymbol&#39;,
            fill=&#39;white&#39;, outline=&#39;gray&#39;, width=wdth)
        self.create_polygon(x2+2,h/4, x2+10,h/2, x2+2,h*3/4, tag=&#39;resizesymbol&#39;,
            fill=&#39;white&#39;, outline=&#39;gray&#39;, width=wdth)
        return

    def drawRect(self,col, tag=None, color=None, outline=None, delete=1):
        &#34;&#34;&#34;User has clicked to select a col&#34;&#34;&#34;

        if tag==None:
            tag=&#39;rect&#39;
        if color==None:
            color=&#39;#0099CC&#39;
        if outline==None:
            outline=&#39;gray25&#39;
        if delete == 1:
            self.delete(tag)
        w=2
        x1,y1,x2,y2 = self.table.getCellCoords(0,col)
        rect = self.create_rectangle(x1,y1-w,x2,self.height,
                                  fill=color,
                                  outline=outline,
                                  width=w,
                                  stipple=&#39;gray50&#39;,
                                  tag=tag)
        self.lower(tag)
        return

class RowHeader(Canvas):
    &#34;&#34;&#34;Class that displays the row headings on the table
       takes it&#39;s size and rendering from the parent table
       This also handles row/record selection as opposed to cell
       selection&#34;&#34;&#34;

    def __init__(self, parent=None, table=None, width=40):
        Canvas.__init__(self, parent, bg=&#39;gray75&#39;, width=width, height=None)

        if table != None:
            self.table = table
            self.width = width
            self.x_start = 0
            self.inset = 1
            self.config(height = self.table.height)
            self.startrow = self.endrow = None
            self.model = self.table.getModel()
            self.bind(&#39;&lt;Button-1&gt;&#39;,self.handle_left_click)
            self.bind(&#34;&lt;ButtonRelease-1&gt;&#34;, self.handle_left_release)
            self.bind(&#34;&lt;Control-Button-1&gt;&#34;, self.handle_left_ctrl_click)
            self.bind(&#39;&lt;Button-3&gt;&#39;,self.handle_right_click)
            self.bind(&#39;&lt;B1-Motion&gt;&#39;, self.handle_mouse_drag)
            #self.bind(&#39;&lt;Shift-Button-1&gt;&#39;, self.handle_left_shift_click)
        return

    def redraw(self, align=&#39;w&#39;, showkeys=False):
        &#34;&#34;&#34;Redraw row header&#34;&#34;&#34;

        self.height = self.table.rowheight * self.table.rows+10
        self.configure(scrollregion=(0,0, self.width, self.height))
        self.delete(&#39;rowheader&#39;,&#39;text&#39;)
        self.delete(&#39;rect&#39;)
        w = float(self.width)
        h = self.table.rowheight
        x = self.x_start+w/2
        if align == &#39;w&#39;:
            x = x-w/2+3
        elif align == &#39;e&#39;:
            x = x+w/2-3
        for row in self.table.visiblerows:
            if showkeys == True:
                text = self.model.getRecName(row)
            else:
                text = row+1
            x1,y1,x2,y2 = self.table.getCellCoords(row,0)
            self.create_rectangle(0,y1,w-1,y2,
                                      fill=&#39;gray75&#39;,
                                      outline=&#39;white&#39;,
                                      width=1,
                                      tag=&#39;rowheader&#39;)
            self.create_text(x,y1+h/2,
                                      text=text,
                                      fill=&#39;black&#39;,
                                      font=self.table.thefont,
                                      tag=&#39;text&#39;, anchor=align)
        return

    def setWidth(self, w):
        &#34;&#34;&#34;Set width&#34;&#34;&#34;
        self.width = w
        self.redraw()
        return

    def clearSelected(self):
        self.delete(&#39;rect&#39;)
        return

    def handle_left_click(self, event):
        rowclicked = self.table.get_row_clicked(event)
        self.startrow = rowclicked
        if 0 &lt;= rowclicked &lt; self.table.rows:
            self.delete(&#39;rect&#39;)
            self.table.delete(&#39;entry&#39;)
            self.table.delete(&#39;multicellrect&#39;)
            #set row selected
            self.table.setSelectedRow(rowclicked)
            self.table.drawSelectedRow()
            self.drawSelectedRows(self.table.currentrow)
        return

    def handle_left_release(self,event):

        return

    def handle_left_ctrl_click(self, event):
        &#34;&#34;&#34;Handle ctrl clicks - for multiple row selections&#34;&#34;&#34;

        rowclicked = self.table.get_row_clicked(event)
        multirowlist = self.table.multiplerowlist
        if 0 &lt;= rowclicked &lt; self.table.rows:
            if rowclicked not in multirowlist:
                multirowlist.append(rowclicked)
            else:
                multirowlist.remove(rowclicked)
            self.table.drawMultipleRows(multirowlist)
            self.drawSelectedRows(multirowlist)
        return

    def handle_right_click(self,event):

        return

    &#39;&#39;&#39;def handle_mouse_drag(self, event):
        &#34;&#34;&#34;Handle mouse drag for mult row selection&#34;&#34;&#34;
        rowover = self.table.get_row_clicked(event)
        colover = self.table.get_col_clicked(event)
        if colover == None or rowover == None:
            return&#39;&#39;&#39;

    def handle_mouse_drag(self, event):
        &#34;&#34;&#34;Handle mouse moved with button held down, multiple selections&#34;&#34;&#34;

        if hasattr(self, &#39;cellentry&#39;):
            self.cellentry.destroy()
        rowover = self.table.get_row_clicked(event)
        colover = self.table.get_col_clicked(event)
        if rowover == None:
            return
        if rowover &gt;= self.table.rows or self.startrow &gt; self.table.rows:
            return
        else:
            self.endrow = rowover
        #draw the selected rows
        if self.endrow != self.startrow:
            if self.endrow &lt; self.startrow:
                rowlist=range(self.endrow, self.startrow+1)
            else:
                rowlist=range(self.startrow, self.endrow+1)
            self.drawSelectedRows(rowlist)
            self.table.multiplerowlist = rowlist
            self.table.drawMultipleRows(rowlist)
        else:
            self.table.multiplerowlist = []
            self.table.multiplerowlist.append(rowover)
            self.drawSelectedRows(rowover)
            self.table.drawMultipleRows(self.table.multiplerowlist)
        return

    def drawSelectedRows(self, rows=None):
        &#34;&#34;&#34;Draw selected rows, accepts a list or integer&#34;&#34;&#34;

        self.delete(&#39;rect&#39;)
        if type(rows) is not list:
            rowlist=[]
            rowlist.append(rows)
        else:
           rowlist = rows
        for r in rowlist:
            if r not in self.table.visiblerows:
                continue
            self.drawRect(r, delete=0)
        return

    def drawRect(self, row=None, tag=None, color=None, outline=None, delete=1):
        &#34;&#34;&#34;Draw a rect representing row selection&#34;&#34;&#34;

        if tag==None:
            tag=&#39;rect&#39;
        if color==None:
            color=&#39;#0099CC&#39;
        if outline==None:
            outline=&#39;gray25&#39;
        if delete == 1:
            self.delete(tag)
        w=0
        i = self.inset
        x1,y1,x2,y2 = self.table.getCellCoords(row, 0)
        rect = self.create_rectangle(0+i,y1+i,self.width-i,y2,
                                      fill=color,
                                      outline=outline,
                                      width=w,
                                      tag=tag)
        self.lift(&#39;text&#39;)
        return

class AutoScrollbar(Scrollbar):
    &#34;&#34;&#34;a scrollbar that hides itself if it&#39;s not needed.  only
       works if you use the grid geometry manager.&#34;&#34;&#34;

    def set(self, lo, hi):
        if float(lo) &lt;= 0.0 and float(hi) &gt;= 1.0:
            # grid_remove is currently missing from Tkinter!
            self.tk.call(&#34;grid&#34;, &#34;remove&#34;, self)
        else:
            self.grid()
        Scrollbar.set(self, lo, hi)
    #def pack(self, **kw):
    #    raise TclError, &#34;cannot use pack with this widget&#34;
    #def place(self, **kw):
    #    raise TclError, &#34;cannot use place with this widget&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tkintertable.Tables.AutoScrollbar"><code class="flex name class">
<span>class <span class="ident">AutoScrollbar</span></span>
<span>(</span><span>master=None, **kw)</span>
</code></dt>
<dd>
<section class="desc"><p>a scrollbar that hides itself if it's not needed.
only
works if you use the grid geometry manager.</p>
<p>Construct a Ttk Scrollbar with parent master.</p>
<p>STANDARD OPTIONS</p>
<pre><code>class, cursor, style, takefocus
</code></pre>
<p>WIDGET-SPECIFIC OPTIONS</p>
<pre><code>command, orient
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class AutoScrollbar(Scrollbar):
    &#34;&#34;&#34;a scrollbar that hides itself if it&#39;s not needed.  only
       works if you use the grid geometry manager.&#34;&#34;&#34;

    def set(self, lo, hi):
        if float(lo) &lt;= 0.0 and float(hi) &gt;= 1.0:
            # grid_remove is currently missing from Tkinter!
            self.tk.call(&#34;grid&#34;, &#34;remove&#34;, self)
        else:
            self.grid()
        Scrollbar.set(self, lo, hi)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.ttk.Scrollbar</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Scrollbar</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tkintertable.Tables.AutoScrollbar.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, lo, hi)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the fractional values of the slider position (upper and
lower ends as value between 0 and 1).</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set(self, lo, hi):
    if float(lo) &lt;= 0.0 and float(hi) &gt;= 1.0:
        # grid_remove is currently missing from Tkinter!
        self.tk.call(&#34;grid&#34;, &#34;remove&#34;, self)
    else:
        self.grid()
    Scrollbar.set(self, lo, hi)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tkintertable.Tables.ColumnHeader"><code class="flex name class">
<span>class <span class="ident">ColumnHeader</span></span>
<span>(</span><span>parent=None, table=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Class that takes it's size and rendering from a parent table
and column names from the table model.</p>
<p>Construct a canvas widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, closeenough,
confine, cursor, height, highlightbackground, highlightcolor,
highlightthickness, insertbackground, insertborderwidth,
insertofftime, insertontime, insertwidth, offset, relief,
scrollregion, selectbackground, selectborderwidth, selectforeground,
state, takefocus, width, xscrollcommand, xscrollincrement,
yscrollcommand, yscrollincrement.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ColumnHeader(Canvas):
    &#34;&#34;&#34;Class that takes it&#39;s size and rendering from a parent table
        and column names from the table model.&#34;&#34;&#34;

    def __init__(self, parent=None, table=None):
        Canvas.__init__(self, parent, bg=&#39;gray25&#39;, width=500, height=20)
        self.thefont=&#39;Arial 14&#39;
        if table != None:
            self.table = table
            self.height = 20
            self.model = self.table.getModel()
            self.config(width=self.table.width)
            #self.colnames = self.model.columnNames
            self.columnlabels = self.model.columnlabels
            self.bind(&#39;&lt;Button-1&gt;&#39;,self.handle_left_click)
            self.bind(&#34;&lt;ButtonRelease-1&gt;&#34;, self.handle_left_release)
            self.bind(&#39;&lt;B1-Motion&gt;&#39;, self.handle_mouse_drag)
            self.bind(&#39;&lt;Motion&gt;&#39;, self.handle_mouse_move)
            self.bind(&#39;&lt;Shift-Button-1&gt;&#39;, self.handle_left_shift_click)
            if self.table.ostyp==&#39;mac&#39;:
                #For mac we bind Shift, left-click to right click
                self.bind(&#34;&lt;Button-2&gt;&#34;, self.handle_right_click)
                self.bind(&#39;&lt;Shift-Button-1&gt;&#39;,self.handle_right_click)
            else:
                self.bind(&#34;&lt;Button-3&gt;&#34;, self.handle_right_click)
            self.thefont = self.table.thefont
        return

    def redraw(self):

        cols = self.model.getColumnCount()
        self.tablewidth=self.table.tablewidth
        self.configure(scrollregion=(0,0, self.table.tablewidth+self.table.x_start, self.height))
        self.delete(&#39;gridline&#39;,&#39;text&#39;)
        self.delete(&#39;rect&#39;)
        self.atdivider = None
        align=&#39;w&#39;
        pad=4
        h=self.height
        #x_start=self.table.x_start

        if cols == 0:
            return
        for col in self.table.visiblecols:
            colname = self.model.columnNames[col]
            if not colname in self.model.columnlabels:
                self.model.columnlabels[colname]=colname
            collabel = self.model.columnlabels[colname]
            if colname in self.model.columnwidths:
                w = self.model.columnwidths[colname]
            else:
                w = self.table.cellwidth
            x = self.table.col_positions[col]

            if len(collabel)&gt;w/10:
                collabel = collabel[0:int(w/12)]+&#39;.&#39;
            line = self.create_line(x, 0, x, h, tag=(&#39;gridline&#39;, &#39;vertline&#39;),
                                 fill=&#39;white&#39;, width=2)

            self.create_text(x+pad,h/2,
                            text=collabel,
                            anchor=align,
                            fill=&#39;white&#39;,
                            font=self.thefont,
                            tag=&#39;text&#39;)


        x=self.table.col_positions[col+1]
        self.create_line(x,0, x,h, tag=&#39;gridline&#39;,
                        fill=&#39;white&#39;, width=2)

        return

    def handle_left_click(self,event):
        &#34;&#34;&#34;Does cell selection when mouse is clicked on canvas&#34;&#34;&#34;

        self.delete(&#39;rect&#39;)
        self.table.delete(&#39;entry&#39;)
        self.table.delete(&#39;multicellrect&#39;)
        colclicked = self.table.get_col_clicked(event)
        if colclicked == None:
            return
        #set all rows selected
        self.table.allrows = True
        self.table.setSelectedCol(colclicked)

        if self.atdivider == 1:
            return
        self.drawRect(self.table.currentcol)
        #also draw a copy of the rect to be dragged
        self.draggedcol = None
        self.drawRect(self.table.currentcol, tag=&#39;dragrect&#39;,
                        color=&#39;red&#39;, outline=&#39;white&#39;)
        if hasattr(self, &#39;rightmenu&#39;):
            self.rightmenu.destroy()
        #finally, draw the selected col on the table
        self.table.drawSelectedCol()
        return

    def handle_left_release(self,event):
        &#34;&#34;&#34;When mouse released implement resize or col move&#34;&#34;&#34;

        self.delete(&#39;dragrect&#39;)
        if self.atdivider == 1:
            #col = self.table.get_col_clicked(event)
            x=int(self.canvasx(event.x))
            col = self.table.currentcol
            x1,y1,x2,y2 = self.table.getCellCoords(0,col)
            newwidth=x - x1
            if newwidth &lt; 5:
                newwidth=5
            self.table.resizeColumn(col, newwidth)
            self.table.delete(&#39;resizeline&#39;)
            self.delete(&#39;resizeline&#39;)
            self.delete(&#39;resizesymbol&#39;)
            self.atdivider = 0
            return
        self.delete(&#39;resizesymbol&#39;)
        #move column
        if self.draggedcol != None and self.table.currentcol != self.draggedcol:
            self.model.moveColumn(self.table.currentcol, self.draggedcol)
            self.table.setSelectedCol(self.draggedcol)
            self.table.redrawTable()
            self.table.drawSelectedCol(self.table.currentcol)
            self.drawRect(self.table.currentcol)
        return

    def handle_mouse_drag(self, event):
        &#34;&#34;&#34;Handle column drag, will be either to move cols or resize&#34;&#34;&#34;

        x=int(self.canvasx(event.x))
        if self.atdivider == 1:
            self.table.delete(&#39;resizeline&#39;)
            self.delete(&#39;resizeline&#39;)
            self.table.create_line(x, 0, x, self.table.rowheight*self.table.rows,
                                width=2, fill=&#39;gray&#39;, tag=&#39;resizeline&#39;)
            self.create_line(x, 0, x, self.height,
                                width=2, fill=&#39;gray&#39;, tag=&#39;resizeline&#39;)
            return
        else:
            w = self.table.cellwidth
            self.draggedcol = self.table.get_col_clicked(event)
            x1, y1, x2, y2 = self.coords(&#39;dragrect&#39;)
            x=int(self.canvasx(event.x))
            y = self.canvasy(event.y)
            self.move(&#39;dragrect&#39;, x-x1-w/2, 0)

        return

    def within(self, val, l, d):
        &#34;&#34;&#34;Utility funtion to see if val is within d of any
            items in the list l&#34;&#34;&#34;
        for v in l:
            if abs(val-v) &lt;= d:
                return 1
        return 0

    def handle_mouse_move(self, event):
        &#34;&#34;&#34;Handle mouse moved in header, if near divider draw resize symbol&#34;&#34;&#34;

        self.delete(&#39;resizesymbol&#39;)
        w=self.table.cellwidth
        h=self.height
        x_start=self.table.x_start
        #x = event.x
        x=int(self.canvasx(event.x))
        if x &gt; self.tablewidth+w:
            return
        #if event x is within x pixels of divider, draw resize symbol
        if x!=x_start and self.within(x, self.table.col_positions, 4):
            col = self.table.get_col_clicked(event)
            if col == None:
                return
            self.draw_resize_symbol(col)
            self.atdivider = 1
        else:
            self.atdivider = 0
        return

    def handle_right_click(self, event):
        &#34;&#34;&#34;respond to a right click&#34;&#34;&#34;

        self.handle_left_click(event)
        if self.table.read_only == False:
            self.rightmenu = self.popupMenu(event)
        return

    def handle_right_release(self, event):
        self.rightmenu.destroy()
        return

    def handle_left_shift_click(self, event):
        &#34;&#34;&#34;Handle shift click, for selecting multiple cols&#34;&#34;&#34;

        self.table.delete(&#39;colrect&#39;)
        self.delete(&#39;rect&#39;)
        currcol = self.table.currentcol
        colclicked = self.table.get_col_clicked(event)
        if colclicked &gt; currcol:
            self.table.multiplecollist = range(currcol, colclicked+1)
        elif colclicked &lt; currcol:
            self.table.multiplecollist = range(colclicked, currcol+1)
        else:
            return

        #print self.table.multiplecollist
        for c in self.table.multiplecollist:
            self.drawRect(c, delete=0)
            self.table.drawSelectedCol(c, delete=0)
        return

    def popupMenu(self, event):
        &#34;&#34;&#34;Add left and right click behaviour for column header&#34;&#34;&#34;

        colname = self.model.columnNames[self.table.currentcol]
        collabel = self.model.columnlabels[colname]
        currcol = self.table.currentcol
        popupmenu = Menu(self, tearoff = 0)
        def popupFocusOut(event):
            popupmenu.unpost()
        popupmenu.add_command(label=&#34;Rename Column&#34;, command=self.relabel_Column)
        popupmenu.add_command(label=&#34;Sort by &#34;+ collabel, command=lambda : self.table.sortTable(currcol))
        popupmenu.add_command(label=&#34;Sort by &#34;+ collabel +&#39; (descending)&#39;, command=lambda : self.table.sortTable(currcol,reverse=1))
        popupmenu.add_command(label=&#34;Delete This Column&#34;, command=self.table.deleteColumn)
        popupmenu.add_command(label=&#34;Add New Column&#34;, command=self.table.addColumn)

        popupmenu.bind(&#34;&lt;FocusOut&gt;&#34;, popupFocusOut)
        #self.bind(&#34;&lt;Button-3&gt;&#34;, popupFocusOut)
        popupmenu.focus_set()
        popupmenu.post(event.x_root, event.y_root)
        return popupmenu

    def relabel_Column(self):
        col=self.table.currentcol
        ans = simpledialog.askstring(&#34;New column name?&#34;, &#34;Enter new name:&#34;)
        if ans !=None:
            if ans == &#39;&#39;:
                messagebox.showwarning(&#34;Error&#34;, &#34;Name should not be blank.&#34;)
                return
            else:
                self.model.relabel_Column(col, ans)
                self.redraw()
        return

    def draw_resize_symbol(self, col):
        &#34;&#34;&#34;Draw a symbol to show that col can be resized when mouse here&#34;&#34;&#34;

        self.delete(&#39;resizesymbol&#39;)
        w=self.table.cellwidth
        h=self.height
        wdth=1
        hfac1=0.2
        hfac2=0.4
        x_start=self.table.x_start
        x1,y1,x2,y2 = self.table.getCellCoords(0,col)

        self.create_polygon(x2-3,h/4, x2-10,h/2, x2-3,h*3/4, tag=&#39;resizesymbol&#39;,
            fill=&#39;white&#39;, outline=&#39;gray&#39;, width=wdth)
        self.create_polygon(x2+2,h/4, x2+10,h/2, x2+2,h*3/4, tag=&#39;resizesymbol&#39;,
            fill=&#39;white&#39;, outline=&#39;gray&#39;, width=wdth)
        return

    def drawRect(self,col, tag=None, color=None, outline=None, delete=1):
        &#34;&#34;&#34;User has clicked to select a col&#34;&#34;&#34;

        if tag==None:
            tag=&#39;rect&#39;
        if color==None:
            color=&#39;#0099CC&#39;
        if outline==None:
            outline=&#39;gray25&#39;
        if delete == 1:
            self.delete(tag)
        w=2
        x1,y1,x2,y2 = self.table.getCellCoords(0,col)
        rect = self.create_rectangle(x1,y1-w,x2,self.height,
                                  fill=color,
                                  outline=outline,
                                  width=w,
                                  stipple=&#39;gray50&#39;,
                                  tag=tag)
        self.lower(tag)
        return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Canvas</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
<li>tkinter.XView</li>
<li>tkinter.YView</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tkintertable.Tables.ColumnHeader.drawRect"><code class="name flex">
<span>def <span class="ident">drawRect</span></span>(<span>self, col, tag=None, color=None, outline=None, delete=1)</span>
</code></dt>
<dd>
<section class="desc"><p>User has clicked to select a col</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def drawRect(self,col, tag=None, color=None, outline=None, delete=1):
    &#34;&#34;&#34;User has clicked to select a col&#34;&#34;&#34;

    if tag==None:
        tag=&#39;rect&#39;
    if color==None:
        color=&#39;#0099CC&#39;
    if outline==None:
        outline=&#39;gray25&#39;
    if delete == 1:
        self.delete(tag)
    w=2
    x1,y1,x2,y2 = self.table.getCellCoords(0,col)
    rect = self.create_rectangle(x1,y1-w,x2,self.height,
                              fill=color,
                              outline=outline,
                              width=w,
                              stipple=&#39;gray50&#39;,
                              tag=tag)
    self.lower(tag)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.ColumnHeader.draw_resize_symbol"><code class="name flex">
<span>def <span class="ident">draw_resize_symbol</span></span>(<span>self, col)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw a symbol to show that col can be resized when mouse here</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def draw_resize_symbol(self, col):
    &#34;&#34;&#34;Draw a symbol to show that col can be resized when mouse here&#34;&#34;&#34;

    self.delete(&#39;resizesymbol&#39;)
    w=self.table.cellwidth
    h=self.height
    wdth=1
    hfac1=0.2
    hfac2=0.4
    x_start=self.table.x_start
    x1,y1,x2,y2 = self.table.getCellCoords(0,col)

    self.create_polygon(x2-3,h/4, x2-10,h/2, x2-3,h*3/4, tag=&#39;resizesymbol&#39;,
        fill=&#39;white&#39;, outline=&#39;gray&#39;, width=wdth)
    self.create_polygon(x2+2,h/4, x2+10,h/2, x2+2,h*3/4, tag=&#39;resizesymbol&#39;,
        fill=&#39;white&#39;, outline=&#39;gray&#39;, width=wdth)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.ColumnHeader.handle_left_click"><code class="name flex">
<span>def <span class="ident">handle_left_click</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Does cell selection when mouse is clicked on canvas</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_left_click(self,event):
    &#34;&#34;&#34;Does cell selection when mouse is clicked on canvas&#34;&#34;&#34;

    self.delete(&#39;rect&#39;)
    self.table.delete(&#39;entry&#39;)
    self.table.delete(&#39;multicellrect&#39;)
    colclicked = self.table.get_col_clicked(event)
    if colclicked == None:
        return
    #set all rows selected
    self.table.allrows = True
    self.table.setSelectedCol(colclicked)

    if self.atdivider == 1:
        return
    self.drawRect(self.table.currentcol)
    #also draw a copy of the rect to be dragged
    self.draggedcol = None
    self.drawRect(self.table.currentcol, tag=&#39;dragrect&#39;,
                    color=&#39;red&#39;, outline=&#39;white&#39;)
    if hasattr(self, &#39;rightmenu&#39;):
        self.rightmenu.destroy()
    #finally, draw the selected col on the table
    self.table.drawSelectedCol()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.ColumnHeader.handle_left_release"><code class="name flex">
<span>def <span class="ident">handle_left_release</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>When mouse released implement resize or col move</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_left_release(self,event):
    &#34;&#34;&#34;When mouse released implement resize or col move&#34;&#34;&#34;

    self.delete(&#39;dragrect&#39;)
    if self.atdivider == 1:
        #col = self.table.get_col_clicked(event)
        x=int(self.canvasx(event.x))
        col = self.table.currentcol
        x1,y1,x2,y2 = self.table.getCellCoords(0,col)
        newwidth=x - x1
        if newwidth &lt; 5:
            newwidth=5
        self.table.resizeColumn(col, newwidth)
        self.table.delete(&#39;resizeline&#39;)
        self.delete(&#39;resizeline&#39;)
        self.delete(&#39;resizesymbol&#39;)
        self.atdivider = 0
        return
    self.delete(&#39;resizesymbol&#39;)
    #move column
    if self.draggedcol != None and self.table.currentcol != self.draggedcol:
        self.model.moveColumn(self.table.currentcol, self.draggedcol)
        self.table.setSelectedCol(self.draggedcol)
        self.table.redrawTable()
        self.table.drawSelectedCol(self.table.currentcol)
        self.drawRect(self.table.currentcol)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.ColumnHeader.handle_left_shift_click"><code class="name flex">
<span>def <span class="ident">handle_left_shift_click</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Handle shift click, for selecting multiple cols</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_left_shift_click(self, event):
    &#34;&#34;&#34;Handle shift click, for selecting multiple cols&#34;&#34;&#34;

    self.table.delete(&#39;colrect&#39;)
    self.delete(&#39;rect&#39;)
    currcol = self.table.currentcol
    colclicked = self.table.get_col_clicked(event)
    if colclicked &gt; currcol:
        self.table.multiplecollist = range(currcol, colclicked+1)
    elif colclicked &lt; currcol:
        self.table.multiplecollist = range(colclicked, currcol+1)
    else:
        return

    #print self.table.multiplecollist
    for c in self.table.multiplecollist:
        self.drawRect(c, delete=0)
        self.table.drawSelectedCol(c, delete=0)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.ColumnHeader.handle_mouse_drag"><code class="name flex">
<span>def <span class="ident">handle_mouse_drag</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Handle column drag, will be either to move cols or resize</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_mouse_drag(self, event):
    &#34;&#34;&#34;Handle column drag, will be either to move cols or resize&#34;&#34;&#34;

    x=int(self.canvasx(event.x))
    if self.atdivider == 1:
        self.table.delete(&#39;resizeline&#39;)
        self.delete(&#39;resizeline&#39;)
        self.table.create_line(x, 0, x, self.table.rowheight*self.table.rows,
                            width=2, fill=&#39;gray&#39;, tag=&#39;resizeline&#39;)
        self.create_line(x, 0, x, self.height,
                            width=2, fill=&#39;gray&#39;, tag=&#39;resizeline&#39;)
        return
    else:
        w = self.table.cellwidth
        self.draggedcol = self.table.get_col_clicked(event)
        x1, y1, x2, y2 = self.coords(&#39;dragrect&#39;)
        x=int(self.canvasx(event.x))
        y = self.canvasy(event.y)
        self.move(&#39;dragrect&#39;, x-x1-w/2, 0)

    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.ColumnHeader.handle_mouse_move"><code class="name flex">
<span>def <span class="ident">handle_mouse_move</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Handle mouse moved in header, if near divider draw resize symbol</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_mouse_move(self, event):
    &#34;&#34;&#34;Handle mouse moved in header, if near divider draw resize symbol&#34;&#34;&#34;

    self.delete(&#39;resizesymbol&#39;)
    w=self.table.cellwidth
    h=self.height
    x_start=self.table.x_start
    #x = event.x
    x=int(self.canvasx(event.x))
    if x &gt; self.tablewidth+w:
        return
    #if event x is within x pixels of divider, draw resize symbol
    if x!=x_start and self.within(x, self.table.col_positions, 4):
        col = self.table.get_col_clicked(event)
        if col == None:
            return
        self.draw_resize_symbol(col)
        self.atdivider = 1
    else:
        self.atdivider = 0
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.ColumnHeader.handle_right_click"><code class="name flex">
<span>def <span class="ident">handle_right_click</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>respond to a right click</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_right_click(self, event):
    &#34;&#34;&#34;respond to a right click&#34;&#34;&#34;

    self.handle_left_click(event)
    if self.table.read_only == False:
        self.rightmenu = self.popupMenu(event)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.ColumnHeader.handle_right_release"><code class="name flex">
<span>def <span class="ident">handle_right_release</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_right_release(self, event):
    self.rightmenu.destroy()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.ColumnHeader.popupMenu"><code class="name flex">
<span>def <span class="ident">popupMenu</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Add left and right click behaviour for column header</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def popupMenu(self, event):
    &#34;&#34;&#34;Add left and right click behaviour for column header&#34;&#34;&#34;

    colname = self.model.columnNames[self.table.currentcol]
    collabel = self.model.columnlabels[colname]
    currcol = self.table.currentcol
    popupmenu = Menu(self, tearoff = 0)
    def popupFocusOut(event):
        popupmenu.unpost()
    popupmenu.add_command(label=&#34;Rename Column&#34;, command=self.relabel_Column)
    popupmenu.add_command(label=&#34;Sort by &#34;+ collabel, command=lambda : self.table.sortTable(currcol))
    popupmenu.add_command(label=&#34;Sort by &#34;+ collabel +&#39; (descending)&#39;, command=lambda : self.table.sortTable(currcol,reverse=1))
    popupmenu.add_command(label=&#34;Delete This Column&#34;, command=self.table.deleteColumn)
    popupmenu.add_command(label=&#34;Add New Column&#34;, command=self.table.addColumn)

    popupmenu.bind(&#34;&lt;FocusOut&gt;&#34;, popupFocusOut)
    #self.bind(&#34;&lt;Button-3&gt;&#34;, popupFocusOut)
    popupmenu.focus_set()
    popupmenu.post(event.x_root, event.y_root)
    return popupmenu</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.ColumnHeader.redraw"><code class="name flex">
<span>def <span class="ident">redraw</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def redraw(self):

    cols = self.model.getColumnCount()
    self.tablewidth=self.table.tablewidth
    self.configure(scrollregion=(0,0, self.table.tablewidth+self.table.x_start, self.height))
    self.delete(&#39;gridline&#39;,&#39;text&#39;)
    self.delete(&#39;rect&#39;)
    self.atdivider = None
    align=&#39;w&#39;
    pad=4
    h=self.height
    #x_start=self.table.x_start

    if cols == 0:
        return
    for col in self.table.visiblecols:
        colname = self.model.columnNames[col]
        if not colname in self.model.columnlabels:
            self.model.columnlabels[colname]=colname
        collabel = self.model.columnlabels[colname]
        if colname in self.model.columnwidths:
            w = self.model.columnwidths[colname]
        else:
            w = self.table.cellwidth
        x = self.table.col_positions[col]

        if len(collabel)&gt;w/10:
            collabel = collabel[0:int(w/12)]+&#39;.&#39;
        line = self.create_line(x, 0, x, h, tag=(&#39;gridline&#39;, &#39;vertline&#39;),
                             fill=&#39;white&#39;, width=2)

        self.create_text(x+pad,h/2,
                        text=collabel,
                        anchor=align,
                        fill=&#39;white&#39;,
                        font=self.thefont,
                        tag=&#39;text&#39;)


    x=self.table.col_positions[col+1]
    self.create_line(x,0, x,h, tag=&#39;gridline&#39;,
                    fill=&#39;white&#39;, width=2)

    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.ColumnHeader.relabel_Column"><code class="name flex">
<span>def <span class="ident">relabel_Column</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def relabel_Column(self):
    col=self.table.currentcol
    ans = simpledialog.askstring(&#34;New column name?&#34;, &#34;Enter new name:&#34;)
    if ans !=None:
        if ans == &#39;&#39;:
            messagebox.showwarning(&#34;Error&#34;, &#34;Name should not be blank.&#34;)
            return
        else:
            self.model.relabel_Column(col, ans)
            self.redraw()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.ColumnHeader.within"><code class="name flex">
<span>def <span class="ident">within</span></span>(<span>self, val, l, d)</span>
</code></dt>
<dd>
<section class="desc"><p>Utility funtion to see if val is within d of any
items in the list l</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def within(self, val, l, d):
    &#34;&#34;&#34;Utility funtion to see if val is within d of any
        items in the list l&#34;&#34;&#34;
    for v in l:
        if abs(val-v) &lt;= d:
            return 1
    return 0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tkintertable.Tables.RowHeader"><code class="flex name class">
<span>class <span class="ident">RowHeader</span></span>
<span>(</span><span>parent=None, table=None, width=40)</span>
</code></dt>
<dd>
<section class="desc"><p>Class that displays the row headings on the table
takes it's size and rendering from the parent table
This also handles row/record selection as opposed to cell
selection</p>
<p>Construct a canvas widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, closeenough,
confine, cursor, height, highlightbackground, highlightcolor,
highlightthickness, insertbackground, insertborderwidth,
insertofftime, insertontime, insertwidth, offset, relief,
scrollregion, selectbackground, selectborderwidth, selectforeground,
state, takefocus, width, xscrollcommand, xscrollincrement,
yscrollcommand, yscrollincrement.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class RowHeader(Canvas):
    &#34;&#34;&#34;Class that displays the row headings on the table
       takes it&#39;s size and rendering from the parent table
       This also handles row/record selection as opposed to cell
       selection&#34;&#34;&#34;

    def __init__(self, parent=None, table=None, width=40):
        Canvas.__init__(self, parent, bg=&#39;gray75&#39;, width=width, height=None)

        if table != None:
            self.table = table
            self.width = width
            self.x_start = 0
            self.inset = 1
            self.config(height = self.table.height)
            self.startrow = self.endrow = None
            self.model = self.table.getModel()
            self.bind(&#39;&lt;Button-1&gt;&#39;,self.handle_left_click)
            self.bind(&#34;&lt;ButtonRelease-1&gt;&#34;, self.handle_left_release)
            self.bind(&#34;&lt;Control-Button-1&gt;&#34;, self.handle_left_ctrl_click)
            self.bind(&#39;&lt;Button-3&gt;&#39;,self.handle_right_click)
            self.bind(&#39;&lt;B1-Motion&gt;&#39;, self.handle_mouse_drag)
            #self.bind(&#39;&lt;Shift-Button-1&gt;&#39;, self.handle_left_shift_click)
        return

    def redraw(self, align=&#39;w&#39;, showkeys=False):
        &#34;&#34;&#34;Redraw row header&#34;&#34;&#34;

        self.height = self.table.rowheight * self.table.rows+10
        self.configure(scrollregion=(0,0, self.width, self.height))
        self.delete(&#39;rowheader&#39;,&#39;text&#39;)
        self.delete(&#39;rect&#39;)
        w = float(self.width)
        h = self.table.rowheight
        x = self.x_start+w/2
        if align == &#39;w&#39;:
            x = x-w/2+3
        elif align == &#39;e&#39;:
            x = x+w/2-3
        for row in self.table.visiblerows:
            if showkeys == True:
                text = self.model.getRecName(row)
            else:
                text = row+1
            x1,y1,x2,y2 = self.table.getCellCoords(row,0)
            self.create_rectangle(0,y1,w-1,y2,
                                      fill=&#39;gray75&#39;,
                                      outline=&#39;white&#39;,
                                      width=1,
                                      tag=&#39;rowheader&#39;)
            self.create_text(x,y1+h/2,
                                      text=text,
                                      fill=&#39;black&#39;,
                                      font=self.table.thefont,
                                      tag=&#39;text&#39;, anchor=align)
        return

    def setWidth(self, w):
        &#34;&#34;&#34;Set width&#34;&#34;&#34;
        self.width = w
        self.redraw()
        return

    def clearSelected(self):
        self.delete(&#39;rect&#39;)
        return

    def handle_left_click(self, event):
        rowclicked = self.table.get_row_clicked(event)
        self.startrow = rowclicked
        if 0 &lt;= rowclicked &lt; self.table.rows:
            self.delete(&#39;rect&#39;)
            self.table.delete(&#39;entry&#39;)
            self.table.delete(&#39;multicellrect&#39;)
            #set row selected
            self.table.setSelectedRow(rowclicked)
            self.table.drawSelectedRow()
            self.drawSelectedRows(self.table.currentrow)
        return

    def handle_left_release(self,event):

        return

    def handle_left_ctrl_click(self, event):
        &#34;&#34;&#34;Handle ctrl clicks - for multiple row selections&#34;&#34;&#34;

        rowclicked = self.table.get_row_clicked(event)
        multirowlist = self.table.multiplerowlist
        if 0 &lt;= rowclicked &lt; self.table.rows:
            if rowclicked not in multirowlist:
                multirowlist.append(rowclicked)
            else:
                multirowlist.remove(rowclicked)
            self.table.drawMultipleRows(multirowlist)
            self.drawSelectedRows(multirowlist)
        return

    def handle_right_click(self,event):

        return

    &#39;&#39;&#39;def handle_mouse_drag(self, event):
        &#34;&#34;&#34;Handle mouse drag for mult row selection&#34;&#34;&#34;
        rowover = self.table.get_row_clicked(event)
        colover = self.table.get_col_clicked(event)
        if colover == None or rowover == None:
            return&#39;&#39;&#39;

    def handle_mouse_drag(self, event):
        &#34;&#34;&#34;Handle mouse moved with button held down, multiple selections&#34;&#34;&#34;

        if hasattr(self, &#39;cellentry&#39;):
            self.cellentry.destroy()
        rowover = self.table.get_row_clicked(event)
        colover = self.table.get_col_clicked(event)
        if rowover == None:
            return
        if rowover &gt;= self.table.rows or self.startrow &gt; self.table.rows:
            return
        else:
            self.endrow = rowover
        #draw the selected rows
        if self.endrow != self.startrow:
            if self.endrow &lt; self.startrow:
                rowlist=range(self.endrow, self.startrow+1)
            else:
                rowlist=range(self.startrow, self.endrow+1)
            self.drawSelectedRows(rowlist)
            self.table.multiplerowlist = rowlist
            self.table.drawMultipleRows(rowlist)
        else:
            self.table.multiplerowlist = []
            self.table.multiplerowlist.append(rowover)
            self.drawSelectedRows(rowover)
            self.table.drawMultipleRows(self.table.multiplerowlist)
        return

    def drawSelectedRows(self, rows=None):
        &#34;&#34;&#34;Draw selected rows, accepts a list or integer&#34;&#34;&#34;

        self.delete(&#39;rect&#39;)
        if type(rows) is not list:
            rowlist=[]
            rowlist.append(rows)
        else:
           rowlist = rows
        for r in rowlist:
            if r not in self.table.visiblerows:
                continue
            self.drawRect(r, delete=0)
        return

    def drawRect(self, row=None, tag=None, color=None, outline=None, delete=1):
        &#34;&#34;&#34;Draw a rect representing row selection&#34;&#34;&#34;

        if tag==None:
            tag=&#39;rect&#39;
        if color==None:
            color=&#39;#0099CC&#39;
        if outline==None:
            outline=&#39;gray25&#39;
        if delete == 1:
            self.delete(tag)
        w=0
        i = self.inset
        x1,y1,x2,y2 = self.table.getCellCoords(row, 0)
        rect = self.create_rectangle(0+i,y1+i,self.width-i,y2,
                                      fill=color,
                                      outline=outline,
                                      width=w,
                                      tag=tag)
        self.lift(&#39;text&#39;)
        return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Canvas</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
<li>tkinter.XView</li>
<li>tkinter.YView</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tkintertable.Tables.RowHeader.clearSelected"><code class="name flex">
<span>def <span class="ident">clearSelected</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def clearSelected(self):
    self.delete(&#39;rect&#39;)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.RowHeader.drawRect"><code class="name flex">
<span>def <span class="ident">drawRect</span></span>(<span>self, row=None, tag=None, color=None, outline=None, delete=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw a rect representing row selection</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def drawRect(self, row=None, tag=None, color=None, outline=None, delete=1):
    &#34;&#34;&#34;Draw a rect representing row selection&#34;&#34;&#34;

    if tag==None:
        tag=&#39;rect&#39;
    if color==None:
        color=&#39;#0099CC&#39;
    if outline==None:
        outline=&#39;gray25&#39;
    if delete == 1:
        self.delete(tag)
    w=0
    i = self.inset
    x1,y1,x2,y2 = self.table.getCellCoords(row, 0)
    rect = self.create_rectangle(0+i,y1+i,self.width-i,y2,
                                  fill=color,
                                  outline=outline,
                                  width=w,
                                  tag=tag)
    self.lift(&#39;text&#39;)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.RowHeader.drawSelectedRows"><code class="name flex">
<span>def <span class="ident">drawSelectedRows</span></span>(<span>self, rows=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw selected rows, accepts a list or integer</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def drawSelectedRows(self, rows=None):
    &#34;&#34;&#34;Draw selected rows, accepts a list or integer&#34;&#34;&#34;

    self.delete(&#39;rect&#39;)
    if type(rows) is not list:
        rowlist=[]
        rowlist.append(rows)
    else:
       rowlist = rows
    for r in rowlist:
        if r not in self.table.visiblerows:
            continue
        self.drawRect(r, delete=0)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.RowHeader.handle_left_click"><code class="name flex">
<span>def <span class="ident">handle_left_click</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_left_click(self, event):
    rowclicked = self.table.get_row_clicked(event)
    self.startrow = rowclicked
    if 0 &lt;= rowclicked &lt; self.table.rows:
        self.delete(&#39;rect&#39;)
        self.table.delete(&#39;entry&#39;)
        self.table.delete(&#39;multicellrect&#39;)
        #set row selected
        self.table.setSelectedRow(rowclicked)
        self.table.drawSelectedRow()
        self.drawSelectedRows(self.table.currentrow)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.RowHeader.handle_left_ctrl_click"><code class="name flex">
<span>def <span class="ident">handle_left_ctrl_click</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Handle ctrl clicks - for multiple row selections</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_left_ctrl_click(self, event):
    &#34;&#34;&#34;Handle ctrl clicks - for multiple row selections&#34;&#34;&#34;

    rowclicked = self.table.get_row_clicked(event)
    multirowlist = self.table.multiplerowlist
    if 0 &lt;= rowclicked &lt; self.table.rows:
        if rowclicked not in multirowlist:
            multirowlist.append(rowclicked)
        else:
            multirowlist.remove(rowclicked)
        self.table.drawMultipleRows(multirowlist)
        self.drawSelectedRows(multirowlist)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.RowHeader.handle_left_release"><code class="name flex">
<span>def <span class="ident">handle_left_release</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_left_release(self,event):

    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.RowHeader.handle_mouse_drag"><code class="name flex">
<span>def <span class="ident">handle_mouse_drag</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Handle mouse moved with button held down, multiple selections</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_mouse_drag(self, event):
    &#34;&#34;&#34;Handle mouse moved with button held down, multiple selections&#34;&#34;&#34;

    if hasattr(self, &#39;cellentry&#39;):
        self.cellentry.destroy()
    rowover = self.table.get_row_clicked(event)
    colover = self.table.get_col_clicked(event)
    if rowover == None:
        return
    if rowover &gt;= self.table.rows or self.startrow &gt; self.table.rows:
        return
    else:
        self.endrow = rowover
    #draw the selected rows
    if self.endrow != self.startrow:
        if self.endrow &lt; self.startrow:
            rowlist=range(self.endrow, self.startrow+1)
        else:
            rowlist=range(self.startrow, self.endrow+1)
        self.drawSelectedRows(rowlist)
        self.table.multiplerowlist = rowlist
        self.table.drawMultipleRows(rowlist)
    else:
        self.table.multiplerowlist = []
        self.table.multiplerowlist.append(rowover)
        self.drawSelectedRows(rowover)
        self.table.drawMultipleRows(self.table.multiplerowlist)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.RowHeader.handle_right_click"><code class="name flex">
<span>def <span class="ident">handle_right_click</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_right_click(self,event):

    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.RowHeader.redraw"><code class="name flex">
<span>def <span class="ident">redraw</span></span>(<span>self, align='w', showkeys=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Redraw row header</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def redraw(self, align=&#39;w&#39;, showkeys=False):
    &#34;&#34;&#34;Redraw row header&#34;&#34;&#34;

    self.height = self.table.rowheight * self.table.rows+10
    self.configure(scrollregion=(0,0, self.width, self.height))
    self.delete(&#39;rowheader&#39;,&#39;text&#39;)
    self.delete(&#39;rect&#39;)
    w = float(self.width)
    h = self.table.rowheight
    x = self.x_start+w/2
    if align == &#39;w&#39;:
        x = x-w/2+3
    elif align == &#39;e&#39;:
        x = x+w/2-3
    for row in self.table.visiblerows:
        if showkeys == True:
            text = self.model.getRecName(row)
        else:
            text = row+1
        x1,y1,x2,y2 = self.table.getCellCoords(row,0)
        self.create_rectangle(0,y1,w-1,y2,
                                  fill=&#39;gray75&#39;,
                                  outline=&#39;white&#39;,
                                  width=1,
                                  tag=&#39;rowheader&#39;)
        self.create_text(x,y1+h/2,
                                  text=text,
                                  fill=&#39;black&#39;,
                                  font=self.table.thefont,
                                  tag=&#39;text&#39;, anchor=align)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.RowHeader.setWidth"><code class="name flex">
<span>def <span class="ident">setWidth</span></span>(<span>self, w)</span>
</code></dt>
<dd>
<section class="desc"><p>Set width</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setWidth(self, w):
    &#34;&#34;&#34;Set width&#34;&#34;&#34;
    self.width = w
    self.redraw()
    return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tkintertable.Tables.TableCanvas"><code class="flex name class">
<span>class <span class="ident">TableCanvas</span></span>
<span>(</span><span>parent=None, model=None, data=None, read_only=False, width=None, height=None, rows=10, cols=5, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A tkinter class for providing table functionality</p>
<p>Construct a canvas widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, closeenough,
confine, cursor, height, highlightbackground, highlightcolor,
highlightthickness, insertbackground, insertborderwidth,
insertofftime, insertontime, insertwidth, offset, relief,
scrollregion, selectbackground, selectborderwidth, selectforeground,
state, takefocus, width, xscrollcommand, xscrollincrement,
yscrollcommand, yscrollincrement.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TableCanvas(Canvas):
    &#34;&#34;&#34;A tkinter class for providing table functionality&#34;&#34;&#34;

    def __init__(self, parent=None, model=None, data=None, read_only=False,
                 width=None, height=None,
                 rows=10, cols=5, **kwargs):
        Canvas.__init__(self, parent, bg=&#39;white&#39;,
                         width=width, height=height,
                         relief=GROOVE,
                         scrollregion=(0,0,300,200))
        self.parentframe = parent
        #get platform into a variable
        self.ostyp = self.checkOSType()
        self.platform = platform.system()
        self.width = width
        self.height = height
        self.set_defaults()

        self.currentpage = None
        self.navFrame = None
        self.currentrow = 0
        self.currentcol = 0
        self.reverseorder = 0
        self.startrow = self.endrow = None
        self.startcol = self.endcol = None
        self.allrows = False       #for selected all rows without setting multiplerowlist
        self.multiplerowlist=[]
        self.multiplecollist=[]
        self.col_positions=[]       #record current column grid positions
        self.mode = &#39;normal&#39;
        self.read_only = read_only
        self.filtered = False

        self.loadPrefs()
        #set any options passed in kwargs to overwrite defaults and prefs
        for key in kwargs:
            self.__dict__[key] = kwargs[key]

        if data is not None:
            self.model = TableModel()
            self.model.importDict(data)
        elif model is not None:
            self.model = model
        else:
            self.model = TableModel(rows=rows,columns=cols)

        self.rows = self.model.getRowCount()
        self.cols = self.model.getColumnCount()
        self.tablewidth = (self.cellwidth)*self.cols
        self.do_bindings()
        #initial sort order
        self.model.setSortOrder()

        #column specific actions, define for every column type in the model
        #when you add a column type you should edit this dict
        self.columnactions = {&#39;text&#39; : {&#34;Edit&#34;:  &#39;drawCellEntry&#39; },
                              &#39;number&#39; : {&#34;Edit&#34;: &#39;drawCellEntry&#39; }}
        self.setFontSize()
        return

    def set_defaults(self):
        &#34;&#34;&#34;Set default settings&#34;&#34;&#34;

        self.cellwidth=150
        self.maxcellwidth=200
        self.rowheight=20
        self.horizlines=1
        self.vertlines=1
        self.alternaterows=0
        self.autoresizecols = 0
        self.inset=2
        self.x_start=0
        self.y_start=1
        self.linewidth=1.0
        self.rowheaderwidth=40
        self.showkeynamesinheader=False
        self.thefont = (&#39;Arial&#39;,12)
        self.cellbackgr = &#39;#F7F7FA&#39;
        self.entrybackgr = &#39;white&#39;
        self.grid_color = &#39;#ABB1AD&#39;
        self.selectedcolor = &#39;yellow&#39;
        self.rowselectedcolor = &#39;#CCCCFF&#39;
        self.multipleselectioncolor = &#39;#ECD672&#39;
        return

    def setFontSize(self):
        &#34;&#34;&#34;Set font size to match font, we need to get rid of fontsize as
            a separate variable?&#34;&#34;&#34;

        if hasattr(self, &#39;thefont&#39;) and type(self.thefont) is tuple:
            self.fontsize = self.thefont[1]
        return

    def mouse_wheel(self, event):
        &#34;&#34;&#34;Handle mouse wheel scroll for windows&#34;&#34;&#34;

        if event.num == 5 or event.delta == -120:
            event.widget.yview_scroll(1, UNITS)
            self.tablerowheader.yview_scroll(1, UNITS)
        if event.num == 4 or event.delta == 120:
            if self.canvasy(0) &lt; 0:
                return
            event.widget.yview_scroll(-1, UNITS)
            self.tablerowheader.yview_scroll(-1, UNITS)
        self.redrawVisible()
        return

    def do_bindings(self):
        &#34;&#34;&#34;Bind keys and mouse clicks, this can be overriden&#34;&#34;&#34;
        self.bind(&#34;&lt;Button-1&gt;&#34;,self.handle_left_click)
        self.bind(&#34;&lt;Double-Button-1&gt;&#34;,self.handle_double_click)
        self.bind(&#34;&lt;Control-Button-1&gt;&#34;, self.handle_left_ctrl_click)
        self.bind(&#34;&lt;Shift-Button-1&gt;&#34;, self.handle_left_shift_click)

        self.bind(&#34;&lt;ButtonRelease-1&gt;&#34;, self.handle_left_release)
        if self.ostyp==&#39;mac&#39;:
            #For mac we bind Shift, left-click to right click
            self.bind(&#34;&lt;Button-2&gt;&#34;, self.handle_right_click)
            self.bind(&#39;&lt;Shift-Button-1&gt;&#39;,self.handle_right_click)
        else:
            self.bind(&#34;&lt;Button-3&gt;&#34;, self.handle_right_click)

        self.bind(&#39;&lt;B1-Motion&gt;&#39;, self.handle_mouse_drag)
        self.bind(&#39;&lt;Motion&gt;&#39;, self.handle_motion)

        self.bind_all(&#34;&lt;Control-x&gt;&#34;, self.deleteRow)
        self.bind_all(&#34;&lt;Control-n&gt;&#34;, self.addRow)
        self.bind_all(&#34;&lt;Delete&gt;&#34;, self.clearData)
        self.bind_all(&#34;&lt;Control-v&gt;&#34;, self.paste)

        #if not hasattr(self,&#39;parentapp&#39;):
        #    self.parentapp = self.parentframe

        self.parentframe.master.bind_all(&#34;&lt;Right&gt;&#34;, self.handle_arrow_keys)
        self.parentframe.master.bind_all(&#34;&lt;Left&gt;&#34;, self.handle_arrow_keys)
        self.parentframe.master.bind_all(&#34;&lt;Up&gt;&#34;, self.handle_arrow_keys)
        self.parentframe.master.bind_all(&#34;&lt;Down&gt;&#34;, self.handle_arrow_keys)
        self.parentframe.master.bind_all(&#34;&lt;KP_8&gt;&#34;, self.handle_arrow_keys)
        self.parentframe.master.bind_all(&#34;&lt;Return&gt;&#34;, self.handle_arrow_keys)
        self.parentframe.master.bind_all(&#34;&lt;Tab&gt;&#34;, self.handle_arrow_keys)
        #if &#39;windows&#39; in self.platform:
        self.bind(&#34;&lt;MouseWheel&gt;&#34;, self.mouse_wheel)
        self.bind(&#39;&lt;Button-4&gt;&#39;, self.mouse_wheel)
        self.bind(&#39;&lt;Button-5&gt;&#39;, self.mouse_wheel)
        self.focus_set()
        return

    def getModel(self):
        &#34;&#34;&#34;Get the current table model&#34;&#34;&#34;
        return self.model

    def setModel(self, model):
        &#34;&#34;&#34;Set a new model - requires redraw to reflect changes&#34;&#34;&#34;
        self.model = model
        return

    def createfromDict(self, data):
        &#34;&#34;&#34;Attempt to create a new model/table from a dict&#34;&#34;&#34;

        try:
            namefield=self.namefield
        except:
            namefield=data.keys()[0]
        self.model = TableModel()
        self.model.importDict(data, namefield=namefield)
        self.model.setSortOrder(0,reverse=self.reverseorder)
        return

    def createTableFrame(self, callback=None):
        self.show(callback)
        return

    def show(self, callback=None):
        &#34;&#34;&#34;Adds column header and scrollbars and combines them with
           the current table adding all to the master frame provided in constructor.
           Table is then redrawn.&#34;&#34;&#34;

        #Add the table and header to the frame
        self.tablerowheader = RowHeader(self.parentframe, self, width=self.rowheaderwidth)
        self.tablecolheader = ColumnHeader(self.parentframe, self)
        self.Yscrollbar = AutoScrollbar(self.parentframe,orient=VERTICAL,command=self.set_yviews)
        self.Yscrollbar.grid(row=1,column=2,rowspan=1,sticky=&#39;news&#39;,pady=0,ipady=0)
        self.Xscrollbar = AutoScrollbar(self.parentframe,orient=HORIZONTAL,command=self.set_xviews)
        self.Xscrollbar.grid(row=2,column=1,columnspan=1,sticky=&#39;news&#39;)
        self[&#39;xscrollcommand&#39;] = self.Xscrollbar.set
        self[&#39;yscrollcommand&#39;] = self.Yscrollbar.set
        self.tablecolheader[&#39;xscrollcommand&#39;] = self.Xscrollbar.set
        self.tablerowheader[&#39;yscrollcommand&#39;] = self.Yscrollbar.set
        self.parentframe.rowconfigure(1,weight=1)
        self.parentframe.columnconfigure(1,weight=1)

        self.tablecolheader.grid(row=0,column=1,rowspan=1,sticky=&#39;news&#39;,pady=0,ipady=0)
        self.tablerowheader.grid(row=1,column=0,rowspan=1,sticky=&#39;news&#39;,pady=0,ipady=0)
        self.grid(row=1,column=1,rowspan=1,sticky=&#39;news&#39;,pady=0,ipady=0)

        self.adjustColumnWidths()
        self.redrawTable(callback=callback)
        self.parentframe.bind(&#34;&lt;Configure&gt;&#34;, self.redrawVisible)
        self.tablecolheader.xview(&#34;moveto&#34;, 0)
        self.xview(&#34;moveto&#34;, 0)
        return

    def getVisibleRegion(self):
        &#34;&#34;&#34;Get visible region of table to display&#34;&#34;&#34;

        x1, y1 = self.canvasx(0), self.canvasy(0)
        #w, h = self.winfo_width(), self.winfo_height()
        w,h= self.master.winfo_width(), self.master.winfo_height()
        if w &lt;= 1.0 or h &lt;= 1.0:
            w, h = self.master.winfo_width(), self.master.winfo_height()
        x2, y2 = self.canvasx(w), self.canvasy(h)
        return x1, y1, x2, y2

    def getRowPosition(self, y):
        &#34;&#34;&#34;Get current row from canvas position&#34;&#34;&#34;

        h = self.rowheight
        y_start = self.y_start
        row = (int(y)-y_start)/h
        if row &lt; 0:
            return 0
        if row &gt; self.rows:
            row = self.rows
        return row

    def getColPosition(self, x):
        &#34;&#34;&#34;Get current col from canvas position&#34;&#34;&#34;

        x_start = self.x_start
        w = self.cellwidth
        i=0
        col=0
        for c in self.col_positions:
            col = i
            if c+w&gt;=x:
                break
            i+=1
        return col

    def getVisibleRows(self, y1, y2):
        &#34;&#34;&#34;Get the visible row range&#34;&#34;&#34;

        start = int(self.getRowPosition(y1))
        end = int(self.getRowPosition(y2))+1
        if end &gt; self.rows:
            end = self.rows
        return start, end

    def getVisibleCols(self, x1, x2):
        &#34;&#34;&#34;Get the visible column range&#34;&#34;&#34;

        start = self.getColPosition(x1)
        end = self.getColPosition(x2)+1
        if end &gt; self.cols:
            end = self.cols
        return start, end

    def redrawVisible(self, event=None, callback=None):
        &#34;&#34;&#34;Redraw the visible portion of the canvas&#34;&#34;&#34;

        model = self.model
        self.rows = self.model.getRowCount()
        self.cols = self.model.getColumnCount()

        self.tablewidth = (self.cellwidth) * self.cols
        self.configure(bg=self.cellbackgr)
        self.setColPositions()

        #are we drawing a filtered subset of the recs?
        if self.filtered == True and self.model.filteredrecs != None:
            self.rows = len(self.model.filteredrecs)
            self.delete(&#39;colrect&#39;)

        self.rowrange = range(0,self.rows)
        self.configure(scrollregion=(0,0, self.tablewidth+self.x_start,
                self.rowheight*self.rows+10))

        x1, y1, x2, y2 = self.getVisibleRegion()
        startvisiblerow, endvisiblerow = self.getVisibleRows(y1, y2)
        self.visiblerows = range(startvisiblerow, endvisiblerow)
        startvisiblecol, endvisiblecol = self.getVisibleCols(x1, x2)
        self.visiblecols = range(startvisiblecol, endvisiblecol)

        if self.cols == 0 or self.rows == 0:
            self.delete(&#39;entry&#39;)
            self.delete(&#39;rowrect&#39;)
            self.delete(&#39;currentrect&#39;)
            self.delete(&#39;gridline&#39;,&#39;text&#39;)
            self.tablerowheader.redraw()
            return

        self.drawGrid(startvisiblerow, endvisiblerow)
        align = self.align
        self.delete(&#39;fillrect&#39;)
        for row in self.visiblerows:
            if callback != None:
                callback()
            for col in self.visiblecols:
                colname = model.getColumnName(col)
                bgcolor = model.getColorAt(row,col, &#39;bg&#39;)
                fgcolor = model.getColorAt(row,col, &#39;fg&#39;)
                text = model.getValueAt(row,col)
                self.drawText(row, col, text, fgcolor, align)
                if bgcolor != None:
                    self.drawRect(row,col, color=bgcolor)

        #self.drawSelectedCol()
        self.tablecolheader.redraw()
        self.tablerowheader.redraw(align=self.align, showkeys=self.showkeynamesinheader)
        #self.setSelectedRow(self.currentrow)
        self.drawSelectedRow()
        self.drawSelectedRect(self.currentrow, self.currentcol)
        #print self.multiplerowlist

        if len(self.multiplerowlist)&gt;1:
            self.tablerowheader.drawSelectedRows(self.multiplerowlist)
            self.drawMultipleRows(self.multiplerowlist)
            self.drawMultipleCells()
        return

    def redrawTable(self, event=None, callback=None):
        self.redrawVisible(event, callback)
        return

    def redraw(self, event=None, callback=None):
        self.redrawVisible(event, callback)
        return

    def redrawCell(self, row=None, col=None, recname=None, colname=None):
        &#34;&#34;&#34;Redraw a specific cell only&#34;&#34;&#34;

        if row == None and recname != None:
            row = self.model.getRecordIndex(recname)
        if col == None and colname != None:
            col = self.model.getColumnIndex(colname)
        bgcolor = self.model.getColorAt(row,col, &#39;bg&#39;)
        fgcolor = self.model.getColorAt(row,col, &#39;fg&#39;)
        text = self.model.getValueAt(row,col)
        self.drawText(row, col, text, fgcolor)
        if bgcolor != None:
            self.drawRect(row,col, color=bgcolor)
        return

    def adjustColumnWidths(self):
        &#34;&#34;&#34;Optimally adjust col widths to accomodate the longest entry
            in each column - usually only called  on first redraw&#34;&#34;&#34;

        #self.cols = self.model.getColumnCount()
        try:
            fontsize = self.thefont[1]
        except:
            fontsize = self.fontsize
        scale = 8.5 * float(fontsize)/12
        for col in range(self.cols):
            colname = self.model.getColumnName(col)
            if colname in self.model.columnwidths:
                w = self.model.columnwidths[colname]
            else:
                w = self.cellwidth
            maxlen = self.model.getlongestEntry(col)
            size = maxlen * scale
            if size &lt; w:
                continue
            #print col, size, self.cellwidth
            if size &gt;= self.maxcellwidth:
                size = self.maxcellwidth
            self.model.columnwidths[colname] = size + float(fontsize)/12*6
        return

    def autoResizeColumns(self):
        &#34;&#34;&#34;Automatically set nice column widths and draw&#34;&#34;&#34;

        self.adjustColumnWidths()
        self.redrawTable()
        return

    def setColPositions(self):
        &#34;&#34;&#34;Determine current column grid positions&#34;&#34;&#34;

        self.col_positions=[]
        w=self.cellwidth
        x_pos=self.x_start
        self.col_positions.append(x_pos)
        for col in range(self.cols):
            colname=self.model.getColumnName(col)
            if colname in self.model.columnwidths:
                x_pos=x_pos+self.model.columnwidths[colname]
            else:
                x_pos=x_pos+w
            self.col_positions.append(x_pos)
        self.tablewidth = self.col_positions[len(self.col_positions)-1]
        return

    def sortTable(self, columnIndex=0, columnName=None, reverse=0):
        &#34;&#34;&#34;Set up sort order dict based on currently selected field&#34;&#34;&#34;

        self.model.setSortOrder(columnIndex, columnName, reverse)
        self.redrawTable()
        return

    def set_xviews(self,*args):
        &#34;&#34;&#34;Set the xview of table and col header&#34;&#34;&#34;

        self.xview(*args)
        self.tablecolheader.xview(*args)
        self.redrawVisible()
        return

    def set_yviews(self,*args):
        &#34;&#34;&#34;Set the xview of table and row header&#34;&#34;&#34;

        self.yview(*args)
        self.tablerowheader.yview(*args)
        self.redrawVisible()
        return

    def addRow(self, key=None, **kwargs):
        &#34;&#34;&#34;Add new row&#34;&#34;&#34;

        key = self.model.addRow(key, **kwargs)
        self.redrawTable()
        self.setSelectedRow(self.model.getRecordIndex(key))
        return

    def addRows(self, num=None):
        &#34;&#34;&#34;Add new rows&#34;&#34;&#34;

        if num == None:
            num = simpledialog.askinteger(&#34;Now many rows?&#34;,
                                            &#34;Number of rows:&#34;,initialvalue=1,
                                             parent=self.parentframe)
        if not num:
            return
        keys = self.model.autoAddRows(num)
        self.redrawTable()
        self.setSelectedRow(self.model.getRecordIndex(keys[0]))
        return

    def addColumn(self, newname=None):
        &#34;&#34;&#34;Add a new column&#34;&#34;&#34;

        if newname == None:

            coltypes = self.getModel().getDefaultTypes()
            d = MultipleValDialog(title=&#39;New Column&#39;,
                                    initialvalues=(coltypes, &#39;&#39;),
                                    labels=(&#39;Column Type&#39;,&#39;Name&#39;),
                                    types=(&#39;list&#39;,&#39;string&#39;),
                                    parent=self.parentframe)
            if d.result == None:
                return
            else:
                coltype = d.results[0]
                newname = d.results[1]

        if newname != None:
            if newname in self.getModel().columnNames:
                messagebox.showwarning(&#34;Name exists&#34;,
                                         &#34;Name already exists!&#34;,
                                         parent=self.parentframe)
            else:
                self.model.addColumn(newname)
                self.parentframe.configure(width=self.width)
                self.redrawTable()
        return

    def deleteRow(self):
        &#34;&#34;&#34;Delete a row&#34;&#34;&#34;

        if len(self.multiplerowlist)&gt;1:
            n = messagebox.askyesno(&#34;Delete&#34;,
                                      &#34;Delete Selected Records?&#34;,
                                      parent=self.parentframe)
            if n == True:
                rows = self.multiplerowlist
                self.model.deleteRows(rows)
                self.clearSelected()
                self.setSelectedRow(0)
                self.redrawTable()
        else:
            n = messagebox.askyesno(&#34;Delete&#34;,
                                      &#34;Delete This Record?&#34;,
                                      parent=self.parentframe)
            if n:
                row = self.getSelectedRow()
                self.model.deleteRow(row)
                self.setSelectedRow(row-1)
                self.clearSelected()
                self.redrawTable()
        return

    def deleteColumn(self):
        &#34;&#34;&#34;Delete currently selected column&#34;&#34;&#34;

        n =  messagebox.askyesno(&#34;Delete&#34;,
                                   &#34;Delete This Column?&#34;,
                                   parent=self.parentframe)
        if n:
            col = self.getSelectedColumn()
            self.model.deleteColumn(col)
            self.currentcol = self.currentcol - 1
            self.redrawTable()
        return

    def deleteCells(self, rows, cols):
        &#34;&#34;&#34;Clear the cell contents&#34;&#34;&#34;

        n =  messagebox.askyesno(&#34;Clear Confirm&#34;,
                                   &#34;Clear this data?&#34;,
                                   parent=self.parentframe)
        if not n:
            return
        for col in cols:
            for row in rows:
                #absrow = self.get_AbsoluteRow(row)
                self.model.deleteCellRecord(row, col)
                self.redrawCell(row,col)
        return

    def clearData(self, evt=None):
        &#34;&#34;&#34;Delete cells from gui event&#34;&#34;&#34;

        rows = self.multiplerowlist
        cols = self.multiplecollist
        self.deleteCells(rows, cols)
        return

    def autoAddColumns(self, numcols=None):
        &#34;&#34;&#34;Automatically add x number of cols&#34;&#34;&#34;

        if numcols == None:
            numcols = simpledialog.askinteger(&#34;Auto add rows.&#34;,
                                                &#34;How many empty columns?&#34;,
                                                parent=self.parentframe)
        self.model.auto_AddColumns(numcols)
        self.parentframe.configure(width=self.width)
        self.redrawTable()
        return

    def getRecordInfo(self, row):
        &#34;&#34;&#34;Show the record for this row&#34;&#34;&#34;

        model = self.model
        #We need a custom dialog for allowing field entries here
        #absrow = self.get_AbsoluteRow(row)
        d = RecordViewDialog(title=&#34;Record Details&#34;,
                                  parent=self.parentframe, table=self, row=row)
        return

    def findValue(self, searchstring=None, findagain=None):
        &#34;&#34;&#34;Return the row/col for the input value&#34;&#34;&#34;

        if searchstring == None:
            searchstring = simpledialog.askstring(&#34;Search table.&#34;,
                                               &#34;Enter search value&#34;,
                                               parent=self.parentframe)
        found=0
        if findagain == None or not hasattr(self,&#39;foundlist&#39;):
            self.foundlist=[]
        if self.model!=None:
            for row in range(self.rows):
                for col in range(self.cols):
                    text = str(self.model.getValueAt(row,col))
                    if text==&#39;&#39; or text==None:
                        continue
                    cell=row,col
                    if findagain == 1 and cell in self.foundlist:
                        continue
                    if text.lower().find(searchstring.lower())!=-1:
                        print (&#39;found in&#39;,row,col)
                        found=1
                        #highlight cell
                        self.delete(&#39;searchrect&#39;)
                        self.drawRect(row, col, color=&#39;red&#39;, tag=&#39;searchrect&#39;, delete=0)
                        self.lift(&#39;searchrect&#39;)
                        self.lift(&#39;celltext&#39;+str(col)+&#39;_&#39;+str(row))
                        #add row/col to foundlist
                        self.foundlist.append(cell)
                        #need to scroll to centre the cell here..
                        x,y = self.getCanvasPos(row, col)
                        self.xview(&#39;moveto&#39;, x)
                        self.yview(&#39;moveto&#39;, y)
                        self.tablecolheader.xview(&#39;moveto&#39;, x)
                        self.tablerowheader.yview(&#39;moveto&#39;, y)
                        return row, col
        if found==0:
            self.delete(&#39;searchrect&#39;)
            print (&#39;nothing found&#39;)
            return None

    def showAll(self):
        self.model.filteredrecs = None
        self.filtered = False
        self.redrawTable()
        return

    def doFilter(self, event=None):
        &#34;&#34;&#34;Filter the table display by some column values.
        We simply pass the model search function to the the filtering
        class and that handles everything else.
        See filtering frame class for how searching is done.
        &#34;&#34;&#34;
        if self.model==None:
            return
        names = self.filterframe.doFiltering(searchfunc=self.model.filterBy)
        #create a list of filtered recs
        self.model.filteredrecs = names
        self.filtered = True
        self.redrawTable()
        return

    def createFilteringBar(self, parent=None, fields=None):
        &#34;&#34;&#34;Add a filter frame&#34;&#34;&#34;

        if parent == None:
            parent = Toplevel()
            parent.title(&#39;Filter Records&#39;)
            x,y,w,h = self.getGeometry(self.master)
            parent.geometry(&#39;+%s+%s&#39; %(x,y+h))
        if fields == None:
            fields = self.model.columnNames
        from .Filtering import FilterFrame
        self.filterframe = FilterFrame(parent, fields,
                                       self.doFilter, self.closeFilterFrame)
        self.filterframe.pack()
        return parent

    def showFilteringBar(self):
        if not hasattr(self, &#39;filterwin&#39;) or self.filterwin == None:
            self.filterwin = self.createFilteringBar()
            self.filterwin.protocol(&#34;WM_DELETE_WINDOW&#34;, self.closeFilterFrame)
        else:
            self.filterwin.lift()
        return

    def closeFilterFrame(self):
        &#34;&#34;&#34;Callback for closing filter frame&#34;&#34;&#34;
        self.filterwin.destroy()
        self.filterwin = None
        self.showAll()
        return

    def resizeColumn(self, col, width):
        &#34;&#34;&#34;Resize a column by dragging&#34;&#34;&#34;

        #print &#39;resizing column&#39;, col
        #recalculate all col positions..
        colname=self.model.getColumnName(col)
        self.model.columnwidths[colname]=width
        self.setColPositions()
        self.redrawTable()
        self.drawSelectedCol(self.currentcol)
        return

    def get_currentRecord(self):
        &#34;&#34;&#34;Get the currently selected record&#34;&#34;&#34;

        rec = self.model.getRecordAtRow(self.currentrow)
        return rec

    def get_currentColName(self):
        &#34;&#34;&#34;Get the currently selected record name&#34;&#34;&#34;

        colname = self.mo(self.currentcol)
        return colname

    def get_currentRecordName(self):
        &#34;&#34;&#34;Get the currently selected record name&#34;&#34;&#34;

        recname = self.model.getRecName(self.currentrow)
        return recname

    def get_selectedRecordNames(self):
        &#34;&#34;&#34;Get a list of the current multiple selection, if any&#34;&#34;&#34;

        recnames=[]
        for row in self.multiplerowlist:
            recnames.append(self.model.getRecName(row))
        return recnames

    def get_currentRecCol(self):
        &#34;&#34;&#34;Get the clicked rec and col names as a tuple&#34;&#34;&#34;

        recname = self.get_currentRecordName()
        colname = self.get_currentColName()
        return (recname, colname)

    def get_row_clicked(self, event):
        &#34;&#34;&#34;get row where event on canvas occurs&#34;&#34;&#34;

        h=self.rowheight
        #get coord on canvas, not window, need this if scrolling
        y = int(self.canvasy(event.y))
        y_start=self.y_start
        rowc = int((int(y)-y_start)/h)
        #rowc = math.floor(rowc)
        #print &#39;event.y&#39;,event.y, &#39;y&#39;,y
        #print &#39;rowclicked&#39;, rowc
        return rowc

    def get_col_clicked(self,event):
        &#34;&#34;&#34;get col where event on canvas occurs&#34;&#34;&#34;

        w=self.cellwidth
        x = int(self.canvasx(event.x))
        x_start=self.x_start
        #print self.col_positions
        for colpos in self.col_positions:
            try:
                nextpos=self.col_positions[self.col_positions.index(colpos)+1]
            except:
                nextpos=self.tablewidth
            if x &gt; colpos and x &lt;= nextpos:
                #print &#39;x=&#39;, x, &#39;colpos&#39;, colpos, self.col_positions.index(colpos)
                return self.col_positions.index(colpos)
            else:
                #print None
                pass
        #return colc

    def setSelectedRow(self, row):
        &#34;&#34;&#34;Set currently selected row and reset multiple row list&#34;&#34;&#34;

        self.currentrow = row
        self.multiplerowlist = []
        self.multiplerowlist.append(row)
        return

    def setSelectedCol(self, col):
        &#34;&#34;&#34;Set currently selected column&#34;&#34;&#34;

        self.currentcol = col
        self.multiplecollist = []
        self.multiplecollist.append(col)
        return

    def setSelectedCells(self, startrow, endrow, startcol, endcol):
        &#34;&#34;&#34;Set a block of cells selected&#34;&#34;&#34;

        self.currentrow = startrow
        self.currentcol = startcol
        if startrow &lt; 0 or startcol &lt; 0:
            return
        if endrow &gt; self.rows or endcol &gt; self.cols:
            return
        for r in range(startrow, endrow):
            self.multiplerowlist.append(r)
        for c in range(startcol, endcol):
            self.multiplecollist.append(c)
        return

    def getSelectedRow(self):
        &#34;&#34;&#34;Get currently selected row&#34;&#34;&#34;
        return self.currentrow

    def getSelectedColumn(self):
        &#34;&#34;&#34;Get currently selected column&#34;&#34;&#34;
        return self.currentcol

    def select_All(self):
        &#34;&#34;&#34;Select all rows and cells&#34;&#34;&#34;

        self.startrow = 0
        self.endrow = self.rows
        self.multiplerowlist = range(self.startrow,self.endrow)
        self.drawMultipleRows(self.multiplerowlist)
        self.startcol = 0
        self.endcol = self.cols
        self.multiplecollist = range(self.startcol, self.endcol)
        self.drawMultipleCells()
        return

    def getCellCoords(self, row, col):
        &#34;&#34;&#34;Get x-y coordinates to drawing a cell in a given row/col&#34;&#34;&#34;
        colname=self.model.getColumnName(col)
        if colname in self.model.columnwidths:
            w=self.model.columnwidths[colname]
        else:
            w=self.cellwidth
        h=self.rowheight
        x_start=self.x_start
        y_start=self.y_start

        #get nearest rect co-ords for that row/col
        #x1=x_start+w*col
        x1=self.col_positions[col]
        y1=y_start+h*row
        x2=x1+w
        y2=y1+h
        return x1,y1,x2,y2

    def getCanvasPos(self, row, col):
        &#34;&#34;&#34;Get the cell x-y coords as a fraction of canvas size&#34;&#34;&#34;
        if self.rows==0:
            return None, None
        x1,y1,x2,y2 = self.getCellCoords(row,col)
        cx=float(x1)/self.tablewidth
        cy=float(y1)/(self.rows*self.rowheight)
        return cx, cy

    def isInsideTable(self,x,y):
        &#34;&#34;&#34;Returns true if x-y coord is inside table bounds&#34;&#34;&#34;
        if self.x_start &lt; x &lt; self.tablewidth and self.y_start &lt; y &lt; self.rows*self.rowheight:
            return 1
        else:
            return 0
        return answer

    def setRowHeight(self, h):
        &#34;&#34;&#34;Set the row height&#34;&#34;&#34;
        self.rowheight = h
        return

    def clearSelected(self):
        self.delete(&#39;rect&#39;)
        self.delete(&#39;entry&#39;)
        self.delete(&#39;tooltip&#39;)
        self.delete(&#39;searchrect&#39;)
        self.delete(&#39;colrect&#39;)
        self.delete(&#39;multicellrect&#39;)

        #self.delete(&#39;formulabox&#39;)
        return

    def gotoprevRow(self):
        &#34;&#34;&#34;Programmatically set previous row - eg. for button events&#34;&#34;&#34;
        self.clearSelected()
        current = self.getSelectedRow()
        self.setSelectedRow(current-1)
        self.startrow = current-1
        self.endrow = current-1
        #reset multiple selection list
        self.multiplerowlist=[]
        self.multiplerowlist.append(self.currentrow)
        self.drawSelectedRect(self.currentrow, self.currentcol)
        self.drawSelectedRow()
        coltype = self.model.getColumnType(self.currentcol)
        if coltype == &#39;text&#39; or coltype == &#39;number&#39;:
            self.drawCellEntry(self.currentrow, self.currentcol)
        return

    def gotonextRow(self):
        &#34;&#34;&#34;Programmatically set next row - eg. for button events&#34;&#34;&#34;
        self.clearSelected()
        current = self.getSelectedRow()
        self.setSelectedRow(current+1)
        self.startrow = current+1
        self.endrow = current+1
        #reset multiple selection list
        self.multiplerowlist=[]
        self.multiplerowlist.append(self.currentrow)
        self.drawSelectedRect(self.currentrow, self.currentcol)
        self.drawSelectedRow()
        coltype = self.model.getColumnType(self.currentcol)
        if coltype == &#39;text&#39; or coltype == &#39;number&#39;:
            self.drawCellEntry(self.currentrow, self.currentcol)
        return

    def handle_left_click(self, event):
        &#34;&#34;&#34;Respond to a single press&#34;&#34;&#34;

        #which row and column is the click inside?
        self.clearSelected()
        self.allrows = False
        rowclicked = self.get_row_clicked(event)
        colclicked = self.get_col_clicked(event)
        self.focus_set()
        if self.mode == &#39;formula&#39;:
            self.handleFormulaClick(rowclicked, colclicked)
            return
        if hasattr(self, &#39;cellentry&#39;):
            self.cellentry.destroy()
        #ensure popup menus are removed if present
        if hasattr(self, &#39;rightmenu&#39;):
            self.rightmenu.destroy()
        if hasattr(self.tablecolheader, &#39;rightmenu&#39;):
            self.tablecolheader.rightmenu.destroy()

        self.startrow = rowclicked
        self.endrow = rowclicked
        self.startcol = colclicked
        self.endcol = colclicked
        #reset multiple selection list
        self.multiplerowlist=[]
        self.multiplerowlist.append(rowclicked)
        if rowclicked is None or colclicked is None:
            return
        if self.read_only is True:    
            return
        if 0 &lt;= rowclicked &lt; self.rows and 0 &lt;= colclicked &lt; self.cols:
            self.setSelectedRow(rowclicked)
            self.setSelectedCol(colclicked)
            self.drawSelectedRect(self.currentrow, self.currentcol)
            self.drawSelectedRow()
            self.tablerowheader.drawSelectedRows(rowclicked)
            coltype = self.model.getColumnType(colclicked)
            if coltype == &#39;text&#39; or coltype == &#39;number&#39;:
                self.drawCellEntry(rowclicked, colclicked)
        return

    def handle_left_release(self,event):
        self.endrow = self.get_row_clicked(event)
        return

    def handle_left_ctrl_click(self, event):
        &#34;&#34;&#34;Handle ctrl clicks for multiple row selections&#34;&#34;&#34;
        rowclicked = self.get_row_clicked(event)
        colclicked = self.get_col_clicked(event)
        if 0 &lt;= rowclicked &lt; self.rows and 0 &lt;= colclicked &lt; self.cols:
            if rowclicked not in self.multiplerowlist:
                self.multiplerowlist.append(rowclicked)
            else:
                self.multiplerowlist.remove(rowclicked)
            self.drawMultipleRows(self.multiplerowlist)
            if colclicked not in self.multiplecollist:
                self.multiplecollist.append(colclicked)
            #print self.multiplecollist
            self.drawMultipleCells()
        return

    def handle_left_shift_click(self, event):
        &#34;&#34;&#34;Handle shift click, for selecting multiple rows&#34;&#34;&#34;
        #Has same effect as mouse drag, so just use same method
        self.handle_mouse_drag(event)
        return

    def handle_mouse_drag(self, event):
        &#34;&#34;&#34;Handle mouse moved with button held down, multiple selections&#34;&#34;&#34;

        if hasattr(self, &#39;cellentry&#39;):
            self.cellentry.destroy()
        rowover = self.get_row_clicked(event)
        colover = self.get_col_clicked(event)
        if colover == None or rowover == None:
            return

        if rowover &gt;= self.rows or self.startrow &gt; self.rows:
            return
        else:
            self.endrow = rowover
        #do columns
        if colover &gt; self.cols or self.startcol &gt; self.cols:
            return
        else:
            self.endcol = colover
            if self.startcol is None or self.endcol is None:
                return
            if self.endcol &lt; self.startcol:
                self.multiplecollist = range(self.endcol, self.startcol+1)
            else:
                self.multiplecollist = range(self.startcol, self.endcol+1)
            #print self.multiplecollist
        #draw the selected rows
        if self.endrow != self.startrow:
            if self.endrow &lt; self.startrow:
                self.multiplerowlist = range(self.endrow, self.startrow+1)
            else:
                self.multiplerowlist = range(self.startrow, self.endrow+1)
            self.drawMultipleRows(self.multiplerowlist)
            self.tablerowheader.drawSelectedRows(self.multiplerowlist)
            #draw selected cells outline using row and col lists
            #print self.multiplerowlist
            self.drawMultipleCells()
        else:
            self.multiplerowlist = []
            self.multiplerowlist.append(self.currentrow)
            if len(self.multiplecollist) &gt;= 1:
                self.drawMultipleCells()
            self.delete(&#39;multiplesel&#39;)
        #print self.multiplerowlist
        return

    def handle_arrow_keys(self, event):
        &#34;&#34;&#34;Handle arrow keys press&#34;&#34;&#34;
        #print event.keysym

        row = self.get_row_clicked(event)
        col = self.get_col_clicked(event)
        x,y = self.getCanvasPos(self.currentrow, 0)
        if x == None:
            return

        if event.keysym == &#39;Up&#39;:
            if self.currentrow == 0:
                return
            else:
                self.currentrow  = self.currentrow -1
        elif event.keysym == &#39;Down&#39;:
            if self.currentrow &gt;= self.rows-1:
                return
            else:
                self.currentrow  = self.currentrow +1
        elif event.keysym == &#39;Right&#39; or event.keysym == &#39;Tab&#39;:
            if self.currentcol &gt;= self.cols-1:
                if self.currentrow &lt; self.rows-1:
                    self.currentcol = 0
                    self.currentrow  = self.currentrow +1
                else:
                    return
            else:
                self.currentcol  = self.currentcol +1
        elif event.keysym == &#39;Left&#39;:
            if self.currentcol == 0:
                if self.currentrow == 0:
                    return
                else:
                    self.currentcol = self.cols-1
                    self.currentrow = self.currentrow - 1
            else:
                self.currentcol  = self.currentcol -1
        self.drawSelectedRect(self.currentrow, self.currentcol)
        coltype = self.model.getColumnType(self.currentcol)
        if coltype == &#39;text&#39; or coltype == &#39;number&#39;:
            self.delete(&#39;entry&#39;)
            self.drawCellEntry(self.currentrow, self.currentcol)
        return

    def handle_double_click(self, event):
        &#34;&#34;&#34;Do double click stuff. Selected row/cols will already have
           been set with single click binding&#34;&#34;&#34;

        &#39;&#39;&#39;row = self.get_row_clicked(event)
        col = self.get_col_clicked(event)
        model=self.getModel()
        cellvalue = model.getCellRecord(row, col)
        if Formula.isFormula(cellvalue):
            self.formula_Dialog(row, col, cellvalue)&#39;&#39;&#39;

        return

    def handle_right_click(self, event):
        &#34;&#34;&#34;respond to a right click&#34;&#34;&#34;

        if self.read_only is True:
            return
        self.delete(&#39;tooltip&#39;)
        self.tablerowheader.clearSelected()
        if hasattr(self, &#39;rightmenu&#39;):
            self.rightmenu.destroy()
        rowclicked = self.get_row_clicked(event)
        colclicked = self.get_col_clicked(event)
        if colclicked == None:
            self.rightmenu = self.popupMenu(event, outside=1)
            return

        if (rowclicked in self.multiplerowlist or self.allrows == True) and colclicked in self.multiplecollist:
            self.rightmenu = self.popupMenu(event, rows=self.multiplerowlist, cols=self.multiplecollist)
        else:
            if 0 &lt;= rowclicked &lt; self.rows and 0 &lt;= colclicked &lt; self.cols:
                self.clearSelected()
                self.allrows = False
                self.setSelectedRow(rowclicked)
                self.setSelectedCol(colclicked)
                self.drawSelectedRect(self.currentrow, self.currentcol)
                self.drawSelectedRow()
            if self.isInsideTable(event.x,event.y) == 1:
                self.rightmenu = self.popupMenu(event,rows=self.multiplerowlist, cols=self.multiplecollist)
            else:
                self.rightmenu = self.popupMenu(event, outside=1)
        return

    def handle_motion(self, event):
        &#34;&#34;&#34;Handle mouse motion on table&#34;&#34;&#34;

        self.delete(&#39;tooltip&#39;)
        row = self.get_row_clicked(event)
        col = self.get_col_clicked(event)
        if row == None or col == None:
            return
        if 0 &lt;= row &lt; self.rows and 0 &lt;= col &lt; self.cols:
            self.drawTooltip(row, col)

        return

    def gotonextCell(self, event):
        &#34;&#34;&#34;Move highlighted cell to next cell in row or a new col&#34;&#34;&#34;
        #print &#39;next&#39;
        if hasattr(self, &#39;cellentry&#39;):
            self.cellentry.destroy()
        self.currentcol=self.currentcol+1
        if self.currentcol &gt;= self.cols-1:
            self.currentrow  = self.currentrow +1
            self.currentcol = self.currentcol+1
        self.drawSelectedRect(self.currentrow, self.currentcol)
        return

    def movetoSelectedRow(self, row=None, recname=None):
        &#34;&#34;&#34;Move to selected row, updating table&#34;&#34;&#34;
        row=self.model.getRecordIndex(recname)
        self.setSelectedRow(row)
        self.drawSelectedRow()
        x,y = self.getCanvasPos(row, 0)
        self.yview(&#39;moveto&#39;, y-0.01)
        self.tablecolheader.yview(&#39;moveto&#39;, y)
        return

    def handleFormulaClick(self, row, col):
        &#34;&#34;&#34;Do a dialog for cell formula entry&#34;&#34;&#34;

        model = self.getModel()
        cell = list(model.getRecColNames(row, col))
        #absrow = self.get_AbsoluteRow(row)
        self.formulaText.insert(END, str(cell))
        self.formulaText.focus_set()
        self.drawSelectedRect(row, col, color=&#39;red&#39;)
        return

    def formula_Dialog(self, row, col, currformula=None):
        &#34;&#34;&#34;Formula dialog&#34;&#34;&#34;
        self.mode = &#39;formula&#39;
        print (self.mode)
        x1,y1,x2,y2 = self.getCellCoords(row,col)
        w=300
        h=h=self.rowheight * 3
        def close():
            if hasattr(self,&#39;formulaWin&#39;):
                self.delete(&#39;formulabox&#39;)
            self.mode = &#39;normal&#39;
        def calculate():
            #get text area contents and do formula
            f = self.formulaText.get(1.0, END)
            f = f.strip(&#39;\n&#39;)
            self.model.setFormulaAt(f,row,col)
            value = self.model.doFormula(f)
            color = self.model.getColorAt(row,col,&#39;fg&#39;)
            self.drawText(row, col, value, color)
            close()
            self.mode = &#39;normal&#39;
            return
        def clear():
            self.formulaText.delete(1.0, END)

        self.formulaFrame = Frame(width=w,height=h,bd=3)
        self.formulaText = Text(self.formulaFrame, width=30, height=8, bg=&#39;white&#39;,relief=GROOVE)
        self.formulaText.pack(side=LEFT,padx=2,pady=2)
        if currformula != None:
            self.formulaText.insert(END, Formula.getFormula(currformula))
        cancelbutton=Button(self.formulaFrame, text=&#39;Cancel&#39;,
                            bg=&#39;#99ccff&#39;,command=close)
        cancelbutton.pack(fill=BOTH,padx=2,pady=2)
        donebutton=Button(self.formulaFrame, text=&#39;Done&#39;,
                          bg=&#39;#99ccff&#39;,command=calculate)
        donebutton.pack(fill=BOTH,padx=2,pady=2)
        &#39;&#39;&#39;clrbutton=Button(self.formulaFrame, text=&#39;Clear&#39;,
                           bg=&#39;#99ccff&#39;,command=clear)
        clrbutton.pack(fill=BOTH,padx=2,pady=2) &#39;&#39;&#39;
        #add to canvas
        self.formulaWin = self.create_window(x1+self.inset,y1+self.inset,
                                width=w,height=h,
                                window=self.formulaFrame,anchor=&#39;nw&#39;,
                                tag=&#39;formulabox&#39;)
        self.formulaText.focus_set()
        return

    def convertFormulae(self, rows, cols=None):
        &#34;&#34;&#34;Convert the formulas in the cells to their result values&#34;&#34;&#34;

        if len(self.multiplerowlist) == 0 or len(self.multiplecollist) == 0:
            return None

        print (rows, cols)
        if cols == None:
            cols = range(self.cols)
        for r in rows:
            #absr=self.get_AbsoluteRow(r)
            for c in cols:
                val = self.model.getValueAt(r,c)
                self.model.setValueAt(val, r, c)
        return

    def paste(self, event=None):
        &#34;&#34;&#34;Copy from clipboard&#34;&#34;&#34;

        print (self.parentframe.clipboard_get())
        return

    def copyCell(self, rows, cols=None):
        &#34;&#34;&#34;Copy cell contents to a temp internal clipboard&#34;&#34;&#34;

        row = rows[0]; col = cols[0]
        #absrow = self.get_AbsoluteRow(row)
        self.clipboard = copy.deepcopy(self.model.getCellRecord(row, col))
        return

    def pasteCell(self, rows, cols=None):
        &#34;&#34;&#34;Paste cell from internal clipboard&#34;&#34;&#34;

        row = rows[0]; col = cols[0]
        #absrow = self.get_AbsoluteRow(row)
        val = self.clipboard
        self.model.setValueAt(val, row, col)
        self.redrawTable()
        return

    def copyColumns(self):
        &#34;&#34;&#34;Copy current selected cols&#34;&#34;&#34;

        M = self.model
        coldata = {}
        for col in self.multiplecollist:
            name = M.columnNames[col]
            coldata[name] = M.getColumnData(columnName=name)
        return coldata

    def pasteColumns(self, coldata):
        &#34;&#34;&#34;Paste new cols, overwrites existing names&#34;&#34;&#34;

        M = self.model
        for name in coldata:
            if name not in M.columnNames:
                M.addColumn(name)
            for r in range(len(coldata[name])):
                val = coldata[name][r]
                col = M.columnNames.index(name)
                if r &gt;= self.rows:
                    break
                M.setValueAt(val, r, col)
        self.redrawTable()
        return coldata

    # --- Some cell specific actions here ---

    def setcellColor(self, rows, cols=None, newColor=None, key=None, redraw=True):
        &#34;&#34;&#34;Set the cell color for one or more cells and save it in the model color&#34;&#34;&#34;

        model = self.getModel()
        if newColor == None:
            ctuple, newColor = tkColorChooser.askcolor(title=&#39;pick a color&#39;)
            if newColor == None:
                return

        if type(rows) is int:
            x=rows
            rows=[]
            rows.append(x)
        if self.allrows == True:
            #we use all rows if the whole column has been selected
            rows = range(0,self.rows)
        if cols == None:
            cols = range(self.cols)
        for col in cols:
            for row in rows:
                #absrow = self.get_AbsoluteRow(row)
                model.setColorAt(row, col, color=newColor, key=key)
                #setcolor(absrow, col)
        if redraw == True:
            self.redrawTable()
        return

    def popupMenu(self, event, rows=None, cols=None, outside=None):
        &#34;&#34;&#34;Add left and right click behaviour for canvas, should not have to override
            this function, it will take its values from defined dicts in constructor&#34;&#34;&#34;

        defaultactions = {&#34;Set Fill Color&#34; : lambda : self.setcellColor(rows,cols,key=&#39;bg&#39;),
                        &#34;Set Text Color&#34; : lambda : self.setcellColor(rows,cols,key=&#39;fg&#39;),
                        &#34;Copy&#34; : lambda : self.copyCell(rows, cols),
                        &#34;Paste&#34; : lambda : self.pasteCell(rows, cols),
                        &#34;Fill Down&#34; : lambda : self.fillDown(rows, cols),
                        &#34;Fill Right&#34; : lambda : self.fillAcross(cols, rows),
                        &#34;Add Row(s)&#34; : lambda : self.addRows(),
                        &#34;Delete Row(s)&#34; : lambda : self.deleteRow(),
                        &#34;View Record&#34; : lambda : self.getRecordInfo(row),
                        &#34;Clear Data&#34; : lambda : self.deleteCells(rows, cols),
                        &#34;Select All&#34; : self.select_All,
                        &#34;Auto Fit Columns&#34; : self.autoResizeColumns,
                        &#34;Filter Records&#34; : self.showFilteringBar,
                        &#34;New&#34;: self.new,
                        &#34;Load&#34;: self.load,
                        &#34;Save&#34;: self.save,
                        &#34;Import text&#34;:self.importTable,
                        &#34;Export csv&#34;: self.exportTable,
                        &#34;Plot Selected&#34; : self.plotSelected,
                        &#34;Plot Options&#34; : self.plotSetup,
                        &#34;Export Table&#34; : self.exportTable,
                        &#34;Preferences&#34; : self.showtablePrefs,
                        &#34;Formulae-&gt;Value&#34; : lambda : self.convertFormulae(rows, cols)}

        main = [&#34;Set Fill Color&#34;,&#34;Set Text Color&#34;,&#34;Copy&#34;, &#34;Paste&#34;, &#34;Fill Down&#34;,&#34;Fill Right&#34;,
                &#34;Clear Data&#34;]
        general = [&#34;Select All&#34;, &#34;Add Row(s)&#34; , &#34;Delete Row(s)&#34;, &#34;Auto Fit Columns&#34;, &#34;Filter Records&#34;, &#34;Preferences&#34;]
        filecommands = [&#39;New&#39;,&#39;Load&#39;,&#39;Save&#39;,&#39;Import text&#39;,&#39;Export csv&#39;]
        plotcommands = [&#39;Plot Selected&#39;,&#39;Plot Options&#39;]

        def createSubMenu(parent, label, commands):
            menu = Menu(parent, tearoff = 0)
            popupmenu.add_cascade(label=label,menu=menu)
            for action in commands:
                menu.add_command(label=action, command=defaultactions[action])
            return menu

        def add_commands(fieldtype):
            &#34;&#34;&#34;Add commands to popup menu for column type and specific cell&#34;&#34;&#34;
            functions = self.columnactions[fieldtype]
            for f in functions.keys():
                func = getattr(self, functions[f])
                popupmenu.add_command(label=f, command= lambda : func(row,col))
            return

        popupmenu = Menu(self, tearoff = 0)
        def popupFocusOut(event):
            popupmenu.unpost()

        if outside == None:
            #if outside table, just show general items
            row = self.get_row_clicked(event)
            col = self.get_col_clicked(event)
            coltype = self.model.getColumnType(col)
            def add_defaultcommands():
                &#34;&#34;&#34;now add general actions for all cells&#34;&#34;&#34;
                for action in main:
                    if action == &#39;Fill Down&#39; and (rows == None or len(rows) &lt;= 1):
                        continue
                    if action == &#39;Fill Right&#39; and (cols == None or len(cols) &lt;= 1):
                        continue
                    else:
                        popupmenu.add_command(label=action, command=defaultactions[action])
                return

            if coltype in self.columnactions:
                add_commands(coltype)
            add_defaultcommands()

        for action in general:
            popupmenu.add_command(label=action, command=defaultactions[action])

        popupmenu.add_separator()
        createSubMenu(popupmenu, &#39;File&#39;, filecommands)
        createSubMenu(popupmenu, &#39;Plot&#39;, plotcommands)
        popupmenu.bind(&#34;&lt;FocusOut&gt;&#34;, popupFocusOut)
        popupmenu.focus_set()
        popupmenu.post(event.x_root, event.y_root)
        return popupmenu

    # --- spreadsheet type functions ---

    def fillDown(self, rowlist, collist):
        &#34;&#34;&#34;Fill down a column, or multiple columns&#34;&#34;&#34;
        model = self.model
        #absrow  = self.get_AbsoluteRow(rowlist[0])
        #remove first element as we don&#39;t want to overwrite it
        rowlist.remove(rowlist[0])

        #if this is a formula, we have to treat it specially
        for col in collist:
            val = self.model.getCellRecord(row, col)
            f=val #formula to copy
            i=1
            for r in rowlist:
                #absr = self.get_AbsoluteRow(r)
                if Formula.isFormula(f):
                    newval = model.copyFormula(f, r, col, offset=i)
                    model.setFormulaAt(newval, r, col)
                else:
                    model.setValueAt(val, r, col)
                #print &#39;setting&#39;, val, &#39;at row&#39;, r
                i+=1

        self.redrawTable()
        return

    def fillAcross(self, collist, rowlist):
        &#34;&#34;&#34;Fill across a row, or multiple rows&#34;&#34;&#34;
        model = self.model
        #row = self.currentrow
        #absrow  = self.get_AbsoluteRow(collist[0])
        frstcol = collist[0]
        collist.remove(frstcol)

        for row in rowlist:
            #absr = self.get_AbsoluteRow(row)
            val = self.model.getCellRecord(absr, frstcol)
            f=val     #formula to copy
            i=1
            for c in collist:
                if Formula.isFormula(f):
                    newval = model.copyFormula(f, r, c, offset=i, dim=&#39;x&#39;)
                    model.setFormulaAt(newval, r, c)
                else:
                    model.setValueAt(val, r, c)
                i+=1
        self.redrawTable()
        return

    def getSelectionValues(self):
        &#34;&#34;&#34;Get values for current multiple cell selection&#34;&#34;&#34;
        if len(self.multiplerowlist) == 0 or len(self.multiplecollist) == 0:
            return None
        rows = self.multiplerowlist
        cols = self.multiplecollist
        model = self.model
        if len(rows)&lt;1 or len(cols)&lt;1:
            return None
        #if only one row selected we plot whole col
        if len(rows) == 1:
            rows = self.rowrange
        lists = []

        for c in cols:
            x=[]
            for r in rows:
                #absr = self.get_AbsoluteRow(r)
                val = model.getValueAt(r,c)
                if val == None or val == &#39;&#39;:
                    continue
                x.append(val)
            lists.append(x)
        return lists

    def plotSelected(self, graphtype=&#39;XY&#39;):
        &#34;&#34;&#34;Plot the selected data using pylab - if possible&#34;&#34;&#34;

        from .Plot import pylabPlotter
        if not hasattr(self, &#39;pyplot&#39;):
            self.pyplot = pylabPlotter()
        plotdata = []
        for p in self.getSelectionValues():
            x = []
            fail = False
            for d in p:
                try:
                    x.append(float(d))
                except:
                    fail = True
                    continue
            if fail == False:
                plotdata.append(x)

        pltlabels = self.getplotlabels()
        if len(pltlabels) &gt; 2:
            self.pyplot.setDataSeries(pltlabels)
            self.pyplot.showlegend = 1
        self.pyplot.plotCurrent(data=plotdata, graphtype=graphtype)
        return

    def plotSetup(self):
        &#34;&#34;&#34;Call pylab plot dialog setup, send data if we haven&#39;t already
            plotted&#34;&#34;&#34;

        from PylabPlot import pylabPlotter
        if not hasattr(self, &#39;pyplot&#39;):
            self.pyplot = pylabPlotter()
        plotdata = self.getSelectionValues()
        if not self.pyplot.hasData() and plotdata != None:
            print (&#39;has data&#39;)
            plotdata = self.getSelectionValues()
            pltlabels = self.getplotlabels()
            self.pyplot.setDataSeries(pltlabels)
            self.pyplot.plotSetup(plotdata)
        else:
            self.pyplot.plotSetup()
        return

    def getplotlabels(self):
        &#34;&#34;&#34;Get labels for plot series from col labels&#34;&#34;&#34;
        pltlabels = []
        for col in self.multiplecollist:
            pltlabels.append(self.model.getColumnLabel(col))
        return pltlabels

    #--- Drawing stuff ---

    def drawGrid(self, startrow, endrow):
        &#34;&#34;&#34;Draw the table grid lines&#34;&#34;&#34;
        self.delete(&#39;gridline&#39;,&#39;text&#39;)
        rows=len(self.rowrange)
        cols=self.cols
        w = self.cellwidth
        h = self.rowheight
        x_start=self.x_start
        y_start=self.y_start
        x_pos=x_start

        if self.vertlines==1:
            for col in range(cols+1):
                x=self.col_positions[col]
                self.create_line(x,y_start,x,y_start+rows*h, tag=&#39;gridline&#39;,
                                     fill=self.grid_color, width=self.linewidth)
        if self.horizlines==1:
            for row in range(startrow, endrow+1):
                y_pos=y_start+row*h
                self.create_line(x_start,y_pos,self.tablewidth,y_pos, tag=&#39;gridline&#39;,
                                    fill=self.grid_color, width=self.linewidth)
        return

    def drawRowHeader(self):
        &#34;&#34;&#34;User has clicked to select a cell&#34;&#34;&#34;
        self.delete(&#39;rowheader&#39;)
        x_start=self.x_start
        y_start=self.y_start
        h=self.rowheight
        rowpos=0
        for row in self.rowrange:
            x1,y1,x2,y2 = self.getCellCoords(rowpos,0)
            self.create_rectangle(0,y1,x_start-2,y2,
                                      fill=&#39;gray75&#39;,
                                      outline=&#39;white&#39;,
                                      width=1,
                                      tag=&#39;rowheader&#39;)
            self.create_text(x_start/2,y1+h/2,
                                      text=row+1,
                                      fill=&#39;black&#39;,
                                      font=self.thefont,
                                      tag=&#39;rowheader&#39;)
            rowpos+=1
        return

    def drawSelectedRect(self, row, col, color=None):
        &#34;&#34;&#34;User has clicked to select a cell&#34;&#34;&#34;
        if col &gt;= self.cols:
            return
        self.delete(&#39;currentrect&#39;)
        bg = self.selectedcolor
        if color == None:
            color = &#39;gray25&#39;
        w=3
        x1,y1,x2,y2 = self.getCellCoords(row,col)
        rect = self.create_rectangle(x1+w/2,y1+w/2,x2-w/2,y2-w/2,
                                  fill=bg,
                                  outline=color,
                                  width=w,
                                  stipple=&#39;gray50&#39;,
                                  tag=&#39;currentrect&#39;)
        #self.lower(&#39;currentrect&#39;)
        #raise text above all
        self.lift(&#39;celltext&#39;+str(col)+&#39;_&#39;+str(row))
        return

    def drawRect(self, row, col, color=None, tag=None, delete=1):
        &#34;&#34;&#34;Cell is colored&#34;&#34;&#34;
        if delete==1:
            self.delete(&#39;cellbg&#39;+str(row)+str(col))
        if color==None or color==self.cellbackgr:
            return
        else:
            bg=color
        if tag==None:
            recttag=&#39;fillrect&#39;
        else:
            recttag=tag
        w=1
        x1,y1,x2,y2 = self.getCellCoords(row,col)
        rect = self.create_rectangle(x1+w/2,y1+w/2,x2-w/2,y2-w/2,
                                  fill=bg,
                                  outline=bg,
                                  width=w,
                                  tag=(recttag,&#39;cellbg&#39;+str(row)+str(col)))
        self.lower(recttag)
        return

    def drawCellEntry(self, row, col, text=None):
        &#34;&#34;&#34;When the user single/double clicks on a text/number cell, bring up entry window&#34;&#34;&#34;

        if self.read_only == True:
            return
        #absrow = self.get_AbsoluteRow(row)
        h=self.rowheight
        model=self.getModel()
        cellvalue = self.model.getCellRecord(row, col)
        if Formula.isFormula(cellvalue):
            return
        else:
            text = self.model.getValueAt(row, col)
        x1,y1,x2,y2 = self.getCellCoords(row,col)
        w=x2-x1
        #Draw an entry window
        txtvar = StringVar()
        txtvar.set(text)
        def callback(e):
            value = txtvar.get()
            if value == &#39;=&#39;:
                #do a dialog that gets the formula into a text area
                #then they can click on the cells they want
                #when done the user presses ok and its entered into the cell
                self.cellentry.destroy()
                #its all done here..
                self.formula_Dialog(row, col)
                return

            coltype = self.model.getColumnType(col)
            if coltype == &#39;number&#39;:
                sta = self.checkDataEntry(e)
                if sta == 1:
                    model.setValueAt(value,row,col)
            elif coltype == &#39;text&#39;:
                model.setValueAt(value,row,col)

            color = self.model.getColorAt(row,col,&#39;fg&#39;)
            self.drawText(row, col, value, color, align=self.align)
            if e.keysym==&#39;Return&#39;:
                self.delete(&#39;entry&#39;)
                #self.drawRect(row, col)
                #self.gotonextCell(e)
            return

        self.cellentry=Entry(self.parentframe,width=20,
                        textvariable=txtvar,
                        #bg=self.entrybackgr,
                        #relief=FLAT,
                        takefocus=1,
                        font=self.thefont)
        self.cellentry.icursor(END)
        self.cellentry.bind(&#39;&lt;Return&gt;&#39;, callback)
        self.cellentry.bind(&#39;&lt;KeyRelease&gt;&#39;, callback)
        self.cellentry.focus_set()
        self.entrywin=self.create_window(x1+self.inset,y1+self.inset,
                                width=w-self.inset*2,height=h-self.inset*2,
                                window=self.cellentry,anchor=&#39;nw&#39;,
                                tag=&#39;entry&#39;)

        return

    def checkDataEntry(self,event=None):
        &#34;&#34;&#34;do validation checks on data entry in a widget&#34;&#34;&#34;
        #if user enters commas, change to points
        import re
        value=event.widget.get()
        if value!=&#39;&#39;:
            try:
                value=re.sub(&#39;,&#39;,&#39;.&#39;, value)
                value=float(value)

            except ValueError:
                event.widget.configure(bg=&#39;red&#39;)
                return 0
        elif value == &#39;&#39;:
            return 1
        return 1

    def drawText(self, row, col, celltxt, fgcolor=None, align=None):
        &#34;&#34;&#34;Draw the text inside a cell area&#34;&#34;&#34;

        self.delete(&#39;celltext&#39;+str(col)+&#39;_&#39;+str(row))
        h=self.rowheight
        x1,y1,x2,y2 = self.getCellCoords(row,col)
        w=x2-x1
        wrap = False
        pad=5
        # If celltxt is a number then we make it a string
        if type(celltxt) is float or type(celltxt) is int:
            celltxt=str(celltxt)
        length = len(celltxt)
        if length == 0:
            return
        #if cell width is less than x, print nothing
        if w&lt;=10:
            return

        if fgcolor == None or fgcolor == &#34;None&#34;:
            fgcolor = &#39;black&#39;
        if align == None:
            align = &#39;w&#39;
        if align == &#39;w&#39;:
            x1 = x1-w/2+pad
        elif align == &#39;e&#39;:
            x1 = x1+w/2-pad

        if w &lt; 18:
            celltxt = &#39;.&#39;
        else:
            fontsize = self.fontsize
            colname = self.model.getColumnName(col)
            #scaling between canvas and text normalised to about font 14
            scale = 8.5 * float(fontsize)/12
            size = length * scale
            if size &gt; w:
                newlength = w / scale
                #print w, size, length, newlength
                celltxt = celltxt[0:int(math.floor(newlength))]

        #if celltxt is dict then we are drawing a hyperlink
        if self.isLink(celltxt) == True:
            haslink=0
            linktext=celltxt[&#39;text&#39;]
            if len(linktext) &gt; w/scale or w&lt;28:
                linktext=linktext[0:int(w/fontsize*1.2)-2]+&#39;..&#39;
            if celltxt[&#39;link&#39;]!=None and celltxt[&#39;link&#39;]!=&#39;&#39;:
                f,s = self.thefont
                linkfont = (f, s, &#39;underline&#39;)
                linkcolor=&#39;blue&#39;
                haslink=1
            else:
                linkfont = self.thefont
                linkcolor=fgcolor

            rect = self.create_text(x1+w/2,y1+h/2,
                                      text=linktext,
                                      fill=linkcolor,
                                      font=linkfont,
                                      tag=(&#39;text&#39;,&#39;hlink&#39;,&#39;celltext&#39;+str(col)+&#39;_&#39;+str(row)))
            if haslink == 1:
                self.tag_bind(rect, &#39;&lt;Double-Button-1&gt;&#39;, self.check_hyperlink)

        #just normal text
        else:
            rect = self.create_text(x1+w/2,y1+h/2,
                                      text=celltxt,
                                      fill=fgcolor,
                                      font=self.thefont,
                                      anchor=align,
                                      tag=(&#39;text&#39;,&#39;celltext&#39;+str(col)+&#39;_&#39;+str(row)))
        return

    def isLink(self, cell):
        &#34;&#34;&#34;Checks if cell is a hyperlink, without using isinstance&#34;&#34;&#34;
        try:
            if &#39;link&#39; in cell:
                return True
        except:
            return False

    def drawSelectedRow(self):
        &#34;&#34;&#34;Draw the highlight rect for the currently selected row&#34;&#34;&#34;

        self.delete(&#39;rowrect&#39;)
        row = self.currentrow
        x1,y1,x2,y2 = self.getCellCoords(row,0)
        x2 = self.tablewidth
        rect = self.create_rectangle(x1,y1,x2,y2,
                                  fill=self.rowselectedcolor,
                                  outline=self.rowselectedcolor,
                                  tag=&#39;rowrect&#39;)
        self.lower(&#39;rowrect&#39;)
        self.lower(&#39;fillrect&#39;)
        self.tablerowheader.drawSelectedRows(self.currentrow)
        return

    def drawSelectedCol(self, col=None, delete=1):
        &#34;&#34;&#34;Draw an outline rect fot the current column selection&#34;&#34;&#34;

        if delete == 1:
            self.delete(&#39;colrect&#39;)
        if col == None:
            col=self.currentcol
        w=2
        x1,y1,x2,y2 = self.getCellCoords(0,col)
        y2 = self.rows * self.rowheight
        rect = self.create_rectangle(x1+w/2,y1+w/2,x2,y2+w/2,
                                     outline=&#39;blue&#39;,width=w,
                                     tag=&#39;colrect&#39;)
        return

    def drawMultipleRows(self, rowlist):
        &#34;&#34;&#34;Draw more than one row selection&#34;&#34;&#34;

        self.delete(&#39;multiplesel&#39;)
        for r in rowlist:
            if r not in self.visiblerows or r &gt; self.rows-1:
                continue
            x1,y1,x2,y2 = self.getCellCoords(r,0)
            x2 = self.tablewidth
            rect = self.create_rectangle(x1,y1,x2,y2,
                                      fill=self.multipleselectioncolor,
                                      outline=self.rowselectedcolor,
                                      tag=(&#39;multiplesel&#39;,&#39;rowrect&#39;))
        self.lower(&#39;multiplesel&#39;)
        self.lower(&#39;fillrect&#39;)
        return

    def drawMultipleCells(self):
        &#34;&#34;&#34;Draw an outline box for multiple cell selection&#34;&#34;&#34;

        self.delete(&#39;multicellrect&#39;)
        rows = self.multiplerowlist
        cols = self.multiplecollist
        w=2
        x1,y1,a,b = self.getCellCoords(rows[0],cols[0])
        c,d,x2,y2 = self.getCellCoords(rows[len(rows)-1],cols[len(cols)-1])
        rect = self.create_rectangle(x1+w/2,y1+w/2,x2,y2,
                             outline=&#39;blue&#39;,width=w,activefill=&#39;red&#39;,activestipple=&#39;gray25&#39;,
                             tag=&#39;multicellrect&#39;)

        return

    def drawTooltip(self, row, col):
        &#34;&#34;&#34;Draw a tooltip showing contents of cell&#34;&#34;&#34;

        x1,y1,x2,y2 = self.getCellCoords(row,col)
        w=x2-x1
        text = self.model.getValueAt(row,col)
        if isinstance(text, dict):
            if &#39;link&#39; in text:
                text = text[&#39;link&#39;]

        # If text is a number we make it a string
        if type(text) is float or type is int:
            text = str(text)
        if text == None or text == &#39;&#39; or len(str(text))&lt;=10:
            return

        sfont = font.Font(family=&#39;Arial&#39;, size=12,weight=&#39;bold&#39;)
        obj = self.create_text(x1+w/1.5,y2,text=text,
                                anchor=&#39;w&#39;,
                                font=sfont,tag=&#39;tooltip&#39;)

        box = self.bbox(obj)
        x1=box[0]-1
        y1=box[1]-1
        x2=box[2]+1
        y2=box[3]+1

        rect = self.create_rectangle(x1+1,y1+1,x2+1,y2+1,tag=&#39;tooltip&#39;,fill=&#39;black&#39;)
        rect2 = self.create_rectangle(x1,y1,x2,y2,tag=&#39;tooltip&#39;,fill=&#39;lightyellow&#39;)
        self.lift(obj)
        return

    def setcellbackgr(self):
        clr = self.getaColor(self.cellbackgr)
        if clr != None:
            self.cellbackgr = clr
        return

    def setgrid_color(self):
        clr = self.getaColor(self.grid_color)
        if clr != None:
            self.grid_color = clr

        return

    def setrowselectedcolor(self):
        clr = self.getaColor(self.rowselectedcolor)
        if clr != None:
            self.rowselectedcolor = clr
        return

    def getaColor(self, oldcolor):

        ctuple, newcolor = tkColorChooser.askcolor(title=&#39;pick a color&#39;, initialcolor=oldcolor,
                                                   parent=self.parentframe)
        if ctuple == None:
            return None
        return str(newcolor)

    #--- Preferences stuff ---

    def showtablePrefs(self, prefs=None):
        &#34;&#34;&#34;Show table options dialog using an instance of prefs&#34;&#34;&#34;
        #self.prefs = prefs
        if self.prefs == None:
            self.loadPrefs()
        self.prefswindow=Toplevel()
        x,y,w,h = self.getGeometry(self.master)
        self.prefswindow.geometry(&#39;+%s+%s&#39; %(int(x+w/2),int(y+h/2)))
        self.prefswindow.title(&#39;Preferences&#39;)
        self.prefswindow.resizable(width=FALSE, height=FALSE)

        frame1=Frame(self.prefswindow)
        frame1.pack(side=LEFT)
        frame2=Frame(self.prefswindow)
        frame2.pack()
        def close_prefsdialog():
            self.prefswindow.destroy()
        row=0
        Checkbutton(frame1, text=&#34;Show horizontal lines&#34;, variable=self.horizlinesvar,
                    onvalue=1, offvalue=0).grid(row=row,column=0, columnspan=2, sticky=&#39;news&#39;)
        row=row+1
        Checkbutton(frame1, text=&#34;Show vertical lines&#34;, variable=self.vertlinesvar,
                    onvalue=1, offvalue=0).grid(row=row,column=0, columnspan=2, sticky=&#39;news&#39;)
        row=row+1
        Checkbutton(frame1, text=&#34;Alternate Row Color&#34;, variable=self.alternaterowsvar,
                    onvalue=1, offvalue=0).grid(row=row,column=0, columnspan=2, sticky=&#39;news&#39;)
        row=row+1
        lblrowheight = Label(frame1,text=&#39;Row Height:&#39;)
        lblrowheight.grid(row=row,column=0,padx=3,pady=2)
        rowheightentry = Spinbox(frame1,from_=12,to=50,width=10,
                            textvariable=self.rowheightvar)
        rowheightentry.grid(row=row,column=1,padx=3,pady=2)
        row=row+1
        lblcellwidth = Label(frame1,text=&#39;Cell Width:&#39;)
        lblcellwidth.grid(row=row,column=0,padx=3,pady=2)
        cellwidthentry = Spinbox(frame1,from_=20,to=500, width=10,
                             textvariable=self.cellwidthvar)
        cellwidthentry.grid(row=row,column=1,padx=3,pady=2)
        row=row+1

        lbllinewidth = Label(frame1,text=&#39;Line Width:&#39;)
        lbllinewidth.grid(row=row,column=0,padx=3,pady=2)
        linewidthentry = Spinbox(frame1,from_=0,to=10,width=10,
                            textvariable=self.linewidthvar)
        linewidthentry.grid(row=row,column=1,padx=3,pady=2)
        row=row+1

        rowhdrwidth = Label(frame1,text=&#39;Row Header Width:&#39;)
        rowhdrwidth.grid(row=row,column=0,padx=3,pady=2)
        rowhdrentry = Spinbox(frame1,from_=0,to=300, width=10,
                            textvariable=self.rowheaderwidthvar)
        rowhdrentry.grid(row=row,column=1,padx=3,pady=2)
        row=row+1

        #fonts
        fts = self.getFonts()
        self.fontvar = StringVar()
        self.fontvar.set(self.prefs.get(&#39;celltextfont&#39;))
        def setFont(*args):
            self.thefont = self.fontvar.get()
            return

        self.fontbox = Combobox(frame2,
                        values=(fts),
                        text=&#39;Font:&#39;,
                        height = 6,
                        textvariable=self.fontvar)
        self.fontvar.trace(&#39;w&#39;, setFont)
        Label(frame2,text=&#39;Font:&#39;).grid(row=row,column=0,padx=3,pady=2)
        self.fontbox.grid(row=row,column=1, columnspan=2, sticky=&#39;nes&#39;, padx=3,pady=2)
        row=row+1

        lblfontsize=Label(frame2,text=&#39;Text Size:&#39;)
        lblfontsize.grid(row=row,column=0,padx=3,pady=2)
        fontsizeentry = Spinbox(frame2,from_=6,to=50, width=20,
                                textvariable=self.celltextsizevar)

        fontsizeentry.grid(row=row,column=1, sticky=&#39;wens&#39;,padx=3,pady=2)
        row=row+1

        #cell alignment
        lbl=Label(frame2,text=&#39;Alignment:&#39;)
        lbl.grid(row=row,column=0,padx=3,pady=2)
        alignentry_button = Menubutton(frame2,textvariable=self.cellalignvar, width=16)
        alignentry_menu = Menu(alignentry_button,tearoff=0)
        alignentry_button[&#39;menu&#39;] = alignentry_menu
        alignments=[&#39;w&#39;,&#39;e&#39;,&#39;center&#39;]
        for text in alignments:
            alignentry_menu.add_radiobutton(label=text,
                                            variable=self.cellalignvar,
                                            value=text,
                                            indicatoron=1)
        alignentry_button.grid(row=row,column=1, sticky=&#39;nes&#39;, padx=3,pady=2)
        row=row+1

        #colors
        style = Style()
        style.configure(&#34;cb.TButton&#34;, background=self.cellbackgr)
        cellbackgrbutton = Button(frame2, text=&#39;table background&#39;, style=&#34;cb.TButton&#34;, #bg=self.cellbackgr,
                                 command=self.setcellbackgr)
        cellbackgrbutton.grid(row=row,column=0,columnspan=2, sticky=&#39;news&#39;,padx=3,pady=2)
        row=row+1
        style = Style()
        style.configure(&#34;gc.TButton&#34;, background=self.grid_color)
        grid_colorbutton = Button(frame2, text=&#39;grid color&#39;,  style=&#34;gc.TButton&#34;, #bg=self.grid_color,
                                 command=self.setgrid_color)
        grid_colorbutton.grid(row=row,column=0,columnspan=2,  sticky=&#39;news&#39;,padx=3,pady=2)
        row=row+1
        style = Style()
        style.configure(&#34;rhc.TButton&#34;, background=self.rowselectedcolor)
        rowselectedcolorbutton = Button(frame2, text=&#39;row highlight color&#39;, style=&#34;rhc.TButton&#34;,
                                 command=self.setrowselectedcolor)
        rowselectedcolorbutton.grid(row=row,column=0,columnspan=2,  sticky=&#39;news&#39;,padx=3,pady=2)
        row=row+1

        frame=Frame(self.prefswindow)
        frame.pack()
        # Apply Button
        b = Button(frame, text=&#34;Apply Settings&#34;, command=self.applyPrefs)
        b.grid(row=row,column=1,columnspan=2,sticky=&#39;news&#39;,padx=4,pady=4)

        # Close button
        c=Button(frame,text=&#39;Close&#39;, command=close_prefsdialog)
        c.grid(row=row,column=0,sticky=&#39;news&#39;,padx=4,pady=4)
        self.prefswindow.focus_set()
        self.prefswindow.grab_set()
        self.prefswindow.wait_window()
        return self.prefswindow

    def getFonts(self):
        fonts = set(list(font.families()))
        fonts = sorted(list(fonts))
        return fonts

    def loadPrefs(self, prefs=None):
        &#34;&#34;&#34;Load table specific prefs from the prefs instance used
           if they are not present, create them.&#34;&#34;&#34;

        if prefs == None:
            prefs=Preferences(&#39;Table&#39;,{&#39;check_for_update&#39;:1})
        self.prefs = prefs
        defaultprefs = {&#39;horizlines&#39;:self.horizlines, &#39;vertlines&#39;:self.vertlines,
                        &#39;alternaterows&#39;:self.alternaterows,
                        &#39;rowheight&#39;:self.rowheight,
                        &#39;cellwidth&#39;:100,
                        &#39;autoresizecols&#39;: 0,
                        &#39;align&#39;: &#39;w&#39;,
                        &#39;celltextsize&#39;:11, &#39;celltextfont&#39;:&#39;Arial&#39;,
                        &#39;cellbackgr&#39;: self.cellbackgr, &#39;grid_color&#39;: self.grid_color,
                        &#39;linewidth&#39; : self.linewidth,
                        &#39;rowselectedcolor&#39;: self.rowselectedcolor,
                        &#39;rowheaderwidth&#39;: self.rowheaderwidth}

        #print (self.prefs.__dict__)
        for prop in defaultprefs:
            if not prop in self.prefs.prefs:
                #print (defaultprefs[prop])
                if defaultprefs[prop] != &#39;None&#39;:
                    self.prefs.set(prop, defaultprefs[prop])

        self.defaultprefs = defaultprefs

        #Create tkvars for dialog
        self.rowheightvar = IntVar()
        self.rowheightvar.set(self.prefs.get(&#39;rowheight&#39;))
        self.rowheight = self.rowheightvar.get()
        self.cellwidthvar = IntVar()
        self.cellwidthvar.set(self.prefs.get(&#39;cellwidth&#39;))
        self.cellwidth = self.cellwidthvar.get()
        self.cellalignvar = StringVar()
        self.cellalignvar.set(self.prefs.get(&#39;align&#39;))
        self.align = self.cellalignvar.get()
        self.linewidthvar = IntVar()
        self.linewidthvar.set(self.prefs.get(&#39;linewidth&#39;))
        self.horizlinesvar = IntVar()
        self.horizlinesvar.set(self.prefs.get(&#39;horizlines&#39;))
        self.vertlinesvar = IntVar()
        self.vertlinesvar.set(self.prefs.get(&#39;vertlines&#39;))
        self.alternaterowsvar = IntVar()
        self.alternaterowsvar.set(self.prefs.get(&#39;alternaterows&#39;))
        self.celltextsizevar = IntVar()
        self.celltextsizevar.set(self.prefs.get(&#39;celltextsize&#39;))
        self.cellbackgr = self.prefs.get(&#39;cellbackgr&#39;)
        self.grid_color = self.prefs.get(&#39;grid_color&#39;)
        self.rowselectedcolor = self.prefs.get(&#39;rowselectedcolor&#39;)
        self.fontsize = self.celltextsizevar.get()
        self.thefont = (self.prefs.get(&#39;celltextfont&#39;), self.prefs.get(&#39;celltextsize&#39;))
        self.rowheaderwidthvar = IntVar()
        self.rowheaderwidthvar.set(self.prefs.get(&#39;rowheaderwidth&#39;))
        self.rowheaderwidth = self.rowheaderwidthvar.get()
        return

    def savePrefs(self):
        &#34;&#34;&#34;Save and set the prefs&#34;&#34;&#34;

        try:
            self.prefs.set(&#39;horizlines&#39;, self.horizlinesvar.get())
            self.horizlines = self.horizlinesvar.get()
            self.prefs.set(&#39;vertlines&#39;, self.vertlinesvar.get())
            self.vertlines = self.vertlinesvar.get()
            self.prefs.set(&#39;alternaterows&#39;, self.alternaterowsvar.get())
            self.alternaterows = self.alternaterowsvar.get()
            self.prefs.set(&#39;rowheight&#39;, self.rowheightvar.get())
            self.rowheight = self.rowheightvar.get()
            self.prefs.set(&#39;cellwidth&#39;, self.cellwidthvar.get())
            self.cellwidth = self.cellwidthvar.get()
            self.prefs.set(&#39;align&#39;, self.cellalignvar.get())
            self.align = self.cellalignvar.get()
            self.prefs.set(&#39;linewidth&#39;, self.linewidthvar.get())
            self.linewidth = self.linewidthvar.get()
            self.prefs.set(&#39;celltextsize&#39;, self.celltextsizevar.get())
            self.prefs.set(&#39;celltextfont&#39;, self.fontvar.get())
            self.prefs.set(&#39;cellbackgr&#39;, self.cellbackgr)
            self.prefs.set(&#39;grid_color&#39;, self.grid_color)
            self.prefs.set(&#39;rowselectedcolor&#39;, self.rowselectedcolor)
            self.prefs.set(&#39;rowheaderwidth&#39;, self.rowheaderwidth)
            self.rowheaderwidth = self.rowheaderwidthvar.get()
            self.thefont = (self.prefs.get(&#39;celltextfont&#39;), self.prefs.get(&#39;celltextsize&#39;))
            self.fontsize = self.prefs.get(&#39;celltextsize&#39;)

        except ValueError as e:
            print (e)
            pass
        self.prefs.save_prefs()
        return

    def applyPrefs(self):
        &#34;&#34;&#34;Apply prefs to the table by redrawing&#34;&#34;&#34;

        self.savePrefs()
        self.redrawTable()
        return

    def AskForColorButton(self, frame, text, func):
        def SetColor():
            ctuple, variable = tkColorChooser.askcolor(title=&#39;pick a color&#39;,
                                                       initialcolor=self.cellbackgr)

            return
        bgcolorbutton = Button(frame, text=text,command=SetColor)
        return  bgcolorbutton

    def check_hyperlink(self,event=None):
        &#34;&#34;&#34;Check if a hyperlink was clicked&#34;&#34;&#34;

        row = self.get_row_clicked(event)
        col = self.get_col_clicked(event)
        #absrow = self.get_AbsoluteRow(row)
        recdata = self.model.getValueAt(row, col)
        try:
            link = recdata[&#39;link&#39;]
            import webbrowser
            webbrowser.open(link,autoraise=1)
        except:
            pass
        return

    def show_progressbar(self,message=None):
        &#34;&#34;&#34;Show progress bar window for loading of data&#34;&#34;&#34;
        progress_win=Toplevel() # Open a new window
        progress_win.title(&#34;Please Wait&#34;)
        #progress_win.geometry(&#39;+%d+%d&#39; %(self.parentframe.rootx+200,self.parentframe.rooty+200))
        #force on top
        progress_win.grab_set()
        progress_win.transient(self.parentframe)
        if message==None:
            message=&#39;Working&#39;
        lbl = Label(progress_win,text=message,font=&#39;Arial 16&#39;)

        lbl.grid(row=0,column=0,columnspan=2,sticky=&#39;news&#39;,padx=6,pady=4)
        progrlbl = Label(progress_win,text=&#39;Progress:&#39;)
        progrlbl.grid(row=1,column=0,sticky=&#39;news&#39;,padx=2,pady=4)
        import ProgressBar
        self.bar = ProgressBar.ProgressBar(progress_win)
        self.bar.frame.grid(row=1,column=1,columnspan=2,padx=2,pady=4)

        return progress_win

    def updateModel(self, model):
        &#34;&#34;&#34;Call this method to update the table model&#34;&#34;&#34;

        self.model = model
        self.rows = self.model.getRowCount()
        self.cols = self.model.getColumnCount()
        self.tablewidth = (self.cellwidth)*self.cols
        self.tablecolheader = ColumnHeader(self.parentframe, self)
        self.tablerowheader = RowHeader(self.parentframe, self)
        self.createTableFrame()
        return

    def new(self):
        &#34;&#34;&#34;Clears all the data and makes a new table&#34;&#34;&#34;

        mpDlg = MultipleValDialog(title=&#39;Create new table&#39;,
                                    initialvalues=(10, 4),
                                    labels=(&#39;rows&#39;,&#39;columns&#39;),
                                    types=(&#39;int&#39;,&#39;int&#39;),
                                    parent=self.parentframe)

        if mpDlg.result == True:
            rows = mpDlg.results[0]
            cols = mpDlg.results[1]
            model = TableModel(rows=rows,columns=cols)
            self.updateModel(model)
        return

    def load(self, filename=None):
        &#34;&#34;&#34;load from a file&#34;&#34;&#34;

        if filename == None:
            filename = filedialog.askopenfilename(parent=self.master,
                                                      defaultextension=&#39;.table&#39;,
                                                      initialdir=os.getcwd(),
                                                      filetypes=[(&#34;pickle&#34;,&#34;*.table&#34;),
                                                        (&#34;All files&#34;,&#34;*.*&#34;)])
        if not os.path.exists(filename):
            print (&#39;file does not exist&#39;)
            return
        if filename:
            self.model.load(filename)
            self.redrawTable()
        return

    def save(self, filename=None):
        &#34;&#34;&#34;Save model to pickle file&#34;&#34;&#34;

        if filename == None:
            filename = filedialog.asksaveasfilename(parent=self.master,
                                                        defaultextension=&#39;.table&#39;,
                                                        initialdir=os.getcwd(),
                                                        filetypes=[(&#34;pickle&#34;,&#34;*.table&#34;),
                                                          (&#34;All files&#34;,&#34;*.*&#34;)])
        if filename:
            self.model.save(filename)
        return

    def importTable(self):
        self.importCSV()

    def importCSV(self, filename=None):
        &#34;&#34;&#34;Import from csv file&#34;&#34;&#34;

        if filename is None:
            from .Tables_IO import TableImporter
            importer = TableImporter()
            importdialog = importer.import_Dialog(self.master)
            self.master.wait_window(importdialog)
            model = TableModel()
            model.importDict(importer.data)
        else:
            model = TableModel()
            model.importCSV(filename)
        self.updateModel(model)
        return

    def exportTable(self, filename=None):
        &#34;&#34;&#34;Do a simple export of the cell contents to csv&#34;&#34;&#34;

        from .Tables_IO import TableExporter
        exporter = TableExporter()
        exporter.ExportTableData(self)
        return

    @classmethod
    def checkOSType(cls):
        &#34;&#34;&#34;Check the OS we are in&#34;&#34;&#34;

        ostyp=&#39;&#39;
        var_s=[&#39;OSTYPE&#39;,&#39;OS&#39;]
        for var in var_s:
            if var in os.environ:
                try:
                    ostyp = str.lower(os.environ[var])
                except:
                    ostyp = os.environ[var].lower()

        ostyp=ostyp.lower()
        if ostyp.find(&#39;windows&#39;)!=-1:
            ostyp=&#39;windows&#39;
        elif ostyp.find(&#39;darwin&#39;)!=-1 or ostyp.find(&#39;apple&#39;)!=-1:
            ostyp=&#39;mac&#39;
        elif ostyp.find(&#39;linux&#39;)!=-1:
            ostyp=&#39;linux&#39;
        else:
            ostyp=&#39;unknown&#39;
            try:
                info=os.uname()
            except:
                pass
            ostyp=info[0].lower()
            if ostyp.find(&#39;darwin&#39;)!=-1:
                ostyp=&#39;mac&#39;
        return ostyp

    def getGeometry(self, frame):
        &#34;&#34;&#34;Get frame geometry&#34;&#34;&#34;
        return frame.winfo_rootx(), frame.winfo_rooty(), frame.winfo_width(), frame.winfo_height()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Canvas</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
<li>tkinter.XView</li>
<li>tkinter.YView</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tkintertable.Custom.MyTable" href="Custom.html#tkintertable.Custom.MyTable">MyTable</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="tkintertable.Tables.TableCanvas.checkOSType"><code class="name flex">
<span>def <span class="ident">checkOSType</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Check the OS we are in</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@classmethod
def checkOSType(cls):
    &#34;&#34;&#34;Check the OS we are in&#34;&#34;&#34;

    ostyp=&#39;&#39;
    var_s=[&#39;OSTYPE&#39;,&#39;OS&#39;]
    for var in var_s:
        if var in os.environ:
            try:
                ostyp = str.lower(os.environ[var])
            except:
                ostyp = os.environ[var].lower()

    ostyp=ostyp.lower()
    if ostyp.find(&#39;windows&#39;)!=-1:
        ostyp=&#39;windows&#39;
    elif ostyp.find(&#39;darwin&#39;)!=-1 or ostyp.find(&#39;apple&#39;)!=-1:
        ostyp=&#39;mac&#39;
    elif ostyp.find(&#39;linux&#39;)!=-1:
        ostyp=&#39;linux&#39;
    else:
        ostyp=&#39;unknown&#39;
        try:
            info=os.uname()
        except:
            pass
        ostyp=info[0].lower()
        if ostyp.find(&#39;darwin&#39;)!=-1:
            ostyp=&#39;mac&#39;
    return ostyp</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tkintertable.Tables.TableCanvas.AskForColorButton"><code class="name flex">
<span>def <span class="ident">AskForColorButton</span></span>(<span>self, frame, text, func)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def AskForColorButton(self, frame, text, func):
    def SetColor():
        ctuple, variable = tkColorChooser.askcolor(title=&#39;pick a color&#39;,
                                                   initialcolor=self.cellbackgr)

        return
    bgcolorbutton = Button(frame, text=text,command=SetColor)
    return  bgcolorbutton</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.addColumn"><code class="name flex">
<span>def <span class="ident">addColumn</span></span>(<span>self, newname=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a new column</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def addColumn(self, newname=None):
    &#34;&#34;&#34;Add a new column&#34;&#34;&#34;

    if newname == None:

        coltypes = self.getModel().getDefaultTypes()
        d = MultipleValDialog(title=&#39;New Column&#39;,
                                initialvalues=(coltypes, &#39;&#39;),
                                labels=(&#39;Column Type&#39;,&#39;Name&#39;),
                                types=(&#39;list&#39;,&#39;string&#39;),
                                parent=self.parentframe)
        if d.result == None:
            return
        else:
            coltype = d.results[0]
            newname = d.results[1]

    if newname != None:
        if newname in self.getModel().columnNames:
            messagebox.showwarning(&#34;Name exists&#34;,
                                     &#34;Name already exists!&#34;,
                                     parent=self.parentframe)
        else:
            self.model.addColumn(newname)
            self.parentframe.configure(width=self.width)
            self.redrawTable()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.addRow"><code class="name flex">
<span>def <span class="ident">addRow</span></span>(<span>self, key=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Add new row</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def addRow(self, key=None, **kwargs):
    &#34;&#34;&#34;Add new row&#34;&#34;&#34;

    key = self.model.addRow(key, **kwargs)
    self.redrawTable()
    self.setSelectedRow(self.model.getRecordIndex(key))
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.addRows"><code class="name flex">
<span>def <span class="ident">addRows</span></span>(<span>self, num=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Add new rows</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def addRows(self, num=None):
    &#34;&#34;&#34;Add new rows&#34;&#34;&#34;

    if num == None:
        num = simpledialog.askinteger(&#34;Now many rows?&#34;,
                                        &#34;Number of rows:&#34;,initialvalue=1,
                                         parent=self.parentframe)
    if not num:
        return
    keys = self.model.autoAddRows(num)
    self.redrawTable()
    self.setSelectedRow(self.model.getRecordIndex(keys[0]))
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.adjustColumnWidths"><code class="name flex">
<span>def <span class="ident">adjustColumnWidths</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Optimally adjust col widths to accomodate the longest entry
in each column - usually only called
on first redraw</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def adjustColumnWidths(self):
    &#34;&#34;&#34;Optimally adjust col widths to accomodate the longest entry
        in each column - usually only called  on first redraw&#34;&#34;&#34;

    #self.cols = self.model.getColumnCount()
    try:
        fontsize = self.thefont[1]
    except:
        fontsize = self.fontsize
    scale = 8.5 * float(fontsize)/12
    for col in range(self.cols):
        colname = self.model.getColumnName(col)
        if colname in self.model.columnwidths:
            w = self.model.columnwidths[colname]
        else:
            w = self.cellwidth
        maxlen = self.model.getlongestEntry(col)
        size = maxlen * scale
        if size &lt; w:
            continue
        #print col, size, self.cellwidth
        if size &gt;= self.maxcellwidth:
            size = self.maxcellwidth
        self.model.columnwidths[colname] = size + float(fontsize)/12*6
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.applyPrefs"><code class="name flex">
<span>def <span class="ident">applyPrefs</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply prefs to the table by redrawing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def applyPrefs(self):
    &#34;&#34;&#34;Apply prefs to the table by redrawing&#34;&#34;&#34;

    self.savePrefs()
    self.redrawTable()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.autoAddColumns"><code class="name flex">
<span>def <span class="ident">autoAddColumns</span></span>(<span>self, numcols=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Automatically add x number of cols</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def autoAddColumns(self, numcols=None):
    &#34;&#34;&#34;Automatically add x number of cols&#34;&#34;&#34;

    if numcols == None:
        numcols = simpledialog.askinteger(&#34;Auto add rows.&#34;,
                                            &#34;How many empty columns?&#34;,
                                            parent=self.parentframe)
    self.model.auto_AddColumns(numcols)
    self.parentframe.configure(width=self.width)
    self.redrawTable()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.autoResizeColumns"><code class="name flex">
<span>def <span class="ident">autoResizeColumns</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Automatically set nice column widths and draw</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def autoResizeColumns(self):
    &#34;&#34;&#34;Automatically set nice column widths and draw&#34;&#34;&#34;

    self.adjustColumnWidths()
    self.redrawTable()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.checkDataEntry"><code class="name flex">
<span>def <span class="ident">checkDataEntry</span></span>(<span>self, event=None)</span>
</code></dt>
<dd>
<section class="desc"><p>do validation checks on data entry in a widget</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def checkDataEntry(self,event=None):
    &#34;&#34;&#34;do validation checks on data entry in a widget&#34;&#34;&#34;
    #if user enters commas, change to points
    import re
    value=event.widget.get()
    if value!=&#39;&#39;:
        try:
            value=re.sub(&#39;,&#39;,&#39;.&#39;, value)
            value=float(value)

        except ValueError:
            event.widget.configure(bg=&#39;red&#39;)
            return 0
    elif value == &#39;&#39;:
        return 1
    return 1</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.check_hyperlink"><code class="name flex">
<span>def <span class="ident">check_hyperlink</span></span>(<span>self, event=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if a hyperlink was clicked</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_hyperlink(self,event=None):
    &#34;&#34;&#34;Check if a hyperlink was clicked&#34;&#34;&#34;

    row = self.get_row_clicked(event)
    col = self.get_col_clicked(event)
    #absrow = self.get_AbsoluteRow(row)
    recdata = self.model.getValueAt(row, col)
    try:
        link = recdata[&#39;link&#39;]
        import webbrowser
        webbrowser.open(link,autoraise=1)
    except:
        pass
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.clearData"><code class="name flex">
<span>def <span class="ident">clearData</span></span>(<span>self, evt=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Delete cells from gui event</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def clearData(self, evt=None):
    &#34;&#34;&#34;Delete cells from gui event&#34;&#34;&#34;

    rows = self.multiplerowlist
    cols = self.multiplecollist
    self.deleteCells(rows, cols)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.clearSelected"><code class="name flex">
<span>def <span class="ident">clearSelected</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def clearSelected(self):
    self.delete(&#39;rect&#39;)
    self.delete(&#39;entry&#39;)
    self.delete(&#39;tooltip&#39;)
    self.delete(&#39;searchrect&#39;)
    self.delete(&#39;colrect&#39;)
    self.delete(&#39;multicellrect&#39;)

    #self.delete(&#39;formulabox&#39;)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.closeFilterFrame"><code class="name flex">
<span>def <span class="ident">closeFilterFrame</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Callback for closing filter frame</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def closeFilterFrame(self):
    &#34;&#34;&#34;Callback for closing filter frame&#34;&#34;&#34;
    self.filterwin.destroy()
    self.filterwin = None
    self.showAll()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.convertFormulae"><code class="name flex">
<span>def <span class="ident">convertFormulae</span></span>(<span>self, rows, cols=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert the formulas in the cells to their result values</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def convertFormulae(self, rows, cols=None):
    &#34;&#34;&#34;Convert the formulas in the cells to their result values&#34;&#34;&#34;

    if len(self.multiplerowlist) == 0 or len(self.multiplecollist) == 0:
        return None

    print (rows, cols)
    if cols == None:
        cols = range(self.cols)
    for r in rows:
        #absr=self.get_AbsoluteRow(r)
        for c in cols:
            val = self.model.getValueAt(r,c)
            self.model.setValueAt(val, r, c)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.copyCell"><code class="name flex">
<span>def <span class="ident">copyCell</span></span>(<span>self, rows, cols=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Copy cell contents to a temp internal clipboard</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def copyCell(self, rows, cols=None):
    &#34;&#34;&#34;Copy cell contents to a temp internal clipboard&#34;&#34;&#34;

    row = rows[0]; col = cols[0]
    #absrow = self.get_AbsoluteRow(row)
    self.clipboard = copy.deepcopy(self.model.getCellRecord(row, col))
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.copyColumns"><code class="name flex">
<span>def <span class="ident">copyColumns</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Copy current selected cols</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def copyColumns(self):
    &#34;&#34;&#34;Copy current selected cols&#34;&#34;&#34;

    M = self.model
    coldata = {}
    for col in self.multiplecollist:
        name = M.columnNames[col]
        coldata[name] = M.getColumnData(columnName=name)
    return coldata</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.createFilteringBar"><code class="name flex">
<span>def <span class="ident">createFilteringBar</span></span>(<span>self, parent=None, fields=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a filter frame</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def createFilteringBar(self, parent=None, fields=None):
    &#34;&#34;&#34;Add a filter frame&#34;&#34;&#34;

    if parent == None:
        parent = Toplevel()
        parent.title(&#39;Filter Records&#39;)
        x,y,w,h = self.getGeometry(self.master)
        parent.geometry(&#39;+%s+%s&#39; %(x,y+h))
    if fields == None:
        fields = self.model.columnNames
    from .Filtering import FilterFrame
    self.filterframe = FilterFrame(parent, fields,
                                   self.doFilter, self.closeFilterFrame)
    self.filterframe.pack()
    return parent</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.createTableFrame"><code class="name flex">
<span>def <span class="ident">createTableFrame</span></span>(<span>self, callback=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def createTableFrame(self, callback=None):
    self.show(callback)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.createfromDict"><code class="name flex">
<span>def <span class="ident">createfromDict</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempt to create a new model/table from a dict</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def createfromDict(self, data):
    &#34;&#34;&#34;Attempt to create a new model/table from a dict&#34;&#34;&#34;

    try:
        namefield=self.namefield
    except:
        namefield=data.keys()[0]
    self.model = TableModel()
    self.model.importDict(data, namefield=namefield)
    self.model.setSortOrder(0,reverse=self.reverseorder)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.deleteCells"><code class="name flex">
<span>def <span class="ident">deleteCells</span></span>(<span>self, rows, cols)</span>
</code></dt>
<dd>
<section class="desc"><p>Clear the cell contents</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def deleteCells(self, rows, cols):
    &#34;&#34;&#34;Clear the cell contents&#34;&#34;&#34;

    n =  messagebox.askyesno(&#34;Clear Confirm&#34;,
                               &#34;Clear this data?&#34;,
                               parent=self.parentframe)
    if not n:
        return
    for col in cols:
        for row in rows:
            #absrow = self.get_AbsoluteRow(row)
            self.model.deleteCellRecord(row, col)
            self.redrawCell(row,col)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.deleteColumn"><code class="name flex">
<span>def <span class="ident">deleteColumn</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Delete currently selected column</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def deleteColumn(self):
    &#34;&#34;&#34;Delete currently selected column&#34;&#34;&#34;

    n =  messagebox.askyesno(&#34;Delete&#34;,
                               &#34;Delete This Column?&#34;,
                               parent=self.parentframe)
    if n:
        col = self.getSelectedColumn()
        self.model.deleteColumn(col)
        self.currentcol = self.currentcol - 1
        self.redrawTable()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.deleteRow"><code class="name flex">
<span>def <span class="ident">deleteRow</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Delete a row</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def deleteRow(self):
    &#34;&#34;&#34;Delete a row&#34;&#34;&#34;

    if len(self.multiplerowlist)&gt;1:
        n = messagebox.askyesno(&#34;Delete&#34;,
                                  &#34;Delete Selected Records?&#34;,
                                  parent=self.parentframe)
        if n == True:
            rows = self.multiplerowlist
            self.model.deleteRows(rows)
            self.clearSelected()
            self.setSelectedRow(0)
            self.redrawTable()
    else:
        n = messagebox.askyesno(&#34;Delete&#34;,
                                  &#34;Delete This Record?&#34;,
                                  parent=self.parentframe)
        if n:
            row = self.getSelectedRow()
            self.model.deleteRow(row)
            self.setSelectedRow(row-1)
            self.clearSelected()
            self.redrawTable()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.doFilter"><code class="name flex">
<span>def <span class="ident">doFilter</span></span>(<span>self, event=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Filter the table display by some column values.
We simply pass the model search function to the the filtering
class and that handles everything else.
See filtering frame class for how searching is done.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def doFilter(self, event=None):
    &#34;&#34;&#34;Filter the table display by some column values.
    We simply pass the model search function to the the filtering
    class and that handles everything else.
    See filtering frame class for how searching is done.
    &#34;&#34;&#34;
    if self.model==None:
        return
    names = self.filterframe.doFiltering(searchfunc=self.model.filterBy)
    #create a list of filtered recs
    self.model.filteredrecs = names
    self.filtered = True
    self.redrawTable()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.do_bindings"><code class="name flex">
<span>def <span class="ident">do_bindings</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Bind keys and mouse clicks, this can be overriden</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def do_bindings(self):
    &#34;&#34;&#34;Bind keys and mouse clicks, this can be overriden&#34;&#34;&#34;
    self.bind(&#34;&lt;Button-1&gt;&#34;,self.handle_left_click)
    self.bind(&#34;&lt;Double-Button-1&gt;&#34;,self.handle_double_click)
    self.bind(&#34;&lt;Control-Button-1&gt;&#34;, self.handle_left_ctrl_click)
    self.bind(&#34;&lt;Shift-Button-1&gt;&#34;, self.handle_left_shift_click)

    self.bind(&#34;&lt;ButtonRelease-1&gt;&#34;, self.handle_left_release)
    if self.ostyp==&#39;mac&#39;:
        #For mac we bind Shift, left-click to right click
        self.bind(&#34;&lt;Button-2&gt;&#34;, self.handle_right_click)
        self.bind(&#39;&lt;Shift-Button-1&gt;&#39;,self.handle_right_click)
    else:
        self.bind(&#34;&lt;Button-3&gt;&#34;, self.handle_right_click)

    self.bind(&#39;&lt;B1-Motion&gt;&#39;, self.handle_mouse_drag)
    self.bind(&#39;&lt;Motion&gt;&#39;, self.handle_motion)

    self.bind_all(&#34;&lt;Control-x&gt;&#34;, self.deleteRow)
    self.bind_all(&#34;&lt;Control-n&gt;&#34;, self.addRow)
    self.bind_all(&#34;&lt;Delete&gt;&#34;, self.clearData)
    self.bind_all(&#34;&lt;Control-v&gt;&#34;, self.paste)

    #if not hasattr(self,&#39;parentapp&#39;):
    #    self.parentapp = self.parentframe

    self.parentframe.master.bind_all(&#34;&lt;Right&gt;&#34;, self.handle_arrow_keys)
    self.parentframe.master.bind_all(&#34;&lt;Left&gt;&#34;, self.handle_arrow_keys)
    self.parentframe.master.bind_all(&#34;&lt;Up&gt;&#34;, self.handle_arrow_keys)
    self.parentframe.master.bind_all(&#34;&lt;Down&gt;&#34;, self.handle_arrow_keys)
    self.parentframe.master.bind_all(&#34;&lt;KP_8&gt;&#34;, self.handle_arrow_keys)
    self.parentframe.master.bind_all(&#34;&lt;Return&gt;&#34;, self.handle_arrow_keys)
    self.parentframe.master.bind_all(&#34;&lt;Tab&gt;&#34;, self.handle_arrow_keys)
    #if &#39;windows&#39; in self.platform:
    self.bind(&#34;&lt;MouseWheel&gt;&#34;, self.mouse_wheel)
    self.bind(&#39;&lt;Button-4&gt;&#39;, self.mouse_wheel)
    self.bind(&#39;&lt;Button-5&gt;&#39;, self.mouse_wheel)
    self.focus_set()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.drawCellEntry"><code class="name flex">
<span>def <span class="ident">drawCellEntry</span></span>(<span>self, row, col, text=None)</span>
</code></dt>
<dd>
<section class="desc"><p>When the user single/double clicks on a text/number cell, bring up entry window</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def drawCellEntry(self, row, col, text=None):
    &#34;&#34;&#34;When the user single/double clicks on a text/number cell, bring up entry window&#34;&#34;&#34;

    if self.read_only == True:
        return
    #absrow = self.get_AbsoluteRow(row)
    h=self.rowheight
    model=self.getModel()
    cellvalue = self.model.getCellRecord(row, col)
    if Formula.isFormula(cellvalue):
        return
    else:
        text = self.model.getValueAt(row, col)
    x1,y1,x2,y2 = self.getCellCoords(row,col)
    w=x2-x1
    #Draw an entry window
    txtvar = StringVar()
    txtvar.set(text)
    def callback(e):
        value = txtvar.get()
        if value == &#39;=&#39;:
            #do a dialog that gets the formula into a text area
            #then they can click on the cells they want
            #when done the user presses ok and its entered into the cell
            self.cellentry.destroy()
            #its all done here..
            self.formula_Dialog(row, col)
            return

        coltype = self.model.getColumnType(col)
        if coltype == &#39;number&#39;:
            sta = self.checkDataEntry(e)
            if sta == 1:
                model.setValueAt(value,row,col)
        elif coltype == &#39;text&#39;:
            model.setValueAt(value,row,col)

        color = self.model.getColorAt(row,col,&#39;fg&#39;)
        self.drawText(row, col, value, color, align=self.align)
        if e.keysym==&#39;Return&#39;:
            self.delete(&#39;entry&#39;)
            #self.drawRect(row, col)
            #self.gotonextCell(e)
        return

    self.cellentry=Entry(self.parentframe,width=20,
                    textvariable=txtvar,
                    #bg=self.entrybackgr,
                    #relief=FLAT,
                    takefocus=1,
                    font=self.thefont)
    self.cellentry.icursor(END)
    self.cellentry.bind(&#39;&lt;Return&gt;&#39;, callback)
    self.cellentry.bind(&#39;&lt;KeyRelease&gt;&#39;, callback)
    self.cellentry.focus_set()
    self.entrywin=self.create_window(x1+self.inset,y1+self.inset,
                            width=w-self.inset*2,height=h-self.inset*2,
                            window=self.cellentry,anchor=&#39;nw&#39;,
                            tag=&#39;entry&#39;)

    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.drawGrid"><code class="name flex">
<span>def <span class="ident">drawGrid</span></span>(<span>self, startrow, endrow)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw the table grid lines</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def drawGrid(self, startrow, endrow):
    &#34;&#34;&#34;Draw the table grid lines&#34;&#34;&#34;
    self.delete(&#39;gridline&#39;,&#39;text&#39;)
    rows=len(self.rowrange)
    cols=self.cols
    w = self.cellwidth
    h = self.rowheight
    x_start=self.x_start
    y_start=self.y_start
    x_pos=x_start

    if self.vertlines==1:
        for col in range(cols+1):
            x=self.col_positions[col]
            self.create_line(x,y_start,x,y_start+rows*h, tag=&#39;gridline&#39;,
                                 fill=self.grid_color, width=self.linewidth)
    if self.horizlines==1:
        for row in range(startrow, endrow+1):
            y_pos=y_start+row*h
            self.create_line(x_start,y_pos,self.tablewidth,y_pos, tag=&#39;gridline&#39;,
                                fill=self.grid_color, width=self.linewidth)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.drawMultipleCells"><code class="name flex">
<span>def <span class="ident">drawMultipleCells</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw an outline box for multiple cell selection</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def drawMultipleCells(self):
    &#34;&#34;&#34;Draw an outline box for multiple cell selection&#34;&#34;&#34;

    self.delete(&#39;multicellrect&#39;)
    rows = self.multiplerowlist
    cols = self.multiplecollist
    w=2
    x1,y1,a,b = self.getCellCoords(rows[0],cols[0])
    c,d,x2,y2 = self.getCellCoords(rows[len(rows)-1],cols[len(cols)-1])
    rect = self.create_rectangle(x1+w/2,y1+w/2,x2,y2,
                         outline=&#39;blue&#39;,width=w,activefill=&#39;red&#39;,activestipple=&#39;gray25&#39;,
                         tag=&#39;multicellrect&#39;)

    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.drawMultipleRows"><code class="name flex">
<span>def <span class="ident">drawMultipleRows</span></span>(<span>self, rowlist)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw more than one row selection</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def drawMultipleRows(self, rowlist):
    &#34;&#34;&#34;Draw more than one row selection&#34;&#34;&#34;

    self.delete(&#39;multiplesel&#39;)
    for r in rowlist:
        if r not in self.visiblerows or r &gt; self.rows-1:
            continue
        x1,y1,x2,y2 = self.getCellCoords(r,0)
        x2 = self.tablewidth
        rect = self.create_rectangle(x1,y1,x2,y2,
                                  fill=self.multipleselectioncolor,
                                  outline=self.rowselectedcolor,
                                  tag=(&#39;multiplesel&#39;,&#39;rowrect&#39;))
    self.lower(&#39;multiplesel&#39;)
    self.lower(&#39;fillrect&#39;)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.drawRect"><code class="name flex">
<span>def <span class="ident">drawRect</span></span>(<span>self, row, col, color=None, tag=None, delete=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Cell is colored</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def drawRect(self, row, col, color=None, tag=None, delete=1):
    &#34;&#34;&#34;Cell is colored&#34;&#34;&#34;
    if delete==1:
        self.delete(&#39;cellbg&#39;+str(row)+str(col))
    if color==None or color==self.cellbackgr:
        return
    else:
        bg=color
    if tag==None:
        recttag=&#39;fillrect&#39;
    else:
        recttag=tag
    w=1
    x1,y1,x2,y2 = self.getCellCoords(row,col)
    rect = self.create_rectangle(x1+w/2,y1+w/2,x2-w/2,y2-w/2,
                              fill=bg,
                              outline=bg,
                              width=w,
                              tag=(recttag,&#39;cellbg&#39;+str(row)+str(col)))
    self.lower(recttag)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.drawRowHeader"><code class="name flex">
<span>def <span class="ident">drawRowHeader</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>User has clicked to select a cell</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def drawRowHeader(self):
    &#34;&#34;&#34;User has clicked to select a cell&#34;&#34;&#34;
    self.delete(&#39;rowheader&#39;)
    x_start=self.x_start
    y_start=self.y_start
    h=self.rowheight
    rowpos=0
    for row in self.rowrange:
        x1,y1,x2,y2 = self.getCellCoords(rowpos,0)
        self.create_rectangle(0,y1,x_start-2,y2,
                                  fill=&#39;gray75&#39;,
                                  outline=&#39;white&#39;,
                                  width=1,
                                  tag=&#39;rowheader&#39;)
        self.create_text(x_start/2,y1+h/2,
                                  text=row+1,
                                  fill=&#39;black&#39;,
                                  font=self.thefont,
                                  tag=&#39;rowheader&#39;)
        rowpos+=1
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.drawSelectedCol"><code class="name flex">
<span>def <span class="ident">drawSelectedCol</span></span>(<span>self, col=None, delete=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw an outline rect fot the current column selection</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def drawSelectedCol(self, col=None, delete=1):
    &#34;&#34;&#34;Draw an outline rect fot the current column selection&#34;&#34;&#34;

    if delete == 1:
        self.delete(&#39;colrect&#39;)
    if col == None:
        col=self.currentcol
    w=2
    x1,y1,x2,y2 = self.getCellCoords(0,col)
    y2 = self.rows * self.rowheight
    rect = self.create_rectangle(x1+w/2,y1+w/2,x2,y2+w/2,
                                 outline=&#39;blue&#39;,width=w,
                                 tag=&#39;colrect&#39;)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.drawSelectedRect"><code class="name flex">
<span>def <span class="ident">drawSelectedRect</span></span>(<span>self, row, col, color=None)</span>
</code></dt>
<dd>
<section class="desc"><p>User has clicked to select a cell</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def drawSelectedRect(self, row, col, color=None):
    &#34;&#34;&#34;User has clicked to select a cell&#34;&#34;&#34;
    if col &gt;= self.cols:
        return
    self.delete(&#39;currentrect&#39;)
    bg = self.selectedcolor
    if color == None:
        color = &#39;gray25&#39;
    w=3
    x1,y1,x2,y2 = self.getCellCoords(row,col)
    rect = self.create_rectangle(x1+w/2,y1+w/2,x2-w/2,y2-w/2,
                              fill=bg,
                              outline=color,
                              width=w,
                              stipple=&#39;gray50&#39;,
                              tag=&#39;currentrect&#39;)
    #self.lower(&#39;currentrect&#39;)
    #raise text above all
    self.lift(&#39;celltext&#39;+str(col)+&#39;_&#39;+str(row))
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.drawSelectedRow"><code class="name flex">
<span>def <span class="ident">drawSelectedRow</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw the highlight rect for the currently selected row</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def drawSelectedRow(self):
    &#34;&#34;&#34;Draw the highlight rect for the currently selected row&#34;&#34;&#34;

    self.delete(&#39;rowrect&#39;)
    row = self.currentrow
    x1,y1,x2,y2 = self.getCellCoords(row,0)
    x2 = self.tablewidth
    rect = self.create_rectangle(x1,y1,x2,y2,
                              fill=self.rowselectedcolor,
                              outline=self.rowselectedcolor,
                              tag=&#39;rowrect&#39;)
    self.lower(&#39;rowrect&#39;)
    self.lower(&#39;fillrect&#39;)
    self.tablerowheader.drawSelectedRows(self.currentrow)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.drawText"><code class="name flex">
<span>def <span class="ident">drawText</span></span>(<span>self, row, col, celltxt, fgcolor=None, align=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw the text inside a cell area</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def drawText(self, row, col, celltxt, fgcolor=None, align=None):
    &#34;&#34;&#34;Draw the text inside a cell area&#34;&#34;&#34;

    self.delete(&#39;celltext&#39;+str(col)+&#39;_&#39;+str(row))
    h=self.rowheight
    x1,y1,x2,y2 = self.getCellCoords(row,col)
    w=x2-x1
    wrap = False
    pad=5
    # If celltxt is a number then we make it a string
    if type(celltxt) is float or type(celltxt) is int:
        celltxt=str(celltxt)
    length = len(celltxt)
    if length == 0:
        return
    #if cell width is less than x, print nothing
    if w&lt;=10:
        return

    if fgcolor == None or fgcolor == &#34;None&#34;:
        fgcolor = &#39;black&#39;
    if align == None:
        align = &#39;w&#39;
    if align == &#39;w&#39;:
        x1 = x1-w/2+pad
    elif align == &#39;e&#39;:
        x1 = x1+w/2-pad

    if w &lt; 18:
        celltxt = &#39;.&#39;
    else:
        fontsize = self.fontsize
        colname = self.model.getColumnName(col)
        #scaling between canvas and text normalised to about font 14
        scale = 8.5 * float(fontsize)/12
        size = length * scale
        if size &gt; w:
            newlength = w / scale
            #print w, size, length, newlength
            celltxt = celltxt[0:int(math.floor(newlength))]

    #if celltxt is dict then we are drawing a hyperlink
    if self.isLink(celltxt) == True:
        haslink=0
        linktext=celltxt[&#39;text&#39;]
        if len(linktext) &gt; w/scale or w&lt;28:
            linktext=linktext[0:int(w/fontsize*1.2)-2]+&#39;..&#39;
        if celltxt[&#39;link&#39;]!=None and celltxt[&#39;link&#39;]!=&#39;&#39;:
            f,s = self.thefont
            linkfont = (f, s, &#39;underline&#39;)
            linkcolor=&#39;blue&#39;
            haslink=1
        else:
            linkfont = self.thefont
            linkcolor=fgcolor

        rect = self.create_text(x1+w/2,y1+h/2,
                                  text=linktext,
                                  fill=linkcolor,
                                  font=linkfont,
                                  tag=(&#39;text&#39;,&#39;hlink&#39;,&#39;celltext&#39;+str(col)+&#39;_&#39;+str(row)))
        if haslink == 1:
            self.tag_bind(rect, &#39;&lt;Double-Button-1&gt;&#39;, self.check_hyperlink)

    #just normal text
    else:
        rect = self.create_text(x1+w/2,y1+h/2,
                                  text=celltxt,
                                  fill=fgcolor,
                                  font=self.thefont,
                                  anchor=align,
                                  tag=(&#39;text&#39;,&#39;celltext&#39;+str(col)+&#39;_&#39;+str(row)))
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.drawTooltip"><code class="name flex">
<span>def <span class="ident">drawTooltip</span></span>(<span>self, row, col)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw a tooltip showing contents of cell</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def drawTooltip(self, row, col):
    &#34;&#34;&#34;Draw a tooltip showing contents of cell&#34;&#34;&#34;

    x1,y1,x2,y2 = self.getCellCoords(row,col)
    w=x2-x1
    text = self.model.getValueAt(row,col)
    if isinstance(text, dict):
        if &#39;link&#39; in text:
            text = text[&#39;link&#39;]

    # If text is a number we make it a string
    if type(text) is float or type is int:
        text = str(text)
    if text == None or text == &#39;&#39; or len(str(text))&lt;=10:
        return

    sfont = font.Font(family=&#39;Arial&#39;, size=12,weight=&#39;bold&#39;)
    obj = self.create_text(x1+w/1.5,y2,text=text,
                            anchor=&#39;w&#39;,
                            font=sfont,tag=&#39;tooltip&#39;)

    box = self.bbox(obj)
    x1=box[0]-1
    y1=box[1]-1
    x2=box[2]+1
    y2=box[3]+1

    rect = self.create_rectangle(x1+1,y1+1,x2+1,y2+1,tag=&#39;tooltip&#39;,fill=&#39;black&#39;)
    rect2 = self.create_rectangle(x1,y1,x2,y2,tag=&#39;tooltip&#39;,fill=&#39;lightyellow&#39;)
    self.lift(obj)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.exportTable"><code class="name flex">
<span>def <span class="ident">exportTable</span></span>(<span>self, filename=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Do a simple export of the cell contents to csv</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def exportTable(self, filename=None):
    &#34;&#34;&#34;Do a simple export of the cell contents to csv&#34;&#34;&#34;

    from .Tables_IO import TableExporter
    exporter = TableExporter()
    exporter.ExportTableData(self)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.fillAcross"><code class="name flex">
<span>def <span class="ident">fillAcross</span></span>(<span>self, collist, rowlist)</span>
</code></dt>
<dd>
<section class="desc"><p>Fill across a row, or multiple rows</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fillAcross(self, collist, rowlist):
    &#34;&#34;&#34;Fill across a row, or multiple rows&#34;&#34;&#34;
    model = self.model
    #row = self.currentrow
    #absrow  = self.get_AbsoluteRow(collist[0])
    frstcol = collist[0]
    collist.remove(frstcol)

    for row in rowlist:
        #absr = self.get_AbsoluteRow(row)
        val = self.model.getCellRecord(absr, frstcol)
        f=val     #formula to copy
        i=1
        for c in collist:
            if Formula.isFormula(f):
                newval = model.copyFormula(f, r, c, offset=i, dim=&#39;x&#39;)
                model.setFormulaAt(newval, r, c)
            else:
                model.setValueAt(val, r, c)
            i+=1
    self.redrawTable()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.fillDown"><code class="name flex">
<span>def <span class="ident">fillDown</span></span>(<span>self, rowlist, collist)</span>
</code></dt>
<dd>
<section class="desc"><p>Fill down a column, or multiple columns</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fillDown(self, rowlist, collist):
    &#34;&#34;&#34;Fill down a column, or multiple columns&#34;&#34;&#34;
    model = self.model
    #absrow  = self.get_AbsoluteRow(rowlist[0])
    #remove first element as we don&#39;t want to overwrite it
    rowlist.remove(rowlist[0])

    #if this is a formula, we have to treat it specially
    for col in collist:
        val = self.model.getCellRecord(row, col)
        f=val #formula to copy
        i=1
        for r in rowlist:
            #absr = self.get_AbsoluteRow(r)
            if Formula.isFormula(f):
                newval = model.copyFormula(f, r, col, offset=i)
                model.setFormulaAt(newval, r, col)
            else:
                model.setValueAt(val, r, col)
            #print &#39;setting&#39;, val, &#39;at row&#39;, r
            i+=1

    self.redrawTable()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.findValue"><code class="name flex">
<span>def <span class="ident">findValue</span></span>(<span>self, searchstring=None, findagain=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the row/col for the input value</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def findValue(self, searchstring=None, findagain=None):
    &#34;&#34;&#34;Return the row/col for the input value&#34;&#34;&#34;

    if searchstring == None:
        searchstring = simpledialog.askstring(&#34;Search table.&#34;,
                                           &#34;Enter search value&#34;,
                                           parent=self.parentframe)
    found=0
    if findagain == None or not hasattr(self,&#39;foundlist&#39;):
        self.foundlist=[]
    if self.model!=None:
        for row in range(self.rows):
            for col in range(self.cols):
                text = str(self.model.getValueAt(row,col))
                if text==&#39;&#39; or text==None:
                    continue
                cell=row,col
                if findagain == 1 and cell in self.foundlist:
                    continue
                if text.lower().find(searchstring.lower())!=-1:
                    print (&#39;found in&#39;,row,col)
                    found=1
                    #highlight cell
                    self.delete(&#39;searchrect&#39;)
                    self.drawRect(row, col, color=&#39;red&#39;, tag=&#39;searchrect&#39;, delete=0)
                    self.lift(&#39;searchrect&#39;)
                    self.lift(&#39;celltext&#39;+str(col)+&#39;_&#39;+str(row))
                    #add row/col to foundlist
                    self.foundlist.append(cell)
                    #need to scroll to centre the cell here..
                    x,y = self.getCanvasPos(row, col)
                    self.xview(&#39;moveto&#39;, x)
                    self.yview(&#39;moveto&#39;, y)
                    self.tablecolheader.xview(&#39;moveto&#39;, x)
                    self.tablerowheader.yview(&#39;moveto&#39;, y)
                    return row, col
    if found==0:
        self.delete(&#39;searchrect&#39;)
        print (&#39;nothing found&#39;)
        return None</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.formula_Dialog"><code class="name flex">
<span>def <span class="ident">formula_Dialog</span></span>(<span>self, row, col, currformula=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Formula dialog</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def formula_Dialog(self, row, col, currformula=None):
    &#34;&#34;&#34;Formula dialog&#34;&#34;&#34;
    self.mode = &#39;formula&#39;
    print (self.mode)
    x1,y1,x2,y2 = self.getCellCoords(row,col)
    w=300
    h=h=self.rowheight * 3
    def close():
        if hasattr(self,&#39;formulaWin&#39;):
            self.delete(&#39;formulabox&#39;)
        self.mode = &#39;normal&#39;
    def calculate():
        #get text area contents and do formula
        f = self.formulaText.get(1.0, END)
        f = f.strip(&#39;\n&#39;)
        self.model.setFormulaAt(f,row,col)
        value = self.model.doFormula(f)
        color = self.model.getColorAt(row,col,&#39;fg&#39;)
        self.drawText(row, col, value, color)
        close()
        self.mode = &#39;normal&#39;
        return
    def clear():
        self.formulaText.delete(1.0, END)

    self.formulaFrame = Frame(width=w,height=h,bd=3)
    self.formulaText = Text(self.formulaFrame, width=30, height=8, bg=&#39;white&#39;,relief=GROOVE)
    self.formulaText.pack(side=LEFT,padx=2,pady=2)
    if currformula != None:
        self.formulaText.insert(END, Formula.getFormula(currformula))
    cancelbutton=Button(self.formulaFrame, text=&#39;Cancel&#39;,
                        bg=&#39;#99ccff&#39;,command=close)
    cancelbutton.pack(fill=BOTH,padx=2,pady=2)
    donebutton=Button(self.formulaFrame, text=&#39;Done&#39;,
                      bg=&#39;#99ccff&#39;,command=calculate)
    donebutton.pack(fill=BOTH,padx=2,pady=2)
    &#39;&#39;&#39;clrbutton=Button(self.formulaFrame, text=&#39;Clear&#39;,
                       bg=&#39;#99ccff&#39;,command=clear)
    clrbutton.pack(fill=BOTH,padx=2,pady=2) &#39;&#39;&#39;
    #add to canvas
    self.formulaWin = self.create_window(x1+self.inset,y1+self.inset,
                            width=w,height=h,
                            window=self.formulaFrame,anchor=&#39;nw&#39;,
                            tag=&#39;formulabox&#39;)
    self.formulaText.focus_set()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getCanvasPos"><code class="name flex">
<span>def <span class="ident">getCanvasPos</span></span>(<span>self, row, col)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the cell x-y coords as a fraction of canvas size</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getCanvasPos(self, row, col):
    &#34;&#34;&#34;Get the cell x-y coords as a fraction of canvas size&#34;&#34;&#34;
    if self.rows==0:
        return None, None
    x1,y1,x2,y2 = self.getCellCoords(row,col)
    cx=float(x1)/self.tablewidth
    cy=float(y1)/(self.rows*self.rowheight)
    return cx, cy</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getCellCoords"><code class="name flex">
<span>def <span class="ident">getCellCoords</span></span>(<span>self, row, col)</span>
</code></dt>
<dd>
<section class="desc"><p>Get x-y coordinates to drawing a cell in a given row/col</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getCellCoords(self, row, col):
    &#34;&#34;&#34;Get x-y coordinates to drawing a cell in a given row/col&#34;&#34;&#34;
    colname=self.model.getColumnName(col)
    if colname in self.model.columnwidths:
        w=self.model.columnwidths[colname]
    else:
        w=self.cellwidth
    h=self.rowheight
    x_start=self.x_start
    y_start=self.y_start

    #get nearest rect co-ords for that row/col
    #x1=x_start+w*col
    x1=self.col_positions[col]
    y1=y_start+h*row
    x2=x1+w
    y2=y1+h
    return x1,y1,x2,y2</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getColPosition"><code class="name flex">
<span>def <span class="ident">getColPosition</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<section class="desc"><p>Get current col from canvas position</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getColPosition(self, x):
    &#34;&#34;&#34;Get current col from canvas position&#34;&#34;&#34;

    x_start = self.x_start
    w = self.cellwidth
    i=0
    col=0
    for c in self.col_positions:
        col = i
        if c+w&gt;=x:
            break
        i+=1
    return col</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getFonts"><code class="name flex">
<span>def <span class="ident">getFonts</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getFonts(self):
    fonts = set(list(font.families()))
    fonts = sorted(list(fonts))
    return fonts</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getGeometry"><code class="name flex">
<span>def <span class="ident">getGeometry</span></span>(<span>self, frame)</span>
</code></dt>
<dd>
<section class="desc"><p>Get frame geometry</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getGeometry(self, frame):
    &#34;&#34;&#34;Get frame geometry&#34;&#34;&#34;
    return frame.winfo_rootx(), frame.winfo_rooty(), frame.winfo_width(), frame.winfo_height()</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getModel"><code class="name flex">
<span>def <span class="ident">getModel</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the current table model</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getModel(self):
    &#34;&#34;&#34;Get the current table model&#34;&#34;&#34;
    return self.model</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getRecordInfo"><code class="name flex">
<span>def <span class="ident">getRecordInfo</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<section class="desc"><p>Show the record for this row</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getRecordInfo(self, row):
    &#34;&#34;&#34;Show the record for this row&#34;&#34;&#34;

    model = self.model
    #We need a custom dialog for allowing field entries here
    #absrow = self.get_AbsoluteRow(row)
    d = RecordViewDialog(title=&#34;Record Details&#34;,
                              parent=self.parentframe, table=self, row=row)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getRowPosition"><code class="name flex">
<span>def <span class="ident">getRowPosition</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<section class="desc"><p>Get current row from canvas position</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getRowPosition(self, y):
    &#34;&#34;&#34;Get current row from canvas position&#34;&#34;&#34;

    h = self.rowheight
    y_start = self.y_start
    row = (int(y)-y_start)/h
    if row &lt; 0:
        return 0
    if row &gt; self.rows:
        row = self.rows
    return row</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getSelectedColumn"><code class="name flex">
<span>def <span class="ident">getSelectedColumn</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get currently selected column</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getSelectedColumn(self):
    &#34;&#34;&#34;Get currently selected column&#34;&#34;&#34;
    return self.currentcol</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getSelectedRow"><code class="name flex">
<span>def <span class="ident">getSelectedRow</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get currently selected row</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getSelectedRow(self):
    &#34;&#34;&#34;Get currently selected row&#34;&#34;&#34;
    return self.currentrow</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getSelectionValues"><code class="name flex">
<span>def <span class="ident">getSelectionValues</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get values for current multiple cell selection</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getSelectionValues(self):
    &#34;&#34;&#34;Get values for current multiple cell selection&#34;&#34;&#34;
    if len(self.multiplerowlist) == 0 or len(self.multiplecollist) == 0:
        return None
    rows = self.multiplerowlist
    cols = self.multiplecollist
    model = self.model
    if len(rows)&lt;1 or len(cols)&lt;1:
        return None
    #if only one row selected we plot whole col
    if len(rows) == 1:
        rows = self.rowrange
    lists = []

    for c in cols:
        x=[]
        for r in rows:
            #absr = self.get_AbsoluteRow(r)
            val = model.getValueAt(r,c)
            if val == None or val == &#39;&#39;:
                continue
            x.append(val)
        lists.append(x)
    return lists</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getVisibleCols"><code class="name flex">
<span>def <span class="ident">getVisibleCols</span></span>(<span>self, x1, x2)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the visible column range</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getVisibleCols(self, x1, x2):
    &#34;&#34;&#34;Get the visible column range&#34;&#34;&#34;

    start = self.getColPosition(x1)
    end = self.getColPosition(x2)+1
    if end &gt; self.cols:
        end = self.cols
    return start, end</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getVisibleRegion"><code class="name flex">
<span>def <span class="ident">getVisibleRegion</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get visible region of table to display</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getVisibleRegion(self):
    &#34;&#34;&#34;Get visible region of table to display&#34;&#34;&#34;

    x1, y1 = self.canvasx(0), self.canvasy(0)
    #w, h = self.winfo_width(), self.winfo_height()
    w,h= self.master.winfo_width(), self.master.winfo_height()
    if w &lt;= 1.0 or h &lt;= 1.0:
        w, h = self.master.winfo_width(), self.master.winfo_height()
    x2, y2 = self.canvasx(w), self.canvasy(h)
    return x1, y1, x2, y2</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getVisibleRows"><code class="name flex">
<span>def <span class="ident">getVisibleRows</span></span>(<span>self, y1, y2)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the visible row range</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getVisibleRows(self, y1, y2):
    &#34;&#34;&#34;Get the visible row range&#34;&#34;&#34;

    start = int(self.getRowPosition(y1))
    end = int(self.getRowPosition(y2))+1
    if end &gt; self.rows:
        end = self.rows
    return start, end</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.get_col_clicked"><code class="name flex">
<span>def <span class="ident">get_col_clicked</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>get col where event on canvas occurs</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_col_clicked(self,event):
    &#34;&#34;&#34;get col where event on canvas occurs&#34;&#34;&#34;

    w=self.cellwidth
    x = int(self.canvasx(event.x))
    x_start=self.x_start
    #print self.col_positions
    for colpos in self.col_positions:
        try:
            nextpos=self.col_positions[self.col_positions.index(colpos)+1]
        except:
            nextpos=self.tablewidth
        if x &gt; colpos and x &lt;= nextpos:
            #print &#39;x=&#39;, x, &#39;colpos&#39;, colpos, self.col_positions.index(colpos)
            return self.col_positions.index(colpos)
        else:
            #print None
            pass</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.get_currentColName"><code class="name flex">
<span>def <span class="ident">get_currentColName</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the currently selected record name</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_currentColName(self):
    &#34;&#34;&#34;Get the currently selected record name&#34;&#34;&#34;

    colname = self.mo(self.currentcol)
    return colname</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.get_currentRecCol"><code class="name flex">
<span>def <span class="ident">get_currentRecCol</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the clicked rec and col names as a tuple</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_currentRecCol(self):
    &#34;&#34;&#34;Get the clicked rec and col names as a tuple&#34;&#34;&#34;

    recname = self.get_currentRecordName()
    colname = self.get_currentColName()
    return (recname, colname)</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.get_currentRecord"><code class="name flex">
<span>def <span class="ident">get_currentRecord</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the currently selected record</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_currentRecord(self):
    &#34;&#34;&#34;Get the currently selected record&#34;&#34;&#34;

    rec = self.model.getRecordAtRow(self.currentrow)
    return rec</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.get_currentRecordName"><code class="name flex">
<span>def <span class="ident">get_currentRecordName</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the currently selected record name</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_currentRecordName(self):
    &#34;&#34;&#34;Get the currently selected record name&#34;&#34;&#34;

    recname = self.model.getRecName(self.currentrow)
    return recname</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.get_row_clicked"><code class="name flex">
<span>def <span class="ident">get_row_clicked</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>get row where event on canvas occurs</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_row_clicked(self, event):
    &#34;&#34;&#34;get row where event on canvas occurs&#34;&#34;&#34;

    h=self.rowheight
    #get coord on canvas, not window, need this if scrolling
    y = int(self.canvasy(event.y))
    y_start=self.y_start
    rowc = int((int(y)-y_start)/h)
    #rowc = math.floor(rowc)
    #print &#39;event.y&#39;,event.y, &#39;y&#39;,y
    #print &#39;rowclicked&#39;, rowc
    return rowc</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.get_selectedRecordNames"><code class="name flex">
<span>def <span class="ident">get_selectedRecordNames</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a list of the current multiple selection, if any</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_selectedRecordNames(self):
    &#34;&#34;&#34;Get a list of the current multiple selection, if any&#34;&#34;&#34;

    recnames=[]
    for row in self.multiplerowlist:
        recnames.append(self.model.getRecName(row))
    return recnames</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getaColor"><code class="name flex">
<span>def <span class="ident">getaColor</span></span>(<span>self, oldcolor)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getaColor(self, oldcolor):

    ctuple, newcolor = tkColorChooser.askcolor(title=&#39;pick a color&#39;, initialcolor=oldcolor,
                                               parent=self.parentframe)
    if ctuple == None:
        return None
    return str(newcolor)</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.getplotlabels"><code class="name flex">
<span>def <span class="ident">getplotlabels</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get labels for plot series from col labels</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getplotlabels(self):
    &#34;&#34;&#34;Get labels for plot series from col labels&#34;&#34;&#34;
    pltlabels = []
    for col in self.multiplecollist:
        pltlabels.append(self.model.getColumnLabel(col))
    return pltlabels</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.gotonextCell"><code class="name flex">
<span>def <span class="ident">gotonextCell</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Move highlighted cell to next cell in row or a new col</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def gotonextCell(self, event):
    &#34;&#34;&#34;Move highlighted cell to next cell in row or a new col&#34;&#34;&#34;
    #print &#39;next&#39;
    if hasattr(self, &#39;cellentry&#39;):
        self.cellentry.destroy()
    self.currentcol=self.currentcol+1
    if self.currentcol &gt;= self.cols-1:
        self.currentrow  = self.currentrow +1
        self.currentcol = self.currentcol+1
    self.drawSelectedRect(self.currentrow, self.currentcol)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.gotonextRow"><code class="name flex">
<span>def <span class="ident">gotonextRow</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Programmatically set next row - eg. for button events</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def gotonextRow(self):
    &#34;&#34;&#34;Programmatically set next row - eg. for button events&#34;&#34;&#34;
    self.clearSelected()
    current = self.getSelectedRow()
    self.setSelectedRow(current+1)
    self.startrow = current+1
    self.endrow = current+1
    #reset multiple selection list
    self.multiplerowlist=[]
    self.multiplerowlist.append(self.currentrow)
    self.drawSelectedRect(self.currentrow, self.currentcol)
    self.drawSelectedRow()
    coltype = self.model.getColumnType(self.currentcol)
    if coltype == &#39;text&#39; or coltype == &#39;number&#39;:
        self.drawCellEntry(self.currentrow, self.currentcol)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.gotoprevRow"><code class="name flex">
<span>def <span class="ident">gotoprevRow</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Programmatically set previous row - eg. for button events</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def gotoprevRow(self):
    &#34;&#34;&#34;Programmatically set previous row - eg. for button events&#34;&#34;&#34;
    self.clearSelected()
    current = self.getSelectedRow()
    self.setSelectedRow(current-1)
    self.startrow = current-1
    self.endrow = current-1
    #reset multiple selection list
    self.multiplerowlist=[]
    self.multiplerowlist.append(self.currentrow)
    self.drawSelectedRect(self.currentrow, self.currentcol)
    self.drawSelectedRow()
    coltype = self.model.getColumnType(self.currentcol)
    if coltype == &#39;text&#39; or coltype == &#39;number&#39;:
        self.drawCellEntry(self.currentrow, self.currentcol)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.handleFormulaClick"><code class="name flex">
<span>def <span class="ident">handleFormulaClick</span></span>(<span>self, row, col)</span>
</code></dt>
<dd>
<section class="desc"><p>Do a dialog for cell formula entry</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handleFormulaClick(self, row, col):
    &#34;&#34;&#34;Do a dialog for cell formula entry&#34;&#34;&#34;

    model = self.getModel()
    cell = list(model.getRecColNames(row, col))
    #absrow = self.get_AbsoluteRow(row)
    self.formulaText.insert(END, str(cell))
    self.formulaText.focus_set()
    self.drawSelectedRect(row, col, color=&#39;red&#39;)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.handle_arrow_keys"><code class="name flex">
<span>def <span class="ident">handle_arrow_keys</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Handle arrow keys press</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_arrow_keys(self, event):
    &#34;&#34;&#34;Handle arrow keys press&#34;&#34;&#34;
    #print event.keysym

    row = self.get_row_clicked(event)
    col = self.get_col_clicked(event)
    x,y = self.getCanvasPos(self.currentrow, 0)
    if x == None:
        return

    if event.keysym == &#39;Up&#39;:
        if self.currentrow == 0:
            return
        else:
            self.currentrow  = self.currentrow -1
    elif event.keysym == &#39;Down&#39;:
        if self.currentrow &gt;= self.rows-1:
            return
        else:
            self.currentrow  = self.currentrow +1
    elif event.keysym == &#39;Right&#39; or event.keysym == &#39;Tab&#39;:
        if self.currentcol &gt;= self.cols-1:
            if self.currentrow &lt; self.rows-1:
                self.currentcol = 0
                self.currentrow  = self.currentrow +1
            else:
                return
        else:
            self.currentcol  = self.currentcol +1
    elif event.keysym == &#39;Left&#39;:
        if self.currentcol == 0:
            if self.currentrow == 0:
                return
            else:
                self.currentcol = self.cols-1
                self.currentrow = self.currentrow - 1
        else:
            self.currentcol  = self.currentcol -1
    self.drawSelectedRect(self.currentrow, self.currentcol)
    coltype = self.model.getColumnType(self.currentcol)
    if coltype == &#39;text&#39; or coltype == &#39;number&#39;:
        self.delete(&#39;entry&#39;)
        self.drawCellEntry(self.currentrow, self.currentcol)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.handle_double_click"><code class="name flex">
<span>def <span class="ident">handle_double_click</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Do double click stuff. Selected row/cols will already have
been set with single click binding</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_double_click(self, event):
    &#34;&#34;&#34;Do double click stuff. Selected row/cols will already have
       been set with single click binding&#34;&#34;&#34;

    &#39;&#39;&#39;row = self.get_row_clicked(event)
    col = self.get_col_clicked(event)
    model=self.getModel()
    cellvalue = model.getCellRecord(row, col)
    if Formula.isFormula(cellvalue):
        self.formula_Dialog(row, col, cellvalue)&#39;&#39;&#39;

    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.handle_left_click"><code class="name flex">
<span>def <span class="ident">handle_left_click</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Respond to a single press</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_left_click(self, event):
    &#34;&#34;&#34;Respond to a single press&#34;&#34;&#34;

    #which row and column is the click inside?
    self.clearSelected()
    self.allrows = False
    rowclicked = self.get_row_clicked(event)
    colclicked = self.get_col_clicked(event)
    self.focus_set()
    if self.mode == &#39;formula&#39;:
        self.handleFormulaClick(rowclicked, colclicked)
        return
    if hasattr(self, &#39;cellentry&#39;):
        self.cellentry.destroy()
    #ensure popup menus are removed if present
    if hasattr(self, &#39;rightmenu&#39;):
        self.rightmenu.destroy()
    if hasattr(self.tablecolheader, &#39;rightmenu&#39;):
        self.tablecolheader.rightmenu.destroy()

    self.startrow = rowclicked
    self.endrow = rowclicked
    self.startcol = colclicked
    self.endcol = colclicked
    #reset multiple selection list
    self.multiplerowlist=[]
    self.multiplerowlist.append(rowclicked)
    if rowclicked is None or colclicked is None:
        return
    if self.read_only is True:    
        return
    if 0 &lt;= rowclicked &lt; self.rows and 0 &lt;= colclicked &lt; self.cols:
        self.setSelectedRow(rowclicked)
        self.setSelectedCol(colclicked)
        self.drawSelectedRect(self.currentrow, self.currentcol)
        self.drawSelectedRow()
        self.tablerowheader.drawSelectedRows(rowclicked)
        coltype = self.model.getColumnType(colclicked)
        if coltype == &#39;text&#39; or coltype == &#39;number&#39;:
            self.drawCellEntry(rowclicked, colclicked)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.handle_left_ctrl_click"><code class="name flex">
<span>def <span class="ident">handle_left_ctrl_click</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Handle ctrl clicks for multiple row selections</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_left_ctrl_click(self, event):
    &#34;&#34;&#34;Handle ctrl clicks for multiple row selections&#34;&#34;&#34;
    rowclicked = self.get_row_clicked(event)
    colclicked = self.get_col_clicked(event)
    if 0 &lt;= rowclicked &lt; self.rows and 0 &lt;= colclicked &lt; self.cols:
        if rowclicked not in self.multiplerowlist:
            self.multiplerowlist.append(rowclicked)
        else:
            self.multiplerowlist.remove(rowclicked)
        self.drawMultipleRows(self.multiplerowlist)
        if colclicked not in self.multiplecollist:
            self.multiplecollist.append(colclicked)
        #print self.multiplecollist
        self.drawMultipleCells()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.handle_left_release"><code class="name flex">
<span>def <span class="ident">handle_left_release</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_left_release(self,event):
    self.endrow = self.get_row_clicked(event)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.handle_left_shift_click"><code class="name flex">
<span>def <span class="ident">handle_left_shift_click</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Handle shift click, for selecting multiple rows</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_left_shift_click(self, event):
    &#34;&#34;&#34;Handle shift click, for selecting multiple rows&#34;&#34;&#34;
    #Has same effect as mouse drag, so just use same method
    self.handle_mouse_drag(event)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.handle_motion"><code class="name flex">
<span>def <span class="ident">handle_motion</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Handle mouse motion on table</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_motion(self, event):
    &#34;&#34;&#34;Handle mouse motion on table&#34;&#34;&#34;

    self.delete(&#39;tooltip&#39;)
    row = self.get_row_clicked(event)
    col = self.get_col_clicked(event)
    if row == None or col == None:
        return
    if 0 &lt;= row &lt; self.rows and 0 &lt;= col &lt; self.cols:
        self.drawTooltip(row, col)

    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.handle_mouse_drag"><code class="name flex">
<span>def <span class="ident">handle_mouse_drag</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Handle mouse moved with button held down, multiple selections</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_mouse_drag(self, event):
    &#34;&#34;&#34;Handle mouse moved with button held down, multiple selections&#34;&#34;&#34;

    if hasattr(self, &#39;cellentry&#39;):
        self.cellentry.destroy()
    rowover = self.get_row_clicked(event)
    colover = self.get_col_clicked(event)
    if colover == None or rowover == None:
        return

    if rowover &gt;= self.rows or self.startrow &gt; self.rows:
        return
    else:
        self.endrow = rowover
    #do columns
    if colover &gt; self.cols or self.startcol &gt; self.cols:
        return
    else:
        self.endcol = colover
        if self.startcol is None or self.endcol is None:
            return
        if self.endcol &lt; self.startcol:
            self.multiplecollist = range(self.endcol, self.startcol+1)
        else:
            self.multiplecollist = range(self.startcol, self.endcol+1)
        #print self.multiplecollist
    #draw the selected rows
    if self.endrow != self.startrow:
        if self.endrow &lt; self.startrow:
            self.multiplerowlist = range(self.endrow, self.startrow+1)
        else:
            self.multiplerowlist = range(self.startrow, self.endrow+1)
        self.drawMultipleRows(self.multiplerowlist)
        self.tablerowheader.drawSelectedRows(self.multiplerowlist)
        #draw selected cells outline using row and col lists
        #print self.multiplerowlist
        self.drawMultipleCells()
    else:
        self.multiplerowlist = []
        self.multiplerowlist.append(self.currentrow)
        if len(self.multiplecollist) &gt;= 1:
            self.drawMultipleCells()
        self.delete(&#39;multiplesel&#39;)
    #print self.multiplerowlist
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.handle_right_click"><code class="name flex">
<span>def <span class="ident">handle_right_click</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>respond to a right click</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_right_click(self, event):
    &#34;&#34;&#34;respond to a right click&#34;&#34;&#34;

    if self.read_only is True:
        return
    self.delete(&#39;tooltip&#39;)
    self.tablerowheader.clearSelected()
    if hasattr(self, &#39;rightmenu&#39;):
        self.rightmenu.destroy()
    rowclicked = self.get_row_clicked(event)
    colclicked = self.get_col_clicked(event)
    if colclicked == None:
        self.rightmenu = self.popupMenu(event, outside=1)
        return

    if (rowclicked in self.multiplerowlist or self.allrows == True) and colclicked in self.multiplecollist:
        self.rightmenu = self.popupMenu(event, rows=self.multiplerowlist, cols=self.multiplecollist)
    else:
        if 0 &lt;= rowclicked &lt; self.rows and 0 &lt;= colclicked &lt; self.cols:
            self.clearSelected()
            self.allrows = False
            self.setSelectedRow(rowclicked)
            self.setSelectedCol(colclicked)
            self.drawSelectedRect(self.currentrow, self.currentcol)
            self.drawSelectedRow()
        if self.isInsideTable(event.x,event.y) == 1:
            self.rightmenu = self.popupMenu(event,rows=self.multiplerowlist, cols=self.multiplecollist)
        else:
            self.rightmenu = self.popupMenu(event, outside=1)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.importCSV"><code class="name flex">
<span>def <span class="ident">importCSV</span></span>(<span>self, filename=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Import from csv file</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def importCSV(self, filename=None):
    &#34;&#34;&#34;Import from csv file&#34;&#34;&#34;

    if filename is None:
        from .Tables_IO import TableImporter
        importer = TableImporter()
        importdialog = importer.import_Dialog(self.master)
        self.master.wait_window(importdialog)
        model = TableModel()
        model.importDict(importer.data)
    else:
        model = TableModel()
        model.importCSV(filename)
    self.updateModel(model)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.importTable"><code class="name flex">
<span>def <span class="ident">importTable</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def importTable(self):
    self.importCSV()</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.isInsideTable"><code class="name flex">
<span>def <span class="ident">isInsideTable</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns true if x-y coord is inside table bounds</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def isInsideTable(self,x,y):
    &#34;&#34;&#34;Returns true if x-y coord is inside table bounds&#34;&#34;&#34;
    if self.x_start &lt; x &lt; self.tablewidth and self.y_start &lt; y &lt; self.rows*self.rowheight:
        return 1
    else:
        return 0
    return answer</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.isLink"><code class="name flex">
<span>def <span class="ident">isLink</span></span>(<span>self, cell)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if cell is a hyperlink, without using isinstance</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def isLink(self, cell):
    &#34;&#34;&#34;Checks if cell is a hyperlink, without using isinstance&#34;&#34;&#34;
    try:
        if &#39;link&#39; in cell:
            return True
    except:
        return False</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, filename=None)</span>
</code></dt>
<dd>
<section class="desc"><p>load from a file</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load(self, filename=None):
    &#34;&#34;&#34;load from a file&#34;&#34;&#34;

    if filename == None:
        filename = filedialog.askopenfilename(parent=self.master,
                                                  defaultextension=&#39;.table&#39;,
                                                  initialdir=os.getcwd(),
                                                  filetypes=[(&#34;pickle&#34;,&#34;*.table&#34;),
                                                    (&#34;All files&#34;,&#34;*.*&#34;)])
    if not os.path.exists(filename):
        print (&#39;file does not exist&#39;)
        return
    if filename:
        self.model.load(filename)
        self.redrawTable()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.loadPrefs"><code class="name flex">
<span>def <span class="ident">loadPrefs</span></span>(<span>self, prefs=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Load table specific prefs from the prefs instance used
if they are not present, create them.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loadPrefs(self, prefs=None):
    &#34;&#34;&#34;Load table specific prefs from the prefs instance used
       if they are not present, create them.&#34;&#34;&#34;

    if prefs == None:
        prefs=Preferences(&#39;Table&#39;,{&#39;check_for_update&#39;:1})
    self.prefs = prefs
    defaultprefs = {&#39;horizlines&#39;:self.horizlines, &#39;vertlines&#39;:self.vertlines,
                    &#39;alternaterows&#39;:self.alternaterows,
                    &#39;rowheight&#39;:self.rowheight,
                    &#39;cellwidth&#39;:100,
                    &#39;autoresizecols&#39;: 0,
                    &#39;align&#39;: &#39;w&#39;,
                    &#39;celltextsize&#39;:11, &#39;celltextfont&#39;:&#39;Arial&#39;,
                    &#39;cellbackgr&#39;: self.cellbackgr, &#39;grid_color&#39;: self.grid_color,
                    &#39;linewidth&#39; : self.linewidth,
                    &#39;rowselectedcolor&#39;: self.rowselectedcolor,
                    &#39;rowheaderwidth&#39;: self.rowheaderwidth}

    #print (self.prefs.__dict__)
    for prop in defaultprefs:
        if not prop in self.prefs.prefs:
            #print (defaultprefs[prop])
            if defaultprefs[prop] != &#39;None&#39;:
                self.prefs.set(prop, defaultprefs[prop])

    self.defaultprefs = defaultprefs

    #Create tkvars for dialog
    self.rowheightvar = IntVar()
    self.rowheightvar.set(self.prefs.get(&#39;rowheight&#39;))
    self.rowheight = self.rowheightvar.get()
    self.cellwidthvar = IntVar()
    self.cellwidthvar.set(self.prefs.get(&#39;cellwidth&#39;))
    self.cellwidth = self.cellwidthvar.get()
    self.cellalignvar = StringVar()
    self.cellalignvar.set(self.prefs.get(&#39;align&#39;))
    self.align = self.cellalignvar.get()
    self.linewidthvar = IntVar()
    self.linewidthvar.set(self.prefs.get(&#39;linewidth&#39;))
    self.horizlinesvar = IntVar()
    self.horizlinesvar.set(self.prefs.get(&#39;horizlines&#39;))
    self.vertlinesvar = IntVar()
    self.vertlinesvar.set(self.prefs.get(&#39;vertlines&#39;))
    self.alternaterowsvar = IntVar()
    self.alternaterowsvar.set(self.prefs.get(&#39;alternaterows&#39;))
    self.celltextsizevar = IntVar()
    self.celltextsizevar.set(self.prefs.get(&#39;celltextsize&#39;))
    self.cellbackgr = self.prefs.get(&#39;cellbackgr&#39;)
    self.grid_color = self.prefs.get(&#39;grid_color&#39;)
    self.rowselectedcolor = self.prefs.get(&#39;rowselectedcolor&#39;)
    self.fontsize = self.celltextsizevar.get()
    self.thefont = (self.prefs.get(&#39;celltextfont&#39;), self.prefs.get(&#39;celltextsize&#39;))
    self.rowheaderwidthvar = IntVar()
    self.rowheaderwidthvar.set(self.prefs.get(&#39;rowheaderwidth&#39;))
    self.rowheaderwidth = self.rowheaderwidthvar.get()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.mouse_wheel"><code class="name flex">
<span>def <span class="ident">mouse_wheel</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Handle mouse wheel scroll for windows</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def mouse_wheel(self, event):
    &#34;&#34;&#34;Handle mouse wheel scroll for windows&#34;&#34;&#34;

    if event.num == 5 or event.delta == -120:
        event.widget.yview_scroll(1, UNITS)
        self.tablerowheader.yview_scroll(1, UNITS)
    if event.num == 4 or event.delta == 120:
        if self.canvasy(0) &lt; 0:
            return
        event.widget.yview_scroll(-1, UNITS)
        self.tablerowheader.yview_scroll(-1, UNITS)
    self.redrawVisible()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.movetoSelectedRow"><code class="name flex">
<span>def <span class="ident">movetoSelectedRow</span></span>(<span>self, row=None, recname=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Move to selected row, updating table</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def movetoSelectedRow(self, row=None, recname=None):
    &#34;&#34;&#34;Move to selected row, updating table&#34;&#34;&#34;
    row=self.model.getRecordIndex(recname)
    self.setSelectedRow(row)
    self.drawSelectedRow()
    x,y = self.getCanvasPos(row, 0)
    self.yview(&#39;moveto&#39;, y-0.01)
    self.tablecolheader.yview(&#39;moveto&#39;, y)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Clears all the data and makes a new table</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def new(self):
    &#34;&#34;&#34;Clears all the data and makes a new table&#34;&#34;&#34;

    mpDlg = MultipleValDialog(title=&#39;Create new table&#39;,
                                initialvalues=(10, 4),
                                labels=(&#39;rows&#39;,&#39;columns&#39;),
                                types=(&#39;int&#39;,&#39;int&#39;),
                                parent=self.parentframe)

    if mpDlg.result == True:
        rows = mpDlg.results[0]
        cols = mpDlg.results[1]
        model = TableModel(rows=rows,columns=cols)
        self.updateModel(model)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.paste"><code class="name flex">
<span>def <span class="ident">paste</span></span>(<span>self, event=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Copy from clipboard</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def paste(self, event=None):
    &#34;&#34;&#34;Copy from clipboard&#34;&#34;&#34;

    print (self.parentframe.clipboard_get())
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.pasteCell"><code class="name flex">
<span>def <span class="ident">pasteCell</span></span>(<span>self, rows, cols=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Paste cell from internal clipboard</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def pasteCell(self, rows, cols=None):
    &#34;&#34;&#34;Paste cell from internal clipboard&#34;&#34;&#34;

    row = rows[0]; col = cols[0]
    #absrow = self.get_AbsoluteRow(row)
    val = self.clipboard
    self.model.setValueAt(val, row, col)
    self.redrawTable()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.pasteColumns"><code class="name flex">
<span>def <span class="ident">pasteColumns</span></span>(<span>self, coldata)</span>
</code></dt>
<dd>
<section class="desc"><p>Paste new cols, overwrites existing names</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def pasteColumns(self, coldata):
    &#34;&#34;&#34;Paste new cols, overwrites existing names&#34;&#34;&#34;

    M = self.model
    for name in coldata:
        if name not in M.columnNames:
            M.addColumn(name)
        for r in range(len(coldata[name])):
            val = coldata[name][r]
            col = M.columnNames.index(name)
            if r &gt;= self.rows:
                break
            M.setValueAt(val, r, col)
    self.redrawTable()
    return coldata</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.plotSelected"><code class="name flex">
<span>def <span class="ident">plotSelected</span></span>(<span>self, graphtype='XY')</span>
</code></dt>
<dd>
<section class="desc"><p>Plot the selected data using pylab - if possible</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plotSelected(self, graphtype=&#39;XY&#39;):
    &#34;&#34;&#34;Plot the selected data using pylab - if possible&#34;&#34;&#34;

    from .Plot import pylabPlotter
    if not hasattr(self, &#39;pyplot&#39;):
        self.pyplot = pylabPlotter()
    plotdata = []
    for p in self.getSelectionValues():
        x = []
        fail = False
        for d in p:
            try:
                x.append(float(d))
            except:
                fail = True
                continue
        if fail == False:
            plotdata.append(x)

    pltlabels = self.getplotlabels()
    if len(pltlabels) &gt; 2:
        self.pyplot.setDataSeries(pltlabels)
        self.pyplot.showlegend = 1
    self.pyplot.plotCurrent(data=plotdata, graphtype=graphtype)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.plotSetup"><code class="name flex">
<span>def <span class="ident">plotSetup</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Call pylab plot dialog setup, send data if we haven't already
plotted</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plotSetup(self):
    &#34;&#34;&#34;Call pylab plot dialog setup, send data if we haven&#39;t already
        plotted&#34;&#34;&#34;

    from PylabPlot import pylabPlotter
    if not hasattr(self, &#39;pyplot&#39;):
        self.pyplot = pylabPlotter()
    plotdata = self.getSelectionValues()
    if not self.pyplot.hasData() and plotdata != None:
        print (&#39;has data&#39;)
        plotdata = self.getSelectionValues()
        pltlabels = self.getplotlabels()
        self.pyplot.setDataSeries(pltlabels)
        self.pyplot.plotSetup(plotdata)
    else:
        self.pyplot.plotSetup()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.popupMenu"><code class="name flex">
<span>def <span class="ident">popupMenu</span></span>(<span>self, event, rows=None, cols=None, outside=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Add left and right click behaviour for canvas, should not have to override
this function, it will take its values from defined dicts in constructor</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def popupMenu(self, event, rows=None, cols=None, outside=None):
    &#34;&#34;&#34;Add left and right click behaviour for canvas, should not have to override
        this function, it will take its values from defined dicts in constructor&#34;&#34;&#34;

    defaultactions = {&#34;Set Fill Color&#34; : lambda : self.setcellColor(rows,cols,key=&#39;bg&#39;),
                    &#34;Set Text Color&#34; : lambda : self.setcellColor(rows,cols,key=&#39;fg&#39;),
                    &#34;Copy&#34; : lambda : self.copyCell(rows, cols),
                    &#34;Paste&#34; : lambda : self.pasteCell(rows, cols),
                    &#34;Fill Down&#34; : lambda : self.fillDown(rows, cols),
                    &#34;Fill Right&#34; : lambda : self.fillAcross(cols, rows),
                    &#34;Add Row(s)&#34; : lambda : self.addRows(),
                    &#34;Delete Row(s)&#34; : lambda : self.deleteRow(),
                    &#34;View Record&#34; : lambda : self.getRecordInfo(row),
                    &#34;Clear Data&#34; : lambda : self.deleteCells(rows, cols),
                    &#34;Select All&#34; : self.select_All,
                    &#34;Auto Fit Columns&#34; : self.autoResizeColumns,
                    &#34;Filter Records&#34; : self.showFilteringBar,
                    &#34;New&#34;: self.new,
                    &#34;Load&#34;: self.load,
                    &#34;Save&#34;: self.save,
                    &#34;Import text&#34;:self.importTable,
                    &#34;Export csv&#34;: self.exportTable,
                    &#34;Plot Selected&#34; : self.plotSelected,
                    &#34;Plot Options&#34; : self.plotSetup,
                    &#34;Export Table&#34; : self.exportTable,
                    &#34;Preferences&#34; : self.showtablePrefs,
                    &#34;Formulae-&gt;Value&#34; : lambda : self.convertFormulae(rows, cols)}

    main = [&#34;Set Fill Color&#34;,&#34;Set Text Color&#34;,&#34;Copy&#34;, &#34;Paste&#34;, &#34;Fill Down&#34;,&#34;Fill Right&#34;,
            &#34;Clear Data&#34;]
    general = [&#34;Select All&#34;, &#34;Add Row(s)&#34; , &#34;Delete Row(s)&#34;, &#34;Auto Fit Columns&#34;, &#34;Filter Records&#34;, &#34;Preferences&#34;]
    filecommands = [&#39;New&#39;,&#39;Load&#39;,&#39;Save&#39;,&#39;Import text&#39;,&#39;Export csv&#39;]
    plotcommands = [&#39;Plot Selected&#39;,&#39;Plot Options&#39;]

    def createSubMenu(parent, label, commands):
        menu = Menu(parent, tearoff = 0)
        popupmenu.add_cascade(label=label,menu=menu)
        for action in commands:
            menu.add_command(label=action, command=defaultactions[action])
        return menu

    def add_commands(fieldtype):
        &#34;&#34;&#34;Add commands to popup menu for column type and specific cell&#34;&#34;&#34;
        functions = self.columnactions[fieldtype]
        for f in functions.keys():
            func = getattr(self, functions[f])
            popupmenu.add_command(label=f, command= lambda : func(row,col))
        return

    popupmenu = Menu(self, tearoff = 0)
    def popupFocusOut(event):
        popupmenu.unpost()

    if outside == None:
        #if outside table, just show general items
        row = self.get_row_clicked(event)
        col = self.get_col_clicked(event)
        coltype = self.model.getColumnType(col)
        def add_defaultcommands():
            &#34;&#34;&#34;now add general actions for all cells&#34;&#34;&#34;
            for action in main:
                if action == &#39;Fill Down&#39; and (rows == None or len(rows) &lt;= 1):
                    continue
                if action == &#39;Fill Right&#39; and (cols == None or len(cols) &lt;= 1):
                    continue
                else:
                    popupmenu.add_command(label=action, command=defaultactions[action])
            return

        if coltype in self.columnactions:
            add_commands(coltype)
        add_defaultcommands()

    for action in general:
        popupmenu.add_command(label=action, command=defaultactions[action])

    popupmenu.add_separator()
    createSubMenu(popupmenu, &#39;File&#39;, filecommands)
    createSubMenu(popupmenu, &#39;Plot&#39;, plotcommands)
    popupmenu.bind(&#34;&lt;FocusOut&gt;&#34;, popupFocusOut)
    popupmenu.focus_set()
    popupmenu.post(event.x_root, event.y_root)
    return popupmenu</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.redraw"><code class="name flex">
<span>def <span class="ident">redraw</span></span>(<span>self, event=None, callback=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def redraw(self, event=None, callback=None):
    self.redrawVisible(event, callback)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.redrawCell"><code class="name flex">
<span>def <span class="ident">redrawCell</span></span>(<span>self, row=None, col=None, recname=None, colname=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Redraw a specific cell only</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def redrawCell(self, row=None, col=None, recname=None, colname=None):
    &#34;&#34;&#34;Redraw a specific cell only&#34;&#34;&#34;

    if row == None and recname != None:
        row = self.model.getRecordIndex(recname)
    if col == None and colname != None:
        col = self.model.getColumnIndex(colname)
    bgcolor = self.model.getColorAt(row,col, &#39;bg&#39;)
    fgcolor = self.model.getColorAt(row,col, &#39;fg&#39;)
    text = self.model.getValueAt(row,col)
    self.drawText(row, col, text, fgcolor)
    if bgcolor != None:
        self.drawRect(row,col, color=bgcolor)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.redrawTable"><code class="name flex">
<span>def <span class="ident">redrawTable</span></span>(<span>self, event=None, callback=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def redrawTable(self, event=None, callback=None):
    self.redrawVisible(event, callback)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.redrawVisible"><code class="name flex">
<span>def <span class="ident">redrawVisible</span></span>(<span>self, event=None, callback=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Redraw the visible portion of the canvas</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def redrawVisible(self, event=None, callback=None):
    &#34;&#34;&#34;Redraw the visible portion of the canvas&#34;&#34;&#34;

    model = self.model
    self.rows = self.model.getRowCount()
    self.cols = self.model.getColumnCount()

    self.tablewidth = (self.cellwidth) * self.cols
    self.configure(bg=self.cellbackgr)
    self.setColPositions()

    #are we drawing a filtered subset of the recs?
    if self.filtered == True and self.model.filteredrecs != None:
        self.rows = len(self.model.filteredrecs)
        self.delete(&#39;colrect&#39;)

    self.rowrange = range(0,self.rows)
    self.configure(scrollregion=(0,0, self.tablewidth+self.x_start,
            self.rowheight*self.rows+10))

    x1, y1, x2, y2 = self.getVisibleRegion()
    startvisiblerow, endvisiblerow = self.getVisibleRows(y1, y2)
    self.visiblerows = range(startvisiblerow, endvisiblerow)
    startvisiblecol, endvisiblecol = self.getVisibleCols(x1, x2)
    self.visiblecols = range(startvisiblecol, endvisiblecol)

    if self.cols == 0 or self.rows == 0:
        self.delete(&#39;entry&#39;)
        self.delete(&#39;rowrect&#39;)
        self.delete(&#39;currentrect&#39;)
        self.delete(&#39;gridline&#39;,&#39;text&#39;)
        self.tablerowheader.redraw()
        return

    self.drawGrid(startvisiblerow, endvisiblerow)
    align = self.align
    self.delete(&#39;fillrect&#39;)
    for row in self.visiblerows:
        if callback != None:
            callback()
        for col in self.visiblecols:
            colname = model.getColumnName(col)
            bgcolor = model.getColorAt(row,col, &#39;bg&#39;)
            fgcolor = model.getColorAt(row,col, &#39;fg&#39;)
            text = model.getValueAt(row,col)
            self.drawText(row, col, text, fgcolor, align)
            if bgcolor != None:
                self.drawRect(row,col, color=bgcolor)

    #self.drawSelectedCol()
    self.tablecolheader.redraw()
    self.tablerowheader.redraw(align=self.align, showkeys=self.showkeynamesinheader)
    #self.setSelectedRow(self.currentrow)
    self.drawSelectedRow()
    self.drawSelectedRect(self.currentrow, self.currentcol)
    #print self.multiplerowlist

    if len(self.multiplerowlist)&gt;1:
        self.tablerowheader.drawSelectedRows(self.multiplerowlist)
        self.drawMultipleRows(self.multiplerowlist)
        self.drawMultipleCells()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.resizeColumn"><code class="name flex">
<span>def <span class="ident">resizeColumn</span></span>(<span>self, col, width)</span>
</code></dt>
<dd>
<section class="desc"><p>Resize a column by dragging</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def resizeColumn(self, col, width):
    &#34;&#34;&#34;Resize a column by dragging&#34;&#34;&#34;

    #print &#39;resizing column&#39;, col
    #recalculate all col positions..
    colname=self.model.getColumnName(col)
    self.model.columnwidths[colname]=width
    self.setColPositions()
    self.redrawTable()
    self.drawSelectedCol(self.currentcol)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Save model to pickle file</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def save(self, filename=None):
    &#34;&#34;&#34;Save model to pickle file&#34;&#34;&#34;

    if filename == None:
        filename = filedialog.asksaveasfilename(parent=self.master,
                                                    defaultextension=&#39;.table&#39;,
                                                    initialdir=os.getcwd(),
                                                    filetypes=[(&#34;pickle&#34;,&#34;*.table&#34;),
                                                      (&#34;All files&#34;,&#34;*.*&#34;)])
    if filename:
        self.model.save(filename)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.savePrefs"><code class="name flex">
<span>def <span class="ident">savePrefs</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Save and set the prefs</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def savePrefs(self):
    &#34;&#34;&#34;Save and set the prefs&#34;&#34;&#34;

    try:
        self.prefs.set(&#39;horizlines&#39;, self.horizlinesvar.get())
        self.horizlines = self.horizlinesvar.get()
        self.prefs.set(&#39;vertlines&#39;, self.vertlinesvar.get())
        self.vertlines = self.vertlinesvar.get()
        self.prefs.set(&#39;alternaterows&#39;, self.alternaterowsvar.get())
        self.alternaterows = self.alternaterowsvar.get()
        self.prefs.set(&#39;rowheight&#39;, self.rowheightvar.get())
        self.rowheight = self.rowheightvar.get()
        self.prefs.set(&#39;cellwidth&#39;, self.cellwidthvar.get())
        self.cellwidth = self.cellwidthvar.get()
        self.prefs.set(&#39;align&#39;, self.cellalignvar.get())
        self.align = self.cellalignvar.get()
        self.prefs.set(&#39;linewidth&#39;, self.linewidthvar.get())
        self.linewidth = self.linewidthvar.get()
        self.prefs.set(&#39;celltextsize&#39;, self.celltextsizevar.get())
        self.prefs.set(&#39;celltextfont&#39;, self.fontvar.get())
        self.prefs.set(&#39;cellbackgr&#39;, self.cellbackgr)
        self.prefs.set(&#39;grid_color&#39;, self.grid_color)
        self.prefs.set(&#39;rowselectedcolor&#39;, self.rowselectedcolor)
        self.prefs.set(&#39;rowheaderwidth&#39;, self.rowheaderwidth)
        self.rowheaderwidth = self.rowheaderwidthvar.get()
        self.thefont = (self.prefs.get(&#39;celltextfont&#39;), self.prefs.get(&#39;celltextsize&#39;))
        self.fontsize = self.prefs.get(&#39;celltextsize&#39;)

    except ValueError as e:
        print (e)
        pass
    self.prefs.save_prefs()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.select_All"><code class="name flex">
<span>def <span class="ident">select_All</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Select all rows and cells</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def select_All(self):
    &#34;&#34;&#34;Select all rows and cells&#34;&#34;&#34;

    self.startrow = 0
    self.endrow = self.rows
    self.multiplerowlist = range(self.startrow,self.endrow)
    self.drawMultipleRows(self.multiplerowlist)
    self.startcol = 0
    self.endcol = self.cols
    self.multiplecollist = range(self.startcol, self.endcol)
    self.drawMultipleCells()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.setColPositions"><code class="name flex">
<span>def <span class="ident">setColPositions</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Determine current column grid positions</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setColPositions(self):
    &#34;&#34;&#34;Determine current column grid positions&#34;&#34;&#34;

    self.col_positions=[]
    w=self.cellwidth
    x_pos=self.x_start
    self.col_positions.append(x_pos)
    for col in range(self.cols):
        colname=self.model.getColumnName(col)
        if colname in self.model.columnwidths:
            x_pos=x_pos+self.model.columnwidths[colname]
        else:
            x_pos=x_pos+w
        self.col_positions.append(x_pos)
    self.tablewidth = self.col_positions[len(self.col_positions)-1]
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.setFontSize"><code class="name flex">
<span>def <span class="ident">setFontSize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Set font size to match font, we need to get rid of fontsize as
a separate variable?</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setFontSize(self):
    &#34;&#34;&#34;Set font size to match font, we need to get rid of fontsize as
        a separate variable?&#34;&#34;&#34;

    if hasattr(self, &#39;thefont&#39;) and type(self.thefont) is tuple:
        self.fontsize = self.thefont[1]
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.setModel"><code class="name flex">
<span>def <span class="ident">setModel</span></span>(<span>self, model)</span>
</code></dt>
<dd>
<section class="desc"><p>Set a new model - requires redraw to reflect changes</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setModel(self, model):
    &#34;&#34;&#34;Set a new model - requires redraw to reflect changes&#34;&#34;&#34;
    self.model = model
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.setRowHeight"><code class="name flex">
<span>def <span class="ident">setRowHeight</span></span>(<span>self, h)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the row height</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setRowHeight(self, h):
    &#34;&#34;&#34;Set the row height&#34;&#34;&#34;
    self.rowheight = h
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.setSelectedCells"><code class="name flex">
<span>def <span class="ident">setSelectedCells</span></span>(<span>self, startrow, endrow, startcol, endcol)</span>
</code></dt>
<dd>
<section class="desc"><p>Set a block of cells selected</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setSelectedCells(self, startrow, endrow, startcol, endcol):
    &#34;&#34;&#34;Set a block of cells selected&#34;&#34;&#34;

    self.currentrow = startrow
    self.currentcol = startcol
    if startrow &lt; 0 or startcol &lt; 0:
        return
    if endrow &gt; self.rows or endcol &gt; self.cols:
        return
    for r in range(startrow, endrow):
        self.multiplerowlist.append(r)
    for c in range(startcol, endcol):
        self.multiplecollist.append(c)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.setSelectedCol"><code class="name flex">
<span>def <span class="ident">setSelectedCol</span></span>(<span>self, col)</span>
</code></dt>
<dd>
<section class="desc"><p>Set currently selected column</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setSelectedCol(self, col):
    &#34;&#34;&#34;Set currently selected column&#34;&#34;&#34;

    self.currentcol = col
    self.multiplecollist = []
    self.multiplecollist.append(col)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.setSelectedRow"><code class="name flex">
<span>def <span class="ident">setSelectedRow</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<section class="desc"><p>Set currently selected row and reset multiple row list</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setSelectedRow(self, row):
    &#34;&#34;&#34;Set currently selected row and reset multiple row list&#34;&#34;&#34;

    self.currentrow = row
    self.multiplerowlist = []
    self.multiplerowlist.append(row)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.set_defaults"><code class="name flex">
<span>def <span class="ident">set_defaults</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Set default settings</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_defaults(self):
    &#34;&#34;&#34;Set default settings&#34;&#34;&#34;

    self.cellwidth=150
    self.maxcellwidth=200
    self.rowheight=20
    self.horizlines=1
    self.vertlines=1
    self.alternaterows=0
    self.autoresizecols = 0
    self.inset=2
    self.x_start=0
    self.y_start=1
    self.linewidth=1.0
    self.rowheaderwidth=40
    self.showkeynamesinheader=False
    self.thefont = (&#39;Arial&#39;,12)
    self.cellbackgr = &#39;#F7F7FA&#39;
    self.entrybackgr = &#39;white&#39;
    self.grid_color = &#39;#ABB1AD&#39;
    self.selectedcolor = &#39;yellow&#39;
    self.rowselectedcolor = &#39;#CCCCFF&#39;
    self.multipleselectioncolor = &#39;#ECD672&#39;
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.set_xviews"><code class="name flex">
<span>def <span class="ident">set_xviews</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the xview of table and col header</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_xviews(self,*args):
    &#34;&#34;&#34;Set the xview of table and col header&#34;&#34;&#34;

    self.xview(*args)
    self.tablecolheader.xview(*args)
    self.redrawVisible()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.set_yviews"><code class="name flex">
<span>def <span class="ident">set_yviews</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the xview of table and row header</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_yviews(self,*args):
    &#34;&#34;&#34;Set the xview of table and row header&#34;&#34;&#34;

    self.yview(*args)
    self.tablerowheader.yview(*args)
    self.redrawVisible()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.setcellColor"><code class="name flex">
<span>def <span class="ident">setcellColor</span></span>(<span>self, rows, cols=None, newColor=None, key=None, redraw=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the cell color for one or more cells and save it in the model color</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setcellColor(self, rows, cols=None, newColor=None, key=None, redraw=True):
    &#34;&#34;&#34;Set the cell color for one or more cells and save it in the model color&#34;&#34;&#34;

    model = self.getModel()
    if newColor == None:
        ctuple, newColor = tkColorChooser.askcolor(title=&#39;pick a color&#39;)
        if newColor == None:
            return

    if type(rows) is int:
        x=rows
        rows=[]
        rows.append(x)
    if self.allrows == True:
        #we use all rows if the whole column has been selected
        rows = range(0,self.rows)
    if cols == None:
        cols = range(self.cols)
    for col in cols:
        for row in rows:
            #absrow = self.get_AbsoluteRow(row)
            model.setColorAt(row, col, color=newColor, key=key)
            #setcolor(absrow, col)
    if redraw == True:
        self.redrawTable()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.setcellbackgr"><code class="name flex">
<span>def <span class="ident">setcellbackgr</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setcellbackgr(self):
    clr = self.getaColor(self.cellbackgr)
    if clr != None:
        self.cellbackgr = clr
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.setgrid_color"><code class="name flex">
<span>def <span class="ident">setgrid_color</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setgrid_color(self):
    clr = self.getaColor(self.grid_color)
    if clr != None:
        self.grid_color = clr

    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.setrowselectedcolor"><code class="name flex">
<span>def <span class="ident">setrowselectedcolor</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setrowselectedcolor(self):
    clr = self.getaColor(self.rowselectedcolor)
    if clr != None:
        self.rowselectedcolor = clr
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, callback=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds column header and scrollbars and combines them with
the current table adding all to the master frame provided in constructor.
Table is then redrawn.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def show(self, callback=None):
    &#34;&#34;&#34;Adds column header and scrollbars and combines them with
       the current table adding all to the master frame provided in constructor.
       Table is then redrawn.&#34;&#34;&#34;

    #Add the table and header to the frame
    self.tablerowheader = RowHeader(self.parentframe, self, width=self.rowheaderwidth)
    self.tablecolheader = ColumnHeader(self.parentframe, self)
    self.Yscrollbar = AutoScrollbar(self.parentframe,orient=VERTICAL,command=self.set_yviews)
    self.Yscrollbar.grid(row=1,column=2,rowspan=1,sticky=&#39;news&#39;,pady=0,ipady=0)
    self.Xscrollbar = AutoScrollbar(self.parentframe,orient=HORIZONTAL,command=self.set_xviews)
    self.Xscrollbar.grid(row=2,column=1,columnspan=1,sticky=&#39;news&#39;)
    self[&#39;xscrollcommand&#39;] = self.Xscrollbar.set
    self[&#39;yscrollcommand&#39;] = self.Yscrollbar.set
    self.tablecolheader[&#39;xscrollcommand&#39;] = self.Xscrollbar.set
    self.tablerowheader[&#39;yscrollcommand&#39;] = self.Yscrollbar.set
    self.parentframe.rowconfigure(1,weight=1)
    self.parentframe.columnconfigure(1,weight=1)

    self.tablecolheader.grid(row=0,column=1,rowspan=1,sticky=&#39;news&#39;,pady=0,ipady=0)
    self.tablerowheader.grid(row=1,column=0,rowspan=1,sticky=&#39;news&#39;,pady=0,ipady=0)
    self.grid(row=1,column=1,rowspan=1,sticky=&#39;news&#39;,pady=0,ipady=0)

    self.adjustColumnWidths()
    self.redrawTable(callback=callback)
    self.parentframe.bind(&#34;&lt;Configure&gt;&#34;, self.redrawVisible)
    self.tablecolheader.xview(&#34;moveto&#34;, 0)
    self.xview(&#34;moveto&#34;, 0)
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.showAll"><code class="name flex">
<span>def <span class="ident">showAll</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def showAll(self):
    self.model.filteredrecs = None
    self.filtered = False
    self.redrawTable()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.showFilteringBar"><code class="name flex">
<span>def <span class="ident">showFilteringBar</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def showFilteringBar(self):
    if not hasattr(self, &#39;filterwin&#39;) or self.filterwin == None:
        self.filterwin = self.createFilteringBar()
        self.filterwin.protocol(&#34;WM_DELETE_WINDOW&#34;, self.closeFilterFrame)
    else:
        self.filterwin.lift()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.show_progressbar"><code class="name flex">
<span>def <span class="ident">show_progressbar</span></span>(<span>self, message=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Show progress bar window for loading of data</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def show_progressbar(self,message=None):
    &#34;&#34;&#34;Show progress bar window for loading of data&#34;&#34;&#34;
    progress_win=Toplevel() # Open a new window
    progress_win.title(&#34;Please Wait&#34;)
    #progress_win.geometry(&#39;+%d+%d&#39; %(self.parentframe.rootx+200,self.parentframe.rooty+200))
    #force on top
    progress_win.grab_set()
    progress_win.transient(self.parentframe)
    if message==None:
        message=&#39;Working&#39;
    lbl = Label(progress_win,text=message,font=&#39;Arial 16&#39;)

    lbl.grid(row=0,column=0,columnspan=2,sticky=&#39;news&#39;,padx=6,pady=4)
    progrlbl = Label(progress_win,text=&#39;Progress:&#39;)
    progrlbl.grid(row=1,column=0,sticky=&#39;news&#39;,padx=2,pady=4)
    import ProgressBar
    self.bar = ProgressBar.ProgressBar(progress_win)
    self.bar.frame.grid(row=1,column=1,columnspan=2,padx=2,pady=4)

    return progress_win</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.showtablePrefs"><code class="name flex">
<span>def <span class="ident">showtablePrefs</span></span>(<span>self, prefs=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Show table options dialog using an instance of prefs</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def showtablePrefs(self, prefs=None):
    &#34;&#34;&#34;Show table options dialog using an instance of prefs&#34;&#34;&#34;
    #self.prefs = prefs
    if self.prefs == None:
        self.loadPrefs()
    self.prefswindow=Toplevel()
    x,y,w,h = self.getGeometry(self.master)
    self.prefswindow.geometry(&#39;+%s+%s&#39; %(int(x+w/2),int(y+h/2)))
    self.prefswindow.title(&#39;Preferences&#39;)
    self.prefswindow.resizable(width=FALSE, height=FALSE)

    frame1=Frame(self.prefswindow)
    frame1.pack(side=LEFT)
    frame2=Frame(self.prefswindow)
    frame2.pack()
    def close_prefsdialog():
        self.prefswindow.destroy()
    row=0
    Checkbutton(frame1, text=&#34;Show horizontal lines&#34;, variable=self.horizlinesvar,
                onvalue=1, offvalue=0).grid(row=row,column=0, columnspan=2, sticky=&#39;news&#39;)
    row=row+1
    Checkbutton(frame1, text=&#34;Show vertical lines&#34;, variable=self.vertlinesvar,
                onvalue=1, offvalue=0).grid(row=row,column=0, columnspan=2, sticky=&#39;news&#39;)
    row=row+1
    Checkbutton(frame1, text=&#34;Alternate Row Color&#34;, variable=self.alternaterowsvar,
                onvalue=1, offvalue=0).grid(row=row,column=0, columnspan=2, sticky=&#39;news&#39;)
    row=row+1
    lblrowheight = Label(frame1,text=&#39;Row Height:&#39;)
    lblrowheight.grid(row=row,column=0,padx=3,pady=2)
    rowheightentry = Spinbox(frame1,from_=12,to=50,width=10,
                        textvariable=self.rowheightvar)
    rowheightentry.grid(row=row,column=1,padx=3,pady=2)
    row=row+1
    lblcellwidth = Label(frame1,text=&#39;Cell Width:&#39;)
    lblcellwidth.grid(row=row,column=0,padx=3,pady=2)
    cellwidthentry = Spinbox(frame1,from_=20,to=500, width=10,
                         textvariable=self.cellwidthvar)
    cellwidthentry.grid(row=row,column=1,padx=3,pady=2)
    row=row+1

    lbllinewidth = Label(frame1,text=&#39;Line Width:&#39;)
    lbllinewidth.grid(row=row,column=0,padx=3,pady=2)
    linewidthentry = Spinbox(frame1,from_=0,to=10,width=10,
                        textvariable=self.linewidthvar)
    linewidthentry.grid(row=row,column=1,padx=3,pady=2)
    row=row+1

    rowhdrwidth = Label(frame1,text=&#39;Row Header Width:&#39;)
    rowhdrwidth.grid(row=row,column=0,padx=3,pady=2)
    rowhdrentry = Spinbox(frame1,from_=0,to=300, width=10,
                        textvariable=self.rowheaderwidthvar)
    rowhdrentry.grid(row=row,column=1,padx=3,pady=2)
    row=row+1

    #fonts
    fts = self.getFonts()
    self.fontvar = StringVar()
    self.fontvar.set(self.prefs.get(&#39;celltextfont&#39;))
    def setFont(*args):
        self.thefont = self.fontvar.get()
        return

    self.fontbox = Combobox(frame2,
                    values=(fts),
                    text=&#39;Font:&#39;,
                    height = 6,
                    textvariable=self.fontvar)
    self.fontvar.trace(&#39;w&#39;, setFont)
    Label(frame2,text=&#39;Font:&#39;).grid(row=row,column=0,padx=3,pady=2)
    self.fontbox.grid(row=row,column=1, columnspan=2, sticky=&#39;nes&#39;, padx=3,pady=2)
    row=row+1

    lblfontsize=Label(frame2,text=&#39;Text Size:&#39;)
    lblfontsize.grid(row=row,column=0,padx=3,pady=2)
    fontsizeentry = Spinbox(frame2,from_=6,to=50, width=20,
                            textvariable=self.celltextsizevar)

    fontsizeentry.grid(row=row,column=1, sticky=&#39;wens&#39;,padx=3,pady=2)
    row=row+1

    #cell alignment
    lbl=Label(frame2,text=&#39;Alignment:&#39;)
    lbl.grid(row=row,column=0,padx=3,pady=2)
    alignentry_button = Menubutton(frame2,textvariable=self.cellalignvar, width=16)
    alignentry_menu = Menu(alignentry_button,tearoff=0)
    alignentry_button[&#39;menu&#39;] = alignentry_menu
    alignments=[&#39;w&#39;,&#39;e&#39;,&#39;center&#39;]
    for text in alignments:
        alignentry_menu.add_radiobutton(label=text,
                                        variable=self.cellalignvar,
                                        value=text,
                                        indicatoron=1)
    alignentry_button.grid(row=row,column=1, sticky=&#39;nes&#39;, padx=3,pady=2)
    row=row+1

    #colors
    style = Style()
    style.configure(&#34;cb.TButton&#34;, background=self.cellbackgr)
    cellbackgrbutton = Button(frame2, text=&#39;table background&#39;, style=&#34;cb.TButton&#34;, #bg=self.cellbackgr,
                             command=self.setcellbackgr)
    cellbackgrbutton.grid(row=row,column=0,columnspan=2, sticky=&#39;news&#39;,padx=3,pady=2)
    row=row+1
    style = Style()
    style.configure(&#34;gc.TButton&#34;, background=self.grid_color)
    grid_colorbutton = Button(frame2, text=&#39;grid color&#39;,  style=&#34;gc.TButton&#34;, #bg=self.grid_color,
                             command=self.setgrid_color)
    grid_colorbutton.grid(row=row,column=0,columnspan=2,  sticky=&#39;news&#39;,padx=3,pady=2)
    row=row+1
    style = Style()
    style.configure(&#34;rhc.TButton&#34;, background=self.rowselectedcolor)
    rowselectedcolorbutton = Button(frame2, text=&#39;row highlight color&#39;, style=&#34;rhc.TButton&#34;,
                             command=self.setrowselectedcolor)
    rowselectedcolorbutton.grid(row=row,column=0,columnspan=2,  sticky=&#39;news&#39;,padx=3,pady=2)
    row=row+1

    frame=Frame(self.prefswindow)
    frame.pack()
    # Apply Button
    b = Button(frame, text=&#34;Apply Settings&#34;, command=self.applyPrefs)
    b.grid(row=row,column=1,columnspan=2,sticky=&#39;news&#39;,padx=4,pady=4)

    # Close button
    c=Button(frame,text=&#39;Close&#39;, command=close_prefsdialog)
    c.grid(row=row,column=0,sticky=&#39;news&#39;,padx=4,pady=4)
    self.prefswindow.focus_set()
    self.prefswindow.grab_set()
    self.prefswindow.wait_window()
    return self.prefswindow</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.sortTable"><code class="name flex">
<span>def <span class="ident">sortTable</span></span>(<span>self, columnIndex=0, columnName=None, reverse=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Set up sort order dict based on currently selected field</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def sortTable(self, columnIndex=0, columnName=None, reverse=0):
    &#34;&#34;&#34;Set up sort order dict based on currently selected field&#34;&#34;&#34;

    self.model.setSortOrder(columnIndex, columnName, reverse)
    self.redrawTable()
    return</code></pre>
</details>
</dd>
<dt id="tkintertable.Tables.TableCanvas.updateModel"><code class="name flex">
<span>def <span class="ident">updateModel</span></span>(<span>self, model)</span>
</code></dt>
<dd>
<section class="desc"><p>Call this method to update the table model</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def updateModel(self, model):
    &#34;&#34;&#34;Call this method to update the table model&#34;&#34;&#34;

    self.model = model
    self.rows = self.model.getRowCount()
    self.cols = self.model.getColumnCount()
    self.tablewidth = (self.cellwidth)*self.cols
    self.tablecolheader = ColumnHeader(self.parentframe, self)
    self.tablerowheader = RowHeader(self.parentframe, self)
    self.createTableFrame()
    return</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tkintertable" href="index.html">tkintertable</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tkintertable.Tables.AutoScrollbar" href="#tkintertable.Tables.AutoScrollbar">AutoScrollbar</a></code></h4>
<ul class="">
<li><code><a title="tkintertable.Tables.AutoScrollbar.set" href="#tkintertable.Tables.AutoScrollbar.set">set</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tkintertable.Tables.ColumnHeader" href="#tkintertable.Tables.ColumnHeader">ColumnHeader</a></code></h4>
<ul class="">
<li><code><a title="tkintertable.Tables.ColumnHeader.drawRect" href="#tkintertable.Tables.ColumnHeader.drawRect">drawRect</a></code></li>
<li><code><a title="tkintertable.Tables.ColumnHeader.draw_resize_symbol" href="#tkintertable.Tables.ColumnHeader.draw_resize_symbol">draw_resize_symbol</a></code></li>
<li><code><a title="tkintertable.Tables.ColumnHeader.handle_left_click" href="#tkintertable.Tables.ColumnHeader.handle_left_click">handle_left_click</a></code></li>
<li><code><a title="tkintertable.Tables.ColumnHeader.handle_left_release" href="#tkintertable.Tables.ColumnHeader.handle_left_release">handle_left_release</a></code></li>
<li><code><a title="tkintertable.Tables.ColumnHeader.handle_left_shift_click" href="#tkintertable.Tables.ColumnHeader.handle_left_shift_click">handle_left_shift_click</a></code></li>
<li><code><a title="tkintertable.Tables.ColumnHeader.handle_mouse_drag" href="#tkintertable.Tables.ColumnHeader.handle_mouse_drag">handle_mouse_drag</a></code></li>
<li><code><a title="tkintertable.Tables.ColumnHeader.handle_mouse_move" href="#tkintertable.Tables.ColumnHeader.handle_mouse_move">handle_mouse_move</a></code></li>
<li><code><a title="tkintertable.Tables.ColumnHeader.handle_right_click" href="#tkintertable.Tables.ColumnHeader.handle_right_click">handle_right_click</a></code></li>
<li><code><a title="tkintertable.Tables.ColumnHeader.handle_right_release" href="#tkintertable.Tables.ColumnHeader.handle_right_release">handle_right_release</a></code></li>
<li><code><a title="tkintertable.Tables.ColumnHeader.popupMenu" href="#tkintertable.Tables.ColumnHeader.popupMenu">popupMenu</a></code></li>
<li><code><a title="tkintertable.Tables.ColumnHeader.redraw" href="#tkintertable.Tables.ColumnHeader.redraw">redraw</a></code></li>
<li><code><a title="tkintertable.Tables.ColumnHeader.relabel_Column" href="#tkintertable.Tables.ColumnHeader.relabel_Column">relabel_Column</a></code></li>
<li><code><a title="tkintertable.Tables.ColumnHeader.within" href="#tkintertable.Tables.ColumnHeader.within">within</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tkintertable.Tables.RowHeader" href="#tkintertable.Tables.RowHeader">RowHeader</a></code></h4>
<ul class="">
<li><code><a title="tkintertable.Tables.RowHeader.clearSelected" href="#tkintertable.Tables.RowHeader.clearSelected">clearSelected</a></code></li>
<li><code><a title="tkintertable.Tables.RowHeader.drawRect" href="#tkintertable.Tables.RowHeader.drawRect">drawRect</a></code></li>
<li><code><a title="tkintertable.Tables.RowHeader.drawSelectedRows" href="#tkintertable.Tables.RowHeader.drawSelectedRows">drawSelectedRows</a></code></li>
<li><code><a title="tkintertable.Tables.RowHeader.handle_left_click" href="#tkintertable.Tables.RowHeader.handle_left_click">handle_left_click</a></code></li>
<li><code><a title="tkintertable.Tables.RowHeader.handle_left_ctrl_click" href="#tkintertable.Tables.RowHeader.handle_left_ctrl_click">handle_left_ctrl_click</a></code></li>
<li><code><a title="tkintertable.Tables.RowHeader.handle_left_release" href="#tkintertable.Tables.RowHeader.handle_left_release">handle_left_release</a></code></li>
<li><code><a title="tkintertable.Tables.RowHeader.handle_mouse_drag" href="#tkintertable.Tables.RowHeader.handle_mouse_drag">handle_mouse_drag</a></code></li>
<li><code><a title="tkintertable.Tables.RowHeader.handle_right_click" href="#tkintertable.Tables.RowHeader.handle_right_click">handle_right_click</a></code></li>
<li><code><a title="tkintertable.Tables.RowHeader.redraw" href="#tkintertable.Tables.RowHeader.redraw">redraw</a></code></li>
<li><code><a title="tkintertable.Tables.RowHeader.setWidth" href="#tkintertable.Tables.RowHeader.setWidth">setWidth</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tkintertable.Tables.TableCanvas" href="#tkintertable.Tables.TableCanvas">TableCanvas</a></code></h4>
<ul class="">
<li><code><a title="tkintertable.Tables.TableCanvas.AskForColorButton" href="#tkintertable.Tables.TableCanvas.AskForColorButton">AskForColorButton</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.addColumn" href="#tkintertable.Tables.TableCanvas.addColumn">addColumn</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.addRow" href="#tkintertable.Tables.TableCanvas.addRow">addRow</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.addRows" href="#tkintertable.Tables.TableCanvas.addRows">addRows</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.adjustColumnWidths" href="#tkintertable.Tables.TableCanvas.adjustColumnWidths">adjustColumnWidths</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.applyPrefs" href="#tkintertable.Tables.TableCanvas.applyPrefs">applyPrefs</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.autoAddColumns" href="#tkintertable.Tables.TableCanvas.autoAddColumns">autoAddColumns</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.autoResizeColumns" href="#tkintertable.Tables.TableCanvas.autoResizeColumns">autoResizeColumns</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.checkDataEntry" href="#tkintertable.Tables.TableCanvas.checkDataEntry">checkDataEntry</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.checkOSType" href="#tkintertable.Tables.TableCanvas.checkOSType">checkOSType</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.check_hyperlink" href="#tkintertable.Tables.TableCanvas.check_hyperlink">check_hyperlink</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.clearData" href="#tkintertable.Tables.TableCanvas.clearData">clearData</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.clearSelected" href="#tkintertable.Tables.TableCanvas.clearSelected">clearSelected</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.closeFilterFrame" href="#tkintertable.Tables.TableCanvas.closeFilterFrame">closeFilterFrame</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.convertFormulae" href="#tkintertable.Tables.TableCanvas.convertFormulae">convertFormulae</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.copyCell" href="#tkintertable.Tables.TableCanvas.copyCell">copyCell</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.copyColumns" href="#tkintertable.Tables.TableCanvas.copyColumns">copyColumns</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.createFilteringBar" href="#tkintertable.Tables.TableCanvas.createFilteringBar">createFilteringBar</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.createTableFrame" href="#tkintertable.Tables.TableCanvas.createTableFrame">createTableFrame</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.createfromDict" href="#tkintertable.Tables.TableCanvas.createfromDict">createfromDict</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.deleteCells" href="#tkintertable.Tables.TableCanvas.deleteCells">deleteCells</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.deleteColumn" href="#tkintertable.Tables.TableCanvas.deleteColumn">deleteColumn</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.deleteRow" href="#tkintertable.Tables.TableCanvas.deleteRow">deleteRow</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.doFilter" href="#tkintertable.Tables.TableCanvas.doFilter">doFilter</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.do_bindings" href="#tkintertable.Tables.TableCanvas.do_bindings">do_bindings</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.drawCellEntry" href="#tkintertable.Tables.TableCanvas.drawCellEntry">drawCellEntry</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.drawGrid" href="#tkintertable.Tables.TableCanvas.drawGrid">drawGrid</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.drawMultipleCells" href="#tkintertable.Tables.TableCanvas.drawMultipleCells">drawMultipleCells</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.drawMultipleRows" href="#tkintertable.Tables.TableCanvas.drawMultipleRows">drawMultipleRows</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.drawRect" href="#tkintertable.Tables.TableCanvas.drawRect">drawRect</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.drawRowHeader" href="#tkintertable.Tables.TableCanvas.drawRowHeader">drawRowHeader</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.drawSelectedCol" href="#tkintertable.Tables.TableCanvas.drawSelectedCol">drawSelectedCol</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.drawSelectedRect" href="#tkintertable.Tables.TableCanvas.drawSelectedRect">drawSelectedRect</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.drawSelectedRow" href="#tkintertable.Tables.TableCanvas.drawSelectedRow">drawSelectedRow</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.drawText" href="#tkintertable.Tables.TableCanvas.drawText">drawText</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.drawTooltip" href="#tkintertable.Tables.TableCanvas.drawTooltip">drawTooltip</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.exportTable" href="#tkintertable.Tables.TableCanvas.exportTable">exportTable</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.fillAcross" href="#tkintertable.Tables.TableCanvas.fillAcross">fillAcross</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.fillDown" href="#tkintertable.Tables.TableCanvas.fillDown">fillDown</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.findValue" href="#tkintertable.Tables.TableCanvas.findValue">findValue</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.formula_Dialog" href="#tkintertable.Tables.TableCanvas.formula_Dialog">formula_Dialog</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getCanvasPos" href="#tkintertable.Tables.TableCanvas.getCanvasPos">getCanvasPos</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getCellCoords" href="#tkintertable.Tables.TableCanvas.getCellCoords">getCellCoords</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getColPosition" href="#tkintertable.Tables.TableCanvas.getColPosition">getColPosition</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getFonts" href="#tkintertable.Tables.TableCanvas.getFonts">getFonts</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getGeometry" href="#tkintertable.Tables.TableCanvas.getGeometry">getGeometry</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getModel" href="#tkintertable.Tables.TableCanvas.getModel">getModel</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getRecordInfo" href="#tkintertable.Tables.TableCanvas.getRecordInfo">getRecordInfo</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getRowPosition" href="#tkintertable.Tables.TableCanvas.getRowPosition">getRowPosition</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getSelectedColumn" href="#tkintertable.Tables.TableCanvas.getSelectedColumn">getSelectedColumn</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getSelectedRow" href="#tkintertable.Tables.TableCanvas.getSelectedRow">getSelectedRow</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getSelectionValues" href="#tkintertable.Tables.TableCanvas.getSelectionValues">getSelectionValues</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getVisibleCols" href="#tkintertable.Tables.TableCanvas.getVisibleCols">getVisibleCols</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getVisibleRegion" href="#tkintertable.Tables.TableCanvas.getVisibleRegion">getVisibleRegion</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getVisibleRows" href="#tkintertable.Tables.TableCanvas.getVisibleRows">getVisibleRows</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.get_col_clicked" href="#tkintertable.Tables.TableCanvas.get_col_clicked">get_col_clicked</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.get_currentColName" href="#tkintertable.Tables.TableCanvas.get_currentColName">get_currentColName</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.get_currentRecCol" href="#tkintertable.Tables.TableCanvas.get_currentRecCol">get_currentRecCol</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.get_currentRecord" href="#tkintertable.Tables.TableCanvas.get_currentRecord">get_currentRecord</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.get_currentRecordName" href="#tkintertable.Tables.TableCanvas.get_currentRecordName">get_currentRecordName</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.get_row_clicked" href="#tkintertable.Tables.TableCanvas.get_row_clicked">get_row_clicked</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.get_selectedRecordNames" href="#tkintertable.Tables.TableCanvas.get_selectedRecordNames">get_selectedRecordNames</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getaColor" href="#tkintertable.Tables.TableCanvas.getaColor">getaColor</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.getplotlabels" href="#tkintertable.Tables.TableCanvas.getplotlabels">getplotlabels</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.gotonextCell" href="#tkintertable.Tables.TableCanvas.gotonextCell">gotonextCell</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.gotonextRow" href="#tkintertable.Tables.TableCanvas.gotonextRow">gotonextRow</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.gotoprevRow" href="#tkintertable.Tables.TableCanvas.gotoprevRow">gotoprevRow</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.handleFormulaClick" href="#tkintertable.Tables.TableCanvas.handleFormulaClick">handleFormulaClick</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.handle_arrow_keys" href="#tkintertable.Tables.TableCanvas.handle_arrow_keys">handle_arrow_keys</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.handle_double_click" href="#tkintertable.Tables.TableCanvas.handle_double_click">handle_double_click</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.handle_left_click" href="#tkintertable.Tables.TableCanvas.handle_left_click">handle_left_click</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.handle_left_ctrl_click" href="#tkintertable.Tables.TableCanvas.handle_left_ctrl_click">handle_left_ctrl_click</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.handle_left_release" href="#tkintertable.Tables.TableCanvas.handle_left_release">handle_left_release</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.handle_left_shift_click" href="#tkintertable.Tables.TableCanvas.handle_left_shift_click">handle_left_shift_click</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.handle_motion" href="#tkintertable.Tables.TableCanvas.handle_motion">handle_motion</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.handle_mouse_drag" href="#tkintertable.Tables.TableCanvas.handle_mouse_drag">handle_mouse_drag</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.handle_right_click" href="#tkintertable.Tables.TableCanvas.handle_right_click">handle_right_click</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.importCSV" href="#tkintertable.Tables.TableCanvas.importCSV">importCSV</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.importTable" href="#tkintertable.Tables.TableCanvas.importTable">importTable</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.isInsideTable" href="#tkintertable.Tables.TableCanvas.isInsideTable">isInsideTable</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.isLink" href="#tkintertable.Tables.TableCanvas.isLink">isLink</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.load" href="#tkintertable.Tables.TableCanvas.load">load</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.loadPrefs" href="#tkintertable.Tables.TableCanvas.loadPrefs">loadPrefs</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.mouse_wheel" href="#tkintertable.Tables.TableCanvas.mouse_wheel">mouse_wheel</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.movetoSelectedRow" href="#tkintertable.Tables.TableCanvas.movetoSelectedRow">movetoSelectedRow</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.new" href="#tkintertable.Tables.TableCanvas.new">new</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.paste" href="#tkintertable.Tables.TableCanvas.paste">paste</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.pasteCell" href="#tkintertable.Tables.TableCanvas.pasteCell">pasteCell</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.pasteColumns" href="#tkintertable.Tables.TableCanvas.pasteColumns">pasteColumns</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.plotSelected" href="#tkintertable.Tables.TableCanvas.plotSelected">plotSelected</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.plotSetup" href="#tkintertable.Tables.TableCanvas.plotSetup">plotSetup</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.popupMenu" href="#tkintertable.Tables.TableCanvas.popupMenu">popupMenu</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.redraw" href="#tkintertable.Tables.TableCanvas.redraw">redraw</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.redrawCell" href="#tkintertable.Tables.TableCanvas.redrawCell">redrawCell</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.redrawTable" href="#tkintertable.Tables.TableCanvas.redrawTable">redrawTable</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.redrawVisible" href="#tkintertable.Tables.TableCanvas.redrawVisible">redrawVisible</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.resizeColumn" href="#tkintertable.Tables.TableCanvas.resizeColumn">resizeColumn</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.save" href="#tkintertable.Tables.TableCanvas.save">save</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.savePrefs" href="#tkintertable.Tables.TableCanvas.savePrefs">savePrefs</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.select_All" href="#tkintertable.Tables.TableCanvas.select_All">select_All</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.setColPositions" href="#tkintertable.Tables.TableCanvas.setColPositions">setColPositions</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.setFontSize" href="#tkintertable.Tables.TableCanvas.setFontSize">setFontSize</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.setModel" href="#tkintertable.Tables.TableCanvas.setModel">setModel</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.setRowHeight" href="#tkintertable.Tables.TableCanvas.setRowHeight">setRowHeight</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.setSelectedCells" href="#tkintertable.Tables.TableCanvas.setSelectedCells">setSelectedCells</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.setSelectedCol" href="#tkintertable.Tables.TableCanvas.setSelectedCol">setSelectedCol</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.setSelectedRow" href="#tkintertable.Tables.TableCanvas.setSelectedRow">setSelectedRow</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.set_defaults" href="#tkintertable.Tables.TableCanvas.set_defaults">set_defaults</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.set_xviews" href="#tkintertable.Tables.TableCanvas.set_xviews">set_xviews</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.set_yviews" href="#tkintertable.Tables.TableCanvas.set_yviews">set_yviews</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.setcellColor" href="#tkintertable.Tables.TableCanvas.setcellColor">setcellColor</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.setcellbackgr" href="#tkintertable.Tables.TableCanvas.setcellbackgr">setcellbackgr</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.setgrid_color" href="#tkintertable.Tables.TableCanvas.setgrid_color">setgrid_color</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.setrowselectedcolor" href="#tkintertable.Tables.TableCanvas.setrowselectedcolor">setrowselectedcolor</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.show" href="#tkintertable.Tables.TableCanvas.show">show</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.showAll" href="#tkintertable.Tables.TableCanvas.showAll">showAll</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.showFilteringBar" href="#tkintertable.Tables.TableCanvas.showFilteringBar">showFilteringBar</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.show_progressbar" href="#tkintertable.Tables.TableCanvas.show_progressbar">show_progressbar</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.showtablePrefs" href="#tkintertable.Tables.TableCanvas.showtablePrefs">showtablePrefs</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.sortTable" href="#tkintertable.Tables.TableCanvas.sortTable">sortTable</a></code></li>
<li><code><a title="tkintertable.Tables.TableCanvas.updateModel" href="#tkintertable.Tables.TableCanvas.updateModel">updateModel</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>